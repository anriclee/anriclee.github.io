<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TECH on AnricLee's House</title><link>https://anriclee.github.io/categories/tech/</link><description>Recent content in TECH on AnricLee's House</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&amp;copy; &lt;a href="https://github.com/anriclee"> AnricLee &lt;/a></copyright><lastBuildDate>Thu, 13 Jan 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://anriclee.github.io/categories/tech/index.xml" rel="self" type="application/rss+xml"/><item><title>基于 PostgreSQL 的群聊搜索实践</title><link>https://anriclee.github.io/posts/pg/group-search-on-pg/</link><pubDate>Thu, 13 Jan 2022 00:00:00 +0000</pubDate><guid>https://anriclee.github.io/posts/pg/group-search-on-pg/</guid><description>背景 2021年年初，探探上线了群聊功能，并且支持按照群名进行模糊搜索。
对于复杂场景的搜索，业界一般使用非常流行的 ElasticSearch。由于我们的群数据较少，截止到目前还没有达到千万级的量级，且搜索场景比较简单，而 PostgreSQL 对全文搜索又支持得比较好，所以选择了 PostgreSQL 来实现群搜索需求。 在使用 PostgreSQL 做群搜索的过程中，也经历了由简单到复杂的迭代过程，中间也踩了不少坑。 下面的几个例子说明了方案的演进过程和我们的优化思路，希望能够对大家有所帮助。
LIKE 模糊查询 提到模糊搜索，最简单的办法就是对搜索列进行 like 匹配： 在输入词的前后加上 % 即可,如下所示:
SELECT * FROM groups WHERE name LIKE &amp;#39;%探探%&amp;#39;; 这种方案可行是可行了，但是实现过于简单粗暴。对此方案进行测试：
建一张简单的表进行测试，表结构如下：
lixuehan=# \d groups; Table &amp;#34;public.groups&amp;#34; Column | Type | Collation | Nullable | Default --------+-----------------------+-----------+----------+------------------------------------ id | bigint | | not null | nextval(&amp;#39;groups_id_seq&amp;#39;::regclass) name | character varying(50) | | | Indexes: &amp;#34;groups_pkey&amp;#34; PRIMARY KEY, btree (id) 表中只有两列：主键 id 以及群名 name。</description></item><item><title>Examle Article</title><link>https://anriclee.github.io/posts/create-theme/</link><pubDate>Sat, 26 Jun 2021 16:00:21 +0800</pubDate><guid>https://anriclee.github.io/posts/create-theme/</guid><description>Introduction This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I&amp;rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won&amp;rsquo;t cover using CSS to style your theme.
We&amp;rsquo;ll start with creating a new site with a very basic template.</description></item><item><title>Hello</title><link>https://anriclee.github.io/posts/hello/</link><pubDate>Sat, 26 Jun 2021 16:00:21 +0800</pubDate><guid>https://anriclee.github.io/posts/hello/</guid><description>Hello world!</description></item><item><title>Hugo 中的命令行模式</title><link>https://anriclee.github.io/posts/hugo-%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%A8%A1%E5%BC%8F/</link><pubDate>Fri, 26 Jun 2020 22:31:37 +0800</pubDate><guid>https://anriclee.github.io/posts/hugo-%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%A8%A1%E5%BC%8F/</guid><description>最近在用 hugo 构建了个人博客之后，便有兴趣想研究下其源码。但是源码的体量之大，逻辑之复杂出乎我的意料。不过好在源码的结构比较清晰，有许多地方值得借鉴。
比如它的程序入口，非常简洁：
func main() { resp := commands.Execute(os.Args[1:]) if resp.Err != nil { if resp.IsUserError() { resp.Cmd.Println(&amp;quot;&amp;quot;) resp.Cmd.Println(resp.Cmd.UsageString()) } os.Exit(-1) } } 它将所有根据命令行参数传入的指令统一封装到 commands 包中。后面有新命令需求时，只需要新建一个 cmd 文件即可。
它是怎么做到的呢？
简而言之，就是在程序入口处将所有的命令类汇总，然后再根据输入参数args，决定要执行哪个cmd，看似增加了代码的复杂度，但是对于后续命令的扩展显得非常方便。
hugo 中使用了 builder 模式将所有的命令汇总，我这里简单起见，只初始化了一个数组，主要是体会其开闭原则的思想即可。
Talk is cheap, show me the code
借鉴它的思路，我写了一个简化版，可以参看，代码链接.</description></item></channel></rss>