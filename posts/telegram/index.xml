<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Telegram on ReadTinyWord</title>
    <link>http://localhost:1313/posts/telegram/</link>
    <description>Recent content in Telegram on ReadTinyWord</description>
    <generator>Hugo</generator>
    <language>en-US</language>
    
      <managingEditor>anriclee@gmail.com (anriclee)</managingEditor>
    
    
      <webMaster>anriclee@gmail.com (anriclee)</webMaster>
    
    
    <copyright>Copyright © 2024-2025, Rokcso.</copyright>
    
    
    <lastBuildDate>Sat, 11 Jun 2022 11:43:42 +0800</lastBuildDate>
    
    
    <follow_challenge>
        <feedId>00000000000000000</feedId>
        <userId>00000000000000000</userId>
    </follow_challenge>
    
    <atom:link href="http://localhost:1313/posts/telegram/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Telegram bot 入门实践</title>
      <link>http://localhost:1313/posts/telegram_bot/</link>
      <pubDate>Sat, 11 Jun 2022 11:43:42 +0800</pubDate><author>anriclee@gmail.com (anriclee)</author>
      <guid>http://localhost:1313/posts/telegram_bot/</guid>
      <description>&lt;h1 id=&#34;什么是-bot&#34;&gt;什么是 Bot&lt;/h1&gt;&#xA;&lt;p&gt;Bot 的概念在官网的介绍稍微有点繁琐和，详细可以了解&lt;a href=&#34;https://core.telegram.org/bots&#34;&gt;官网介绍&lt;/a&gt;，&lt;/p&gt;&#xA;&lt;p&gt;简单来说，bot 就是你在 telegram 中的一个特殊账号，你申请了 bot，这个 bot 就是你的代理人，你发号施令到 bot，bot 会响应你的指令，仅此而已。&lt;/p&gt;&#xA;&lt;p&gt;申请 bot 需要找 BotFather（名字起的很形象），具体过程官网说的比较详细，此处不赘言。但是需要强调的一点是，bot 仅仅是你的代理人而已，真正执行你指令的是你自己部署的脚本，如果你不部署自己的脚本，在 bot 中输入指令，是没有任何响应的。&lt;/p&gt;&#xA;&lt;p&gt;你、bot和你部署的脚本关系如下:&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/anriclee/diagramStorage/master/telegram.drawio.png&#34; alt=&#34;&amp;ldquo;你、bot和你部署的脚本&amp;rdquo;&#34;&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;脚本&#34;&gt;脚本&lt;/h1&gt;&#xA;&lt;p&gt;上面说过了，bot 只是你在 telegram 的一个代理，真正干活的是你的脚本。既然自己写脚本，就会存在两个问题：接受指令、做出响应。&lt;/p&gt;&#xA;&lt;h2 id=&#34;接受指令&#34;&gt;接受指令&lt;/h2&gt;&#xA;&lt;p&gt;对于如何让脚本接受指令，官方提供了两种思路：推模式 、拉模式。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;拉模式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这种模式，官方不太推荐。简单而言，就是自己部署一个脚本，不断执行 get 请求，获取自己 bot 的更新信息，就好比一个仆人一直在问你：&lt;/p&gt;&#xA;&lt;p&gt;有没有需要我做的？&lt;/p&gt;&#xA;&lt;p&gt;有没有需要我做的？&lt;/p&gt;&#xA;&lt;p&gt;有没有需要我做的？&lt;/p&gt;&#xA;&lt;p&gt;询问的方式也比较简单：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;curl -X GET https://api.telegram.org/bot[token]/getUpdates&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里的 token，就是上面申请 bot 完毕后，得到的 token， 出于脱敏，我使用 [token] 代替，下同。这种方法比较笨拙，轮询的频次太高和太低都不行，而且你在 bot 中发布一条指令后，可能并不能够马上得到执行，会有延迟。&lt;/p&gt;&#xA;&lt;p&gt;这种方式的好处是：可以让 bot 启在本地，不需要部署到服务器上，因为 telegram 不知道你的存在，他也不需要知道你的存在。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;推模式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这种方式是官方比较推荐的一种方式，这种类似事件驱动的原理。只有有任务了，才会通知脚本去做。但前提是：在向 bot 发号施令前，需要在 bot 中注册一个 callback url。&lt;/p&gt;&#xA;&lt;p&gt;bot 在接受你的指令后，会调用此 url，通知你的脚本，让他执行任务。&lt;/p&gt;&#xA;&lt;p&gt;注册方式也比较简单：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;curl -X POST https://api.telegram.org/bot[token]/setWebhook -H &amp;#34;Content-type: application/json&amp;#34; -d &amp;#39;{&amp;#34;url&amp;#34;: &amp;#34;[YOUR_URL]&amp;#34;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用这种方式，会比上一种稍微麻烦一点，需要你部署的服务能够支持 https（这也是为了安全起见）。&lt;/p&gt;&#xA;&lt;h3 id=&#34;响应指令&#34;&gt;响应指令&lt;/h3&gt;&#xA;&lt;p&gt;收到 telegram 的指令后，如何发送消息到 telegram 频道呢？笔者对 golang 较为熟悉，所以采用了 golang 的方式进行响应。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Golang&#34; data-lang=&#34;Golang&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Handler&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ResponseWriter&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Request&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ParseForm&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;parse form values failed:%+v&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;body&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;GetBody&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;bytes&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;io&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ReadAll&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;body&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;msg&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; string(&lt;span style=&#34;color:#a6e22e&#34;&gt;bytes&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;// ...... 读取到 query 参数和 body 后，可以进行各种逻辑操作&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Fprintf&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;result:&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;content&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的代码使用到了一个&lt;a href=&#34;https://github.com/go-telegram-bot-api/telegram-bot-api&#34;&gt;开源库&lt;/a&gt;，他替我们封装好了api（当然也可以自己按照 telegram 的协议组装消息）。&lt;/p&gt;&#xA;&lt;h2 id=&#34;部署脚本&#34;&gt;部署脚本&lt;/h2&gt;&#xA;&lt;p&gt;现在有了 bot，也有了响应 bot 的脚本逻辑，只剩部署脚本到服务器了。我们当然不能仅仅为了响应一条指令租一个个人服务器吧（土豪除外）。&lt;/p&gt;&#xA;&lt;p&gt;笔者用的是 Vercel 平台，使用 Vercel 部署 ServeLess 的 Function 还是比较方便的，部署过程，跟随步骤指导一步一步来比较容易。&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://vercel.com/&#34;&gt;https://vercel.com/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;部署好之后，可以先在本地执行下 curl 请求，测试没问题后，将该 url 设置为 telegram bot 的 callback 函数即可。&lt;/p&gt;&#xA;&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;&#xA;&lt;p&gt;学会一个东西的主要方法，就是疯狂的使用它。本人出入办公单位，都需要扫门禁二维码，不胜其烦，需要关注微信小程序，然后点击门禁二维码，全程既慢且麻烦。&lt;/p&gt;&#xA;&lt;p&gt;在一次偶然抓包之后，发现获取二维码的请求是一个简单的 http post 请求，且密码为明文。&lt;/p&gt;&#xA;&lt;p&gt;这次体验到了 Serveless 的方便，出于 bot 练习之故，可以将该请求封装到 script 中，部署到 vercel 平台上，在 telegram 申请一个门禁机器人，打开之后，发送指令到 script，script 发起 post 调用，获取到结果后，渲染为二维码即可。&lt;/p&gt;&#xA;&lt;p&gt;渲染二维码使用到的&lt;a href=&#34;https://github.com/skip2/go-qrcode&#34;&gt;开源包&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;请求安全性校验&#34;&gt;请求安全性校验&lt;/h2&gt;&#xA;&lt;p&gt;为了安全起见，有人恶意调用你的脚本 url，可以将自己脚本服务的 api 的前缀设置为 token（token 没有人知道，所以也无法知道的 api）。vercel 平台支持通过 vercel.json 进行请求的重定向，可以通过正则表达式，将 &lt;code&gt;randomwdocd23123123[token 示例]/api&lt;/code&gt; 转发到 &lt;code&gt;/api&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Json&#34; data-lang=&#34;Json&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;routes&amp;#34;&lt;/span&gt;:[&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;src&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/random/(?&amp;lt;id&amp;gt;[^/]*)/api/hello/&amp;#34;&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;dest&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/api/hello.go?id=$id&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   ]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这是利用了官方提供的重定向的特性，详细可以参考&lt;a href=&#34;https://vercel.com/docs/project-configuration#&#34;&gt;官网&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;reference&#34;&gt;reference&lt;/h1&gt;&#xA;&lt;p&gt;1.&lt;a href=&#34;https://www.marclittlemore.com/serverless-telegram-chatbot-vercel/&#34;&gt;Build a serverless Telegram chatbot deployed using Vercel&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
  </channel>
</rss>