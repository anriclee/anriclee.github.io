[{"content":"This page explains the new features and changes of PaperModX comparing to the original PaperMod.\nTable of Contents (ToC) floating on the side By adding config:\nparams: TocSide: \u0026#39;left\u0026#39; # or \u0026#39;right\u0026#39; ToC will float on the left/right side of the page. You can take a look at how 'right' feels like in Installation | Update.\nThe ToC box is responsive, it only shows on the side when minimum screen size is 1440px.\nThis feature is enabled on this site.\nInstantClick integration By adding config:\nparams: EnableInstantClick: true InstantClick will be enabled, making navigation behaves like Single Page Application.\nNote that /search pages are omitted from InstantClick to prevent conflicts from search\u0026rsquo;s JavaScript, this may be changed in the future after refactoring those scripts.\nAnother thing to notice is smooth scrolling will be disabled if InstantClick is enabled, because they both listen click event on every \u0026lt;a\u0026gt; tags. IMO smooth scrolling is not very useful so it has to give way to InstantCllick.\nThis feature is enabled on this site.\nGive links an accent color. Though PaperModX is designed to be minimal, accent color is still essential. It\u0026rsquo;s a good way to show personality and make your site feels more delightful.\nThe default color is a purple vibe, you can customize the colors of link, link underline and their hover variants by override the following css variables in assets/css/extended/custom.css of your site.\n:root { --link-color: var(--primary); --link-hover-color: #573eaa; --link-underline-shadow: 0 1px 0 var(--link-color); --link-hover-underline-color: #573eaa; --link-hover-underline-shadow: 0 2px 0 var(--link-hover-underline-color); } Customize pagniator size In section pages, if you want the paginator size be different from the global config, you can add paginate in the frontmatter to customize.\n--- paginate: 10 --- Menus external link You can add external: true to a menu item\u0026rsquo;s params to mark it as an external link, this will add a small icon to the end, and make the link open in new tab when clicked.\nmenu: main: - name: \u0026#34;@Author\u0026#34; url: \u0026#34;https://reorx.com\u0026#34; params: external: true Highlight code with Chroma, no bullshit PaperMod uses highlight.js to highlight code blocks. In PaperModX, we use Chroma which is the recommended way in Hugo\u0026rsquo;s official docs, thus changing theme is easily supported.\nBy default the themes are github for light and dracula for dark, you can change it by adding chroma-light.css and chroma-dark.css in site\u0026rsquo;s assets/css/lib directory.\nSocial icons from Simple Icons Add social icons with -simple suffix from Simple Icons.\nAvailable icons:\ngithub-simple rss-simple telegram-simple twitter-simple pinboard-simple The icons are moved from layouts/partials/svg.html to data/svg.toml, makes it easier to maintain, it\u0026rsquo;s now possible to have an index page to show all the icons, check it out at: Icons Preview\nOpinionated UI enhancements Distinguish home page width and post page width, post page is wider (800px) for better readability, you can change it by --post-width in theme-vars.css. Menu links are always bold, this feels more consistent when clicking around. Active links have deeper color. ","permalink":"http://localhost:1313/docs/papermodx-new-features/","summary":"This page explains the new features and changes of PaperModX comparing to the original PaperMod.","title":"PaperModX New Features"},{"content":"","permalink":"http://localhost:1313/docs/icons_preview/","summary":"Index of all icons in PaperModeX","title":"Icons Preview"},{"content":"最近恒大的暴雷，许家印的败落，一时间甚嚣尘上、沸沸扬扬。之前的时间，许家印还是一个英雄，而现在已经成为了狗熊。看了一些介绍许家印的视频，让我对时势和英雄的关系有了一些思考。\n许家印借着国家发展的东风扶摇直上，凭借敢闯敢干，成为中国首富，又凭借敢闯和敢干，盘子闹得太大，一时无法调头，而致惨淡收场，真是成也萧何，败也萧何。\n时势造英雄还是英雄造时势，这个问题一直争论不休。但是在我心里，有了初步的答案。\n时势和英雄，脱离英雄谈时势与脱离时势谈英雄，都不太妥当。英雄不能超出其所处时代的局限，这就好比，诸葛亮不能想到计算机、曹操不能想到土地革命一样。英雄的思想和观念很大程度上受到当时的教育、观点的传播方式以及科学生产力的影响，他不可能 发明或者创造超越该时代生产力的东西。英雄诞生之后，在很大程度上可以改变一些历史的走向，反而又影响时势，比如没有希特勒这样的人物，二战的进程，可能会推迟很多，没有海森堡这样的科学家推波助澜，原子弹的产生，可能又要往后推迟好多年。\n一句话：时势决定了英雄的上限，英雄决定了自己的下限。\n三国演义开篇词就谈到了英雄。\n浪花淘尽英雄\n英雄只是大江中的几朵大浪而已。\n在我看来，有些人，趁势而起而已，不能算作英雄，只能算作在时代的浪潮中的幸运儿而已。比如我们改革开放时期，借助双轨制的东风，趁势而起的一批人；有些人是随势而起，凭借一己之力，改变了一些东西的，这才可称之为英雄。\n突发奇想，可以对三国期间的人杰按此分类，看看哪些人到底是乘势而起的幸运儿，哪些人乘势而起的英雄。我想一定会非常有趣。\nPS：\n年纪越大，就越对三国演义感兴趣。目光所及，唯有曹老板与刘备二人，曹老板真的是有人格魅力的人，刘老板的矢志不渝，亦颇为动人。在职场中，无论选中的是哪位老板，亦无所憾矣。\n","permalink":"http://localhost:1313/posts/essays/sanguo/","summary":"\u003cp\u003e最近恒大的暴雷，许家印的败落，一时间甚嚣尘上、沸沸扬扬。之前的时间，许家印还是一个英雄，而现在已经成为了狗熊。看了一些介绍许家印的视频，让我对时势和英雄的关系有了一些思考。\u003c/p\u003e\n\u003cp\u003e许家印借着国家发展的东风扶摇直上，凭借敢闯敢干，成为中国首富，又凭借敢闯和敢干，盘子闹得太大，一时无法调头，而致惨淡收场，真是成也萧何，败也萧何。\u003c/p\u003e\n\u003cp\u003e时势造英雄还是英雄造时势，这个问题一直争论不休。但是在我心里，有了初步的答案。\u003c/p\u003e\n\u003cp\u003e时势和英雄，脱离英雄谈时势与脱离时势谈英雄，都不太妥当。英雄不能超出其所处时代的局限，这就好比，诸葛亮不能想到计算机、曹操不能想到土地革命一样。英雄的思想和观念很大程度上受到当时的教育、观点的传播方式以及科学生产力的影响，他不可能\n发明或者创造超越该时代生产力的东西。英雄诞生之后，在很大程度上可以改变一些历史的走向，反而又影响时势，比如没有希特勒这样的人物，二战的进程，可能会推迟很多，没有海森堡这样的科学家推波助澜，原子弹的产生，可能又要往后推迟好多年。\u003c/p\u003e\n\u003cp\u003e一句话：\u003cstrong\u003e时势决定了英雄的上限，英雄决定了自己的下限。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e三国演义开篇词就谈到了英雄。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e浪花淘尽英雄\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e英雄只是大江中的几朵大浪而已。\u003c/p\u003e\n\u003cp\u003e在我看来，有些人，趁势而起而已，不能算作英雄，只能算作在时代的浪潮中的幸运儿而已。比如我们改革开放时期，借助双轨制的东风，趁势而起的一批人；有些人是随势而起，凭借一己之力，改变了一些东西的，这才可称之为英雄。\u003c/p\u003e\n\u003cp\u003e突发奇想，可以对三国期间的人杰按此分类，看看哪些人到底是乘势而起的幸运儿，哪些人乘势而起的英雄。我想一定会非常有趣。\u003c/p\u003e\n\u003cp\u003ePS：\u003c/p\u003e\n\u003cp\u003e年纪越大，就越对三国演义感兴趣。目光所及，唯有曹老板与刘备二人，曹老板真的是有人格魅力的人，刘老板的矢志不渝，亦颇为动人。在职场中，无论选中的是哪位老板，亦无所憾矣。\u003c/p\u003e","title":"英雄与时势"},{"content":"我们离AI越近，就离自己的判断越远。AI 到底会成为人类历史前进的助力还是阻力？这越来越成为在我脑中盘旋的问题。\nAI 的发展，得益于世界上的少数精英对于算法的精进。然而，剩下的大多数，就沦为算法黑盒之外的芸芸众生了。\n当下，开谈不说 AI，读尽诗书也枉然。资本鼓吹大行其道，什么代码会被 AI 代替，艺术会被 AI 代替，一时间，仿佛就差造物主会被 AI 代替了，然而，我们了解自己的痛点么？\n我们以为 AI 可以代替我们做任何事情，实际上，却只能干一小部分事情，剩下的很多事情，AI 并不能替我们做出选择。一句话，因为算法并不是万能的。我们生活中有很多决策，并非是一个公式一个概率所能决定的。比如，婆媳关系，比如，中年危机。\n我们总是倾向于用最省力的办法，解决最复杂的事情。\n先问一下 AI。\nAI 的回答不使我们满意，于是我们请教传统的 AI：风水与命理。\n我们就是不愿意，自己去分析一下当下的处境，调查一下当下所面临的环境，搞清楚当下要解决的事情。\n而这些分析问题的方法、模板以及结论，就在《毛选》中。\n只是，我们从《毛选》中获取到的只是“渔”而非“鱼”。\n在这个快节奏的时代，谁还需要“渔”？即使懂得了“渔”，又有多少时间去实践“渔”？\n思考，是这个时代，最缺乏的东西。\n系统思考，更是稀缺物品。\n","permalink":"http://localhost:1313/posts/essays/mao/","summary":"\u003cp\u003e我们离AI越近，就离自己的判断越远。AI 到底会成为人类历史前进的助力还是阻力？这越来越成为在我脑中盘旋的问题。\u003c/p\u003e\n\u003cp\u003eAI 的发展，得益于世界上的少数精英对于算法的精进。然而，剩下的大多数，就沦为算法黑盒之外的芸芸众生了。\u003c/p\u003e\n\u003cp\u003e当下，开谈不说 AI，读尽诗书也枉然。资本鼓吹大行其道，什么代码会被 AI 代替，艺术会被 AI 代替，一时间，仿佛就差造物主会被 AI 代替了，然而，我们了解自己的痛点么？\u003c/p\u003e\n\u003cp\u003e我们以为 AI 可以代替我们做任何事情，实际上，却只能干一小部分事情，剩下的很多事情，AI 并不能替我们做出选择。一句话，因为算法并不是万能的。我们生活中有很多决策，并非是一个公式一个概率所能决定的。比如，婆媳关系，比如，中年危机。\u003c/p\u003e\n\u003cp\u003e我们总是倾向于用最省力的办法，解决最复杂的事情。\u003c/p\u003e\n\u003cp\u003e先问一下 AI。\u003c/p\u003e\n\u003cp\u003eAI 的回答不使我们满意，于是我们请教传统的 AI：风水与命理。\u003c/p\u003e\n\u003cp\u003e我们就是不愿意，自己去分析一下当下的处境，调查一下当下所面临的环境，搞清楚当下要解决的事情。\u003c/p\u003e\n\u003cp\u003e而这些分析问题的方法、模板以及结论，就在《毛选》中。\u003c/p\u003e\n\u003cp\u003e只是，我们从《毛选》中获取到的只是“渔”而非“鱼”。\u003c/p\u003e\n\u003cp\u003e在这个快节奏的时代，谁还需要“渔”？即使懂得了“渔”，又有多少时间去实践“渔”？\u003c/p\u003e\n\u003cp\u003e思考，是这个时代，最缺乏的东西。\u003c/p\u003e\n\u003cp\u003e系统思考，更是稀缺物品。\u003c/p\u003e","title":"毛选与AI与风水学"},{"content":"","permalink":"http://localhost:1313/posts/bookreading/jobs/","summary":"","title":"乔布斯传"},{"content":"最近有计划做一个系列的技术分享，当然前提是自己需要了解很多东西，去查很多资料。\n平时也看了很多技术分享视频，坦白说，能带给我收获和启发的寥寥。所以，国内的工程师（对，我希望大家都能称为工程师，而不是码农或者程序员）查资料，能看国外的就不会看国内的。\n国内的技术，并不是一定落后于国外很多，但是为什么我们很难有高质量的技术文章出来呢？这可能和我们从小的教育模式有关。\n国内的技术人做的分享，干货最多的，我推左耳朵耗子。前段时间听说他走了的消息，我还一度很悲伤。我的很多技术观念的转变，对于技术人的看法，都是从他的文章受到的启发。他的文章总能带给你不一样的启发，总是能够做到 干货满满。可惜，这么一位我认为纯粹的技术人，就这么走了。健康果然永远是第一位的。不知怎么，我总感觉从这几年开始，一切精致的、理想主义的好的东西，都逐渐在远离我们。\n对于在探探的三年，我学到的技术方面比较硬核的东西不算多，但是，在这段经历中，我受到的一个最大的启发就是，如何去思考技术（这是一位96年的同事带给我的启发）。当今的技术新名词、概念、框架、编程语言等等，层出不穷， 大家都在感叹，要学的东西太多了，自己学不动了。\n出现这种情况的原因，就在于我们永远是被动的接受知识。\n出现一个新的东西，我们总在亦步亦趋地跟学，而很少去主动思考，为什么出现这个东西，这个东西的出现能够解决什么问题？比如最近 Java 21 版本发布，有一个史诗级的更新就是 Java 协程。我们如果不去想，Java 到底出现什么瓶颈 为什么要引入协程的概念，当时设计语言的时候为什么不考虑协程，或者为什么现在才引入，引入后对原来的语言架构有什么破坏性影响等等问题。这些问题没有考虑清楚，就一头扎到协程的实现细节中，我们必然会疲于奔命。\n个人以为学一个新技术需要从以下步骤入手：\n一、搞清楚解决的问题。\n先把这个技术点的前世今生搞清楚，如果这个技术点的引入，只是为了炫技，只是为了蹭热点，那我宁可不学，吾生也有涯，要学的东西实在太多，我才没有必要为此浪费时间呢！而这一层分析，是好多技术文章或者技术视频里面 缺乏的。\n二、如何解决\n搞清楚要解决的现实痛点之后，接着就是要想如果是我们遇到了这个问题，我们该怎么办，它又是怎么做得？这一点可能比第一点更重要。思考这一点的好处多多。\n首先，它能够帮你对这个技术点有个宏观的把握，之后研究这个技术点的时候，你永远有一个明确地导向，你不再会被里面天花乱坠的细节所误导和迷惑。 这就跟交朋友一样，你知道这个人所处的立场后，无论这个人怎么对你施加糖衣炮弹，你都不会为其所展现的表象所迷惑。你永远能够认清楚这个人的本质。用老毛的话来说，就是抓住事务的主要矛盾，透过现象看本质。\n其次，如果我们冥思苦想也想不出更好的方案，然后看人家的实现，觉得既优雅，又简单，这个时候，你就会被它的设计所吸引。你的技术水平便会在无形中有所提高。下次你遇到类似的问题，或者别的问题时，你就会将此想法从此处迁移到彼处。 这就好比写文章一样，给到一个命题，我们自己写一篇，然后再看人家是怎么写的。二者一对比，高下立判。他和你实现的肯定有不同的地方，那么这些不同的地方，不外乎三种情形：\n它不如你 这个时候一定不能傲慢，认为它这样做，就一定不如你。需要慎重考虑为什么这里出现一个表面看起来很明显的不太好的设计（这种情况，往往是因为一些历史原因或者有其特殊的需求背景）。\n如果反复考虑之后，确实没有想出来更好的理由，那么你就可以理解你的设计比他的要高明（它的设计，并不一定都是最优方案，所谓战略上藐视，战术上重视），可以小小地得意一下。\n你不如它 这个时候，你要暗自欣喜，因为你挖到矿了。这个技术点，没有白花时间研究。这就好比，你跟高手过招后，学到了几招新的武功，这是能够提升你的战力的。\n殊途同归 你们的实现方案，各有利弊，各有其明显的缺点或者优点。\n情形 2 和情形 3，都能在很大程度上拓宽你的视野，让你的技术品味升级。\n最后，当前的技术点可能和你的工作没有太直接的关系（比如研究操作系统内核和写业务CRUD），但是里面的一些精髓的设计理念，其实完全可以迁移到业务中去（比如缓存、异步）。操作系统在有些时候，是追求极致的准确和性能的，这一点要求是比 99% 的业务高的。\n三、总结和梳理\n在前两步完成之后，基本上你对这个技术点，算是完全吃透了。这个时候别忘记及时梳理和总结，梳理过后的才会有条理的放在你的技能仓库中，不至遗忘或者记忆错乱。\n","permalink":"http://localhost:1313/posts/essays/tech/","summary":"\u003cp\u003e最近有计划做一个系列的技术分享，当然前提是自己需要了解很多东西，去查很多资料。\u003c/p\u003e\n\u003cp\u003e平时也看了很多技术分享视频，坦白说，能带给我收获和启发的寥寥。所以，国内的工程师（对，我希望大家都能称为工程师，而不是码农或者程序员）查资料，能看国外的就不会看国内的。\u003c/p\u003e\n\u003cp\u003e国内的技术，并不是一定落后于国外很多，但是为什么我们很难有高质量的技术文章出来呢？这可能和我们从小的教育模式有关。\u003c/p\u003e\n\u003cp\u003e国内的技术人做的分享，干货最多的，我推左耳朵耗子。前段时间听说他走了的消息，我还一度很悲伤。我的很多技术观念的转变，对于技术人的看法，都是从他的文章受到的启发。他的文章总能带给你不一样的启发，总是能够做到\n干货满满。可惜，这么一位我认为纯粹的技术人，就这么走了。健康果然永远是第一位的。不知怎么，我总感觉从这几年开始，一切精致的、理想主义的好的东西，都逐渐在远离我们。\u003c/p\u003e\n\u003cp\u003e对于在探探的三年，我学到的技术方面比较硬核的东西不算多，但是，在这段经历中，我受到的一个最大的启发就是，如何去思考技术（这是一位96年的同事带给我的启发）。当今的技术新名词、概念、框架、编程语言等等，层出不穷，\n大家都在感叹，要学的东西太多了，自己学不动了。\u003c/p\u003e\n\u003cp\u003e出现这种情况的原因，就在于我们永远是被动的接受知识。\u003c/p\u003e\n\u003cp\u003e出现一个新的东西，我们总在亦步亦趋地跟学，而很少去主动思考，为什么出现这个东西，这个东西的出现能够解决什么问题？比如最近 Java 21 版本发布，有一个史诗级的更新就是 Java 协程。我们如果不去想，Java 到底出现什么瓶颈\n为什么要引入协程的概念，当时设计语言的时候为什么不考虑协程，或者为什么现在才引入，引入后对原来的语言架构有什么破坏性影响等等问题。这些问题没有考虑清楚，就一头扎到协程的实现细节中，我们必然会疲于奔命。\u003c/p\u003e\n\u003cp\u003e个人以为学一个新技术需要从以下步骤入手：\u003c/p\u003e\n\u003cp\u003e一、搞清楚解决的问题。\u003c/p\u003e\n\u003cp\u003e先把这个技术点的前世今生搞清楚，如果这个技术点的引入，只是为了炫技，只是为了蹭热点，那我宁可不学，吾生也有涯，要学的东西实在太多，我才没有必要为此浪费时间呢！而这一层分析，是好多技术文章或者技术视频里面\n缺乏的。\u003c/p\u003e\n\u003cp\u003e二、如何解决\u003c/p\u003e\n\u003cp\u003e搞清楚要解决的现实痛点之后，接着就是要想如果是我们遇到了这个问题，我们该怎么办，它又是怎么做得？这一点可能比第一点更重要。思考这一点的好处多多。\u003c/p\u003e\n\u003cp\u003e首先，它能够帮你对这个技术点有个宏观的把握，之后研究这个技术点的时候，你永远有一个明确地导向，你不再会被里面天花乱坠的细节所误导和迷惑。\n这就跟交朋友一样，你知道这个人所处的立场后，无论这个人怎么对你施加糖衣炮弹，你都不会为其所展现的表象所迷惑。你永远能够认清楚这个人的本质。用老毛的话来说，就是抓住事务的主要矛盾，透过现象看本质。\u003c/p\u003e\n\u003cp\u003e其次，如果我们冥思苦想也想不出更好的方案，然后看人家的实现，觉得既优雅，又简单，这个时候，你就会被它的设计所吸引。你的技术水平便会在无形中有所提高。下次你遇到类似的问题，或者别的问题时，你就会将此想法从此处迁移到彼处。\n这就好比写文章一样，给到一个命题，我们自己写一篇，然后再看人家是怎么写的。二者一对比，高下立判。他和你实现的肯定有不同的地方，那么这些不同的地方，不外乎三种情形：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e它不如你\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这个时候一定不能傲慢，认为它这样做，就一定不如你。需要慎重考虑为什么这里出现一个表面看起来很明显的不太好的设计（这种情况，往往是因为一些历史原因或者有其特殊的需求背景）。\u003c/p\u003e\n\u003cp\u003e如果反复考虑之后，确实没有想出来更好的理由，那么你就可以理解你的设计比他的要高明（它的设计，并不一定都是最优方案，所谓战略上藐视，战术上重视），可以小小地得意一下。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e你不如它\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这个时候，你要暗自欣喜，因为你挖到矿了。这个技术点，没有白花时间研究。这就好比，你跟高手过招后，学到了几招新的武功，这是能够提升你的战力的。\u003c/p\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e殊途同归\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e你们的实现方案，各有利弊，各有其明显的缺点或者优点。\u003c/p\u003e\n\u003cp\u003e情形 2 和情形 3，都能在很大程度上拓宽你的视野，让你的技术品味升级。\u003c/p\u003e\n\u003cp\u003e最后，当前的技术点可能和你的工作没有太直接的关系（比如研究操作系统内核和写业务CRUD），但是里面的一些精髓的设计理念，其实完全可以迁移到业务中去（比如缓存、异步）。操作系统在有些时候，是追求极致的准确和性能的，这一点要求是比 99% 的业务高的。\u003c/p\u003e\n\u003cp\u003e三、总结和梳理\u003c/p\u003e\n\u003cp\u003e在前两步完成之后，基本上你对这个技术点，算是完全吃透了。这个时候别忘记及时梳理和总结，梳理过后的才会有条理的放在你的技能仓库中，不至遗忘或者记忆错乱。\u003c/p\u003e","title":"关于技术知识点的战术和战略问题"},{"content":"依赖项的详细配置\n正如前面所提到的那样，你可以定义 bean 的属性和构造函数参数，去引用其他已经设置好的 bean 或者内联定义的值。 为了达到这个目的，Spring 的基于 XML 配置元数据支持在 和 元素内增加子元素。\n直接值（基本类型，字符串等等） 元素的 value 值，把一个属性值或者构造函数参数定义为一个可读字符串。Spring 的转换服务被用来将这些值从字符串转换为属性或者参数的实际类型。下面的例子展示了可以被设置的多种值：\n\u0026lt;bean id=\u0026#34;myDataSource\u0026#34; class=\u0026#34;org.apache.commons.dbcp.BasicDataSource\u0026#34; destroy-method=\u0026#34;close\u0026#34;\u0026gt; \u0026lt;!-- results in a setDriverClassName(String) call --\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;com.mysql.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mydb\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;misterkaoli\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 下面的例子使用 p-namespace 来让 XML 配置更加简明：\n\u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:p=\u0026#34;http://www.springframework.org/schema/p\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;myDataSource\u0026#34; class=\u0026#34;org.apache.commons.dbcp.BasicDataSource\u0026#34; destroy-method=\u0026#34;close\u0026#34; p:driverClassName=\u0026#34;com.mysql.jdbc.Driver\u0026#34; p:url=\u0026#34;jdbc:mysql://localhost:3306/mydb\u0026#34; p:username=\u0026#34;root\u0026#34; p:password=\u0026#34;misterkaoli\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; 上面的 XML 更加的简明。然而，类型是在运行时而不是设计时发现的，除非你在创建 bean 定义的时候，用支持自动属性完成的 IDE（例如 Intellij IDEA 或者 Eclipse 的 Spring 工具）。这些辅助都是高度推荐的。 你同样可以配置 java.util.Properties 的实例，如下：\n\u0026lt;bean id=\u0026#34;mappings\u0026#34; class=\u0026#34;org.springframework.context.support.PropertySourcesPlaceholderConfigurer\u0026#34;\u0026gt; \u0026lt;!-- typed as a java.util.Properties --\u0026gt; \u0026lt;property name=\u0026#34;properties\u0026#34;\u0026gt; \u0026lt;value\u0026gt; jdbc.driver.className=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/mydb \u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; Spring 容器可以通过使用 JavaBeans 的 PropertyEditor 机制，转换 元素里面的文本值为一个 java.util.Properties 实例。这是一个不错的捷径，也是为数不多的 Spring 团队偏爱嵌套的 元素而非 value 属性的风格的地方。\nidref 元素 idref 元素就是一个简单的传递容器中另外一个 bean 的 id 到 或者 元素中的防止错误的办法。下面的例子展示了如何去使用它：\n\u0026lt;bean id=\u0026#34;theTargetBean\u0026#34; class=\u0026#34;...\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;theClientBean\u0026#34; class=\u0026#34;...\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;targetName\u0026#34;\u0026gt; \u0026lt;idref bean=\u0026#34;theTargetBean\u0026#34;/\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 上面的 bean 定义片段等价于下面的片段：\n\u0026lt;bean id=\u0026#34;theTargetBean\u0026#34; class=\u0026#34;...\u0026#34; /\u0026gt; \u0026lt;bean id=\u0026#34;client\u0026#34; class=\u0026#34;...\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;targetName\u0026#34; value=\u0026#34;theTargetBean\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 第一种形式优于第二种，因为使用 idref 标签，可以让容器在部署时验证所引用的有名称的 bean 是否真正存在。在第二种变体中，不会验证传给 client bean 中 targetName 属性的值。当 client bean 被真正创建时，才会真正发现这个类型（很有可能是致命错误）。如果 client bean 是一个属性 bean，在容器被部署很长时间后，类型和结果异常才有可能被发现。\nNote：idref 元素中的 local 属性在 XSD 4.0 bean 中的属性不再支持，因为它不再对一个普通 bean 引用提供值了。当升级到 4.0 Schema 的时候，需要修改你的当前存在的 idref local 引用为 idref bean。\n一个\n元素中，\n（早从 Spring 2.0 开始） 元素配置值的一个常见位置就是 ProxyFactoryBean bean 定义中的 AOP 拦截器配置值。当你指定拦截器名称时，使用 元素可防止你误拼写一个拦截器的 ID。\n引用其他 bean（协作器） ref 元素是 或者 定义元素里面的最后一个元素。在这里，你可以将一个 bean 的具体属性设置为对另外一个被容器管理的 bean 的引用。被引用的 bean 是将被设置属性值 bean 的依赖，而且在属性被设置前，根据需要被初始化。（如果协作者是一个单例的 bean，它也许已经被容器初始化了）。所有的引用最终都是另外一个对象的引用。Scope 和验证取决于你通过 bean 或者 parent 属性指定的另外一个对象的 ID 或者名字。\n通过 标签的 bean 属性指定目标 bean，是最常见的一种形式，并且允许引用相同容器或者父容器内的任何 bean，不论是否在同一个 XML 文件中。bean 属性的值也许和目标 bean 的id属性相同，或者和目标 bean 的 name 属性的其中一个值相同。下面的例子展示了怎么使用 ref 元素：\n\u0026lt;ref bean=\u0026#34;someBean\u0026#34;/\u0026gt; 通过 parent 属性指定目标 bean 创建了对当前容器父容器内的一个 bean 的引用。parent 属性的值可以和目标 bean 的 id 属性和 name 属性的其中一个值相同。目标 bean 必须在当前容器的一个父容器中。当你有一个容器的继承结构，并且你想要用和父 bean 一样的名字作为代理包装父容器中的一个现有 bean 的时候，你应该使用这种引用变体。下面的例子展示了如何使用 parent 属性：\n\u0026lt;!-- in the parent context --\u0026gt; \u0026lt;bean id=\u0026#34;accountService\u0026#34; class=\u0026#34;com.something.SimpleAccountService\u0026#34;\u0026gt; \u0026lt;!-- insert dependencies as required here --\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- in the child (descendant) context --\u0026gt; \u0026lt;bean id=\u0026#34;accountService\u0026#34; \u0026lt;!-- bean name is the same as the parent bean --\u0026gt; class=\u0026#34;org.springframework.aop.framework.ProxyFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;target\u0026#34;\u0026gt; \u0026lt;ref parent=\u0026#34;accountService\u0026#34;/\u0026gt; \u0026lt;!-- notice how we refer to the parent bean --\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!-- insert other configuration and dependencies as required here --\u0026gt; \u0026lt;/bean\u0026gt; Note：ref 元素中的 local 属性在 XSD 4.0 中的 bean 已经不再支持，因为它不会对一个普通的 bean 引用提供任何值了。升级到 4.0 Schema 时，需要将现有的 ref local 引用改为 ref bean。\n内部 bean 或者 元素内部的 元素定义了一个内部 bean，如下面的例子所示：\n\u0026lt;bean id=\u0026#34;outer\u0026#34; class=\u0026#34;...\u0026#34;\u0026gt; \u0026lt;!-- instead of using a reference to a target bean, simply define the target bean inline --\u0026gt; \u0026lt;property name=\u0026#34;target\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;com.example.Person\u0026#34;\u0026gt; \u0026lt;!-- this is the inner bean --\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;Fiona Apple\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;25\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 一个内部bean定义不需要定义 ID 和名称。如果指定了，容器也不会用这个值作为标识。容器也会在创建 bean 时忽略 scope 标志，因为内部biean通常是匿名的而且总是与外面的 bean 一起创建。不可能单独只访问内部bean 或者将他们注入到外层嵌套 bean 以外的 bean 中。\n在极端情况下，它会从一个自定义的 scope 接收到销毁的回调 —— 例如，对于一个包含在单例 bean 中的 request scope 的内部 bean。内部 bean 实例的创建于它所在的 bean 绑定在一起，但是销毁回调让它参与到 request 范围的生命周期。这不是一个常见的场景。内部 bean 通常仅仅与它所在的 bean 共享一个 scope。\n集合 , , 和 元素分别设置 Java 的集合类型：List，Set，Map 和 Properties。下面的例子显示了该用法：\n\u0026lt;bean id=\u0026#34;moreComplexObject\u0026#34; class=\u0026#34;example.ComplexObject\u0026#34;\u0026gt; \u0026lt;!-- results in a setAdminEmails(java.util.Properties) call --\u0026gt; \u0026lt;property name=\u0026#34;adminEmails\u0026#34;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026#34;administrator\u0026#34;\u0026gt;administrator@example.org\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;support\u0026#34;\u0026gt;support@example.org\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;development\u0026#34;\u0026gt;development@example.org\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!-- results in a setSomeList(java.util.List) call --\u0026gt; \u0026lt;property name=\u0026#34;someList\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;a list element followed by a reference\u0026lt;/value\u0026gt; \u0026lt;ref bean=\u0026#34;myDataSource\u0026#34; /\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!-- results in a setSomeMap(java.util.Map) call --\u0026gt; \u0026lt;property name=\u0026#34;someMap\u0026#34;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026#34;an entry\u0026#34; value=\u0026#34;just some string\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;a ref\u0026#34; value-ref=\u0026#34;myDataSource\u0026#34;/\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!-- results in a setSomeSet(java.util.Set) call --\u0026gt; \u0026lt;property name=\u0026#34;someSet\u0026#34;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;value\u0026gt;just some string\u0026lt;/value\u0026gt; \u0026lt;ref bean=\u0026#34;myDataSource\u0026#34; /\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; map 的 key 或者 value，或者一个设置好的 value，也可以使下面元素的任意一种：\nbean | ref | idref | list | set | map | props | value | null 集合的并集 Spring 容器同样支持集合的合并。一个应用的开发者可以定义一个父 , , 或者 元素或者有一个子的 , , 或者 元素，来继承或者覆盖父集合中的元素。即，子集合中的值是父集合和子集合中元素的并集，同时子集合中的元素会覆盖父集合中的元素。\n这个合并讨论了父子 bean 的机制。不熟悉父子 bean 定义的读者，也许要在继续往下前读一下相关章节。\n下面的例子展示了集合合并的用法：\n\u0026lt;beans\u0026gt; \u0026lt;bean id=\u0026#34;parent\u0026#34; abstract=\u0026#34;true\u0026#34; class=\u0026#34;example.ComplexObject\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;adminEmails\u0026#34;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026#34;administrator\u0026#34;\u0026gt;administrator@example.com\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;support\u0026#34;\u0026gt;support@example.com\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;child\u0026#34; parent=\u0026#34;parent\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;adminEmails\u0026#34;\u0026gt; \u0026lt;!-- the merge is specified on the child collection definition --\u0026gt; \u0026lt;props merge=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;prop key=\u0026#34;sales\u0026#34;\u0026gt;sales@example.com\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;support\u0026#34;\u0026gt;support@example.co.uk\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;beans\u0026gt; 注意子 bean 定义中 adminEmails 属性里 merge=true 属性的用法。当子bean被容器解析和初始化时，最终的实例会有一个包含合并子集合中 adminEmails 和父集合中的 adminEmails 的 adminEmails 和 Properties 集合。下面的列表会展示最终的结果\nadministrator=administrator@example.com sales=sales@example.com support=support@example.co.uk 子 Properties 集合中设置的值继承了所有父 中的属性值，而且子集合中的 support 值覆盖了父集合中的值。\n这个合并的行为同样适用于 , , 类型。在 元素的特殊使用中，与 List 集合类型联系的语义（即集合中值的有序性）会一直保持。父集合中的值优先于子集合。在 Map, Set 和 Properties 集合类型中是无序的。因此，容器内部使用的 Map, Set 和 Properties 实现类型中没有有序性的语义生效。\n集合合并的限制 空串或者 Null p-namespace 的 XML 简写 c-namespace 的 XML 简写 复合属性名称 TO BE CONTINUED \u0026hellip;.\n","permalink":"http://localhost:1313/posts/spring_framework/core/the_ioc_container/dependencies/dependencies_configuration_in_detail/","summary":"\u003cp\u003e依赖项的详细配置\u003c/p\u003e\n\u003cp\u003e正如前面所提到的那样，你可以定义 bean 的属性和构造函数参数，去引用其他已经设置好的 bean 或者内联定义的值。\n为了达到这个目的，Spring 的基于 XML 配置元数据支持在 \u003cproperty/\u003e 和 \u003cconstructor-arg/\u003e 元素内增加子元素。\u003c/p\u003e\n\u003ch1 id=\"直接值基本类型字符串等等\"\u003e直接值（基本类型，字符串等等）\u003c/h1\u003e\n\u003cp\u003e\u003cproperty/\u003e 元素的 value 值，把一个属性值或者构造函数参数定义为一个可读字符串。Spring 的转换服务被用来将这些值从字符串转换为属性或者参数的实际类型。下面的例子展示了可以被设置的多种值：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-XML\" data-lang=\"XML\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003e\u0026lt;bean\u003c/span\u003e \u003cspan class=\"na\"\u003eid=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;myDataSource\u0026#34;\u003c/span\u003e \u003cspan class=\"na\"\u003eclass=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;org.apache.commons.dbcp.BasicDataSource\u0026#34;\u003c/span\u003e \u003cspan class=\"na\"\u003edestroy-method=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;close\u0026#34;\u003c/span\u003e\u003cspan class=\"nt\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"c\"\u003e\u0026lt;!-- results in a setDriverClassName(String) call --\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nt\"\u003e\u0026lt;property\u003c/span\u003e \u003cspan class=\"na\"\u003ename=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;driverClassName\u0026#34;\u003c/span\u003e \u003cspan class=\"na\"\u003evalue=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;com.mysql.jdbc.Driver\u0026#34;\u003c/span\u003e\u003cspan class=\"nt\"\u003e/\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nt\"\u003e\u0026lt;property\u003c/span\u003e \u003cspan class=\"na\"\u003ename=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;url\u0026#34;\u003c/span\u003e \u003cspan class=\"na\"\u003evalue=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;jdbc:mysql://localhost:3306/mydb\u0026#34;\u003c/span\u003e\u003cspan class=\"nt\"\u003e/\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nt\"\u003e\u0026lt;property\u003c/span\u003e \u003cspan class=\"na\"\u003ename=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;username\u0026#34;\u003c/span\u003e \u003cspan class=\"na\"\u003evalue=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;root\u0026#34;\u003c/span\u003e\u003cspan class=\"nt\"\u003e/\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nt\"\u003e\u0026lt;property\u003c/span\u003e \u003cspan class=\"na\"\u003ename=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;password\u0026#34;\u003c/span\u003e \u003cspan class=\"na\"\u003evalue=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;misterkaoli\u0026#34;\u003c/span\u003e\u003cspan class=\"nt\"\u003e/\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003e\u0026lt;/bean\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e下面的例子使用 p-namespace 来让 XML 配置更加简明：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-XML\" data-lang=\"XML\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003e\u0026lt;beans\u003c/span\u003e \u003cspan class=\"na\"\u003exmlns=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;http://www.springframework.org/schema/beans\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"na\"\u003exmlns:xsi=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"na\"\u003exmlns:p=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;http://www.springframework.org/schema/p\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"na\"\u003exsi:schemaLocation=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;http://www.springframework.org/schema/beans\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003e\thttps://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u003c/span\u003e\u003cspan class=\"nt\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nt\"\u003e\u0026lt;bean\u003c/span\u003e \u003cspan class=\"na\"\u003eid=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;myDataSource\u0026#34;\u003c/span\u003e \u003cspan class=\"na\"\u003eclass=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;org.apache.commons.dbcp.BasicDataSource\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"na\"\u003edestroy-method=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;close\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"na\"\u003ep:driverClassName=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;com.mysql.jdbc.Driver\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"na\"\u003ep:url=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;jdbc:mysql://localhost:3306/mydb\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"na\"\u003ep:username=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;root\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"na\"\u003ep:password=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;misterkaoli\u0026#34;\u003c/span\u003e\u003cspan class=\"nt\"\u003e/\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003e\u0026lt;/beans\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e上面的 XML 更加的简明。然而，类型是在运行时而不是设计时发现的，除非你在创建 bean 定义的时候，用支持自动属性完成的 IDE（例如 Intellij IDEA 或者 Eclipse 的 Spring 工具）。这些辅助都是高度推荐的。\n你同样可以配置 \u003ccode\u003ejava.util.Properties\u003c/code\u003e 的实例，如下：\u003c/p\u003e","title":"[译] 细谈依赖和配置"},{"content":"在依赖注入（DI）里，对象通过构造函数参数、工厂方法参数或者在 被工厂方法创建返回的对象中设置的属性定义他们的依赖。然后，容器在创建这些 bean 时，注入依赖。这个过程与 bean 自身使用所需要类的直接构造函数实例化，或者通过 Service Locator 模式来找到所需要的依赖这个过程正好相反。\n使用 DI 原则的代码更加干净整洁，并且提供给对象的依赖时，解耦也更加高效。对象并不找他们的依赖也并不知道这些依赖的地址或者类。这样的结果就是，你的类变得更易测试，尤其是当依赖是接口或者抽象的父类时，在单元测试可以对这些依赖进行打桩或者mock他们的实现。\n基于构造函数的依赖注入 基于构造函数的依赖注入，是通过容器调用构造函数，并且传入若干参数来实现的，每一个参数都代表了一个依赖。调用静态工厂方法并传入特定的参数来构造一个 bean 也是一样的，在本讨论中，对待构造函数的参数和静态方法的参数也是相似的。下面的这里展示了一个之能通过构造函数来进行依赖注入的类：\npublic class SimpleMovieLister { // the SimpleMovieLister has a dependency on a MovieFinder private final MovieFinder movieFinder; // a constructor so that the Spring container can inject a MovieFinder public SimpleMovieLister(MovieFinder movieFinder) { this.movieFinder = movieFinder; } // business logic that actually uses the injected MovieFinder is omitted... } 注意，对于这个类没有更多特殊的地方。它仅仅是一个POJO，并且对容器特定接口、父类或者注解没有任何依赖。【译者按：没有任何代码侵入性】\n构造函数参数解析 构造函数参数解析匹配通过参数类型来进行。如果在构造函数参数的 bean 定义中没有歧义，那么在 bean 定义中构造函数参数的顺序，就是当 bean 被实例化时，传给给构造函数参数的顺序。考虑下面的类：\npackage x.y; public class ThingOne { public ThingOne(ThingTwo thingTwo, ThingThree thingThree) { // ... } } 假设 ThingTwo 和 ThingThree 不是继承关系，并且没有歧义。你不需要指定在 元素中的顺序或者类型，下面的配置一样会正常起作用。\n\u0026lt;beans\u0026gt; \u0026lt;bean id=\u0026#34;beanOne\u0026#34; class=\u0026#34;x.y.ThingOne\u0026#34;\u0026gt; \u0026lt;constructor-arg ref=\u0026#34;beanTwo\u0026#34;/\u0026gt; \u0026lt;constructor-arg ref=\u0026#34;beanThree\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;beanTwo\u0026#34; class=\u0026#34;x.y.ThingTwo\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;beanThree\u0026#34; class=\u0026#34;x.y.ThingThree\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; 当引用另外一个 bean 的时候，类型已知，即可以适配到。当使用一个简单的类型时，例如 \u0026lt;value\u0026gt;true\u0026lt;/value\u0026gt; ，Spring 不能决定一个 value 的类型，因此不能在没有任何帮助时，适配到具体的类型。考虑下面的类：\npackage examples; public class ExampleBean { // Number of years to calculate the Ultimate Answer private final int years; // The Answer to Life, the Universe, and Everything private final String ultimateAnswer; public ExampleBean(int years, String ultimateAnswer) { this.years = years; this.ultimateAnswer = ultimateAnswer; } } 在上面的场景中，如果你通过 type 属性显式地指定一个构造函数参数类型，容器就可以使用简单的类型匹配，如下面的例子所示：\n\u0026lt;bean id=\u0026#34;exampleBean\u0026#34; class=\u0026#34;examples.ExampleBean\u0026#34;\u0026gt; \u0026lt;constructor-arg type=\u0026#34;int\u0026#34; value=\u0026#34;7500000\u0026#34;/\u0026gt; \u0026lt;constructor-arg type=\u0026#34;java.lang.String\u0026#34; value=\u0026#34;42\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 你可以使用 index 属性指定构造函数参数的顺序，如下面的例子所示：\n\u0026lt;bean id=\u0026#34;exampleBean\u0026#34; class=\u0026#34;examples.ExampleBean\u0026#34;\u0026gt; \u0026lt;constructor-arg index=\u0026#34;0\u0026#34; value=\u0026#34;7500000\u0026#34;/\u0026gt; \u0026lt;constructor-arg index=\u0026#34;1\u0026#34; value=\u0026#34;42\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; Note: index 从 0 开始。\n你也可以使用构造函数参数名来消除歧义，如下面的例子所示：\n\u0026lt;bean id=\u0026#34;exampleBean\u0026#34; class=\u0026#34;examples.ExampleBean\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;years\u0026#34; value=\u0026#34;7500000\u0026#34;/\u0026gt; \u0026lt;constructor-arg name=\u0026#34;ultimateAnswer\u0026#34; value=\u0026#34;42\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 需要记住的是，为了开箱即用的效果，你的代码必须在编译时将 debug 标识打开，以便 Spring 可以通过名字从构造器查看参数名。如果你不能或者不想再编译时把 debug 标志打开，你可以使用 @ConstructorProperties JDK 注解对构造函数参数显式地指定名字。下面的例子展示了示例类的样子：\npackage examples; public class ExampleBean { // Fields omitted @ConstructorProperties({\u0026#34;years\u0026#34;, \u0026#34;ultimateAnswer\u0026#34;}) public ExampleBean(int years, String ultimateAnswer) { this.years = years; this.ultimateAnswer = ultimateAnswer; } } 基于 Setter 函数的依赖注入 基于 Setter 的依赖注入，是通过容器在调用无参构造函数或者无参静态工厂方法来实例化 bean 之后，调用 bean 中的 setter 方法来完成的。\n下面的例子展示了一个类可以仅通过单纯的 setter 注入完成依赖注入。这个类是传统的 Java。这是一个对具体的接口，基类或者注解没有依赖的 POJO。\npublic class SimpleMovieLister { // the SimpleMovieLister has a dependency on the MovieFinder private MovieFinder movieFinder; // a setter method so that the Spring container can inject a MovieFinder public void setMovieFinder(MovieFinder movieFinder) { this.movieFinder = movieFinder; } // business logic that actually uses the injected MovieFinder is omitted... } ApplicationContext 支持对其管理的 bean，进行基于构造函数和setter函数的依赖注入。它同样也支持通过构造函数已经注入后，基于 setter 的依赖注入。你用 BeanDefinition 的形式配置了依赖，结合 PropertyEditor 实例，将属性值从一种形式转换为另外一种形式，然而，大部分 Spring 的用户不是直接使用这些类（即，代码的方式），而是使用 XML bean 定义，注解组件（即，有 @Component 和 @Controller 等等装配的类）或者在基于 Java @Configuration 类的 @Bean 方法。这些源在内部被转换成 BeanDefinition 实例，并且被用来加载整个 Spring IoC 容器实例。\n基于构造函数或者基于 setter 的依赖注入？\n因为你可以混合基于构造函数和基于Setter的依赖注入，对必要的依赖使用构造函数，对可选依赖使用 Setter 方法或者配置方法是一个很好的经验法则。注意，在 setter 方法上使用 @Autowired 注解可以用来使这个属性成为一个必要的依赖；然而，通过构造函数注入，并且在代码中验证参数的有效性是值得考虑的。\nSpring 团队通常提倡构造函数的依赖注入，因为这会让你将应用程序的组件实现为不可变对象，并且能够确保必要的依赖是非空的。而且，通过构造函数注入返回的组件是一个完全初始化的状态。一个数量较多参数的构造函数，是一种坏味道，暗示着这个类很可能有诸多的职责，应该需要重构，以更好地解决适当的关注点分离的问题。\n基于 Setter 的注入，应该仅被用于可以被赋予默认值的可选依赖。否则，非空检测，必须在使用依赖的任何地方进行。setter 注入的好处之一是 setter 方法使该类的对象可以在以后重新配置或重新注入。因此，通过 JMX MBean 进行管理是 setter 注入的一个引人注目的用例。\n使用 DI 风格对一些类具有最重要的意义。有时候，当处理你没有源码的第三方类的时候，这是你的选择。例如，如果一个三方类没有暴露任何 setter 方法，构造函数的注入或许会是依赖注入的唯一形式。\n依赖的解决过程 容器对 bean 的依赖解决过程如下：\n创建 ApplicationContext 时用描述所有 bean 的配置元数据一起初始化。配置元数据可以通过 XML，Java代码或者注解表达 对于每一个 bean，它的依赖是以属性、构造函数参数、或者静态工厂方法（如果你用之代替普通的构造器）的参数的形式来表示的。这些依赖在 bean 被实际上创建后，提供给 bean 每个属性或者构造器参数，是一个要设置值得实际上定义，或者容器内对另外一个 bean 的引用 作为值的每一个属性或者构造器参数，都被从其指定的格式转换为属性或者构造函数参数实际上的类型。默认，Spring 可以转换一个字符串类型的值为所有的自建类型，例如 int、lang、String、boolean 等等。 Spring 容器在其被创建时，会对所有的bean的配置进行有效性验证。然而，这些 bean 的属性直到 bean 被实际上创建的时候，才会被设置进去。单例类型且设置为预初始化（默认）的 bean，将会在容器创建时被创建。Scopes 时 Bean Scopes 中定义的。其他的 bean，在 bean 被实际请求时创建。创建一个 bean 会潜在的引起依赖图中的 bean 被创建，bean的依赖和依赖的依赖的创建和分配过程亦然。注意，这些依赖之间的解析不匹配可能会较晚出现 - 即，在第一个受影响的 bean 被创建时出现。\n循环依赖\n如果你主要使用构造器的注入模式，很可能会出现一个无法解决的循环依赖场景。\n例如：类 A 通过构造注入依赖一个类 B 的实例，类 B 通过构造注入依赖一个一个类 A 的实例。如果你配置类 A 和类 B 互相注入，Spring Ioc 容器在运行时检测到循环依赖，即会抛出 BeanCurrentlyInCreationException。\n一个可能的解决办法就是，编辑一些类中的源码，让他们通过 setter 注入而非构造器。也可以选择避免构造器注入，只使用 setter 注入。换句话说，虽然不是很推荐，但是你依赖可以通过 setter 注入配置循环依赖。\n与典型的例子（没有循环依赖）不同，一个bean A 和 bean B 的循环依赖，迫使其中的一个 bean 在自己完全初始化之前注入另外一个优先级更高的 bean（一个典型的鸡生蛋蛋生鸡问题）。\n你通常可以相信 Spring 会做正确的事情。它可以在容器加载的时候检测到配置问题，比如引用不存在的 bean 和循环依赖。Spring 会在 bean 被实际上创建后，尽可能晚地设置属性和解决依赖。当你请求一个对象，如果在创建这个对象或者它的依赖有问题时，一个被正确加载的 Spring 容器可以在稍后抛出异常。 —— 例如，bean 会因为属性丢失或者无效引发异常。这些配置问题的延迟出现就是为什么 ApplicationContext 的实现默认是预初始化的单例 bean。在 bean 实际需要之前，以前期的时间和内存为代价来创建这些 bean。你会在 ApplicationContext 被创建的时候，发现配置问题。你仍然可以覆盖这个默认的行为，以便单例的 bean 可以被延迟初始化而不是过早的初始化。\n如果没有循环依赖存在，当一个或者多个合作的 bean 被注入到一个需要依赖的 bean 时，每一个协作的 bean 会在注入到依赖的 bean 前被完全配置。这意味着，如果 bean A 对 bean B 有依赖，Spring IoC 容器在调用 bean A 的方法之前，将 bean B 完全配置好。换句话说，bean 被实例化后，它的依赖早已被设置好了，它的生命周期方法也早已被调用了。\n依赖注入的例子 下面的例子使用了基于 XML 的配置元数据，用来做基于 setter 的 DI。Spring XML 配置文件指定了一些 bean 定义如下：\n\u0026lt;bean id=\u0026#34;exampleBean\u0026#34; class=\u0026#34;examples.ExampleBean\u0026#34;\u0026gt; \u0026lt;!-- setter injection using the nested ref element --\u0026gt; \u0026lt;property name=\u0026#34;beanOne\u0026#34;\u0026gt; \u0026lt;ref bean=\u0026#34;anotherExampleBean\u0026#34;/\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!-- setter injection using the neater ref attribute --\u0026gt; \u0026lt;property name=\u0026#34;beanTwo\u0026#34; ref=\u0026#34;yetAnotherBean\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;integerProperty\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;anotherExampleBean\u0026#34; class=\u0026#34;examples.AnotherBean\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;yetAnotherBean\u0026#34; class=\u0026#34;examples.YetAnotherBean\u0026#34;/\u0026gt; 下面的例子展示了对应的 ExampleBean 类：\npublic class ExampleBean { private AnotherBean beanOne; private YetAnotherBean beanTwo; private int i; public void setBeanOne(AnotherBean beanOne) { this.beanOne = beanOne; } public void setBeanTwo(YetAnotherBean beanTwo) { this.beanTwo = beanTwo; } public void setIntegerProperty(int i) { this.i = i; } } 在前面的例子中，声明 setter 方法去定义 XML 文件中的属性。下面的例子使用了基于构造函数的 DI：\n\u0026lt;bean id=\u0026#34;exampleBean\u0026#34; class=\u0026#34;examples.ExampleBean\u0026#34;\u0026gt; \u0026lt;!-- constructor injection using the nested ref element --\u0026gt; \u0026lt;constructor-arg\u0026gt; \u0026lt;ref bean=\u0026#34;anotherExampleBean\u0026#34;/\u0026gt; \u0026lt;/constructor-arg\u0026gt; \u0026lt;!-- constructor injection using the neater ref attribute --\u0026gt; \u0026lt;constructor-arg ref=\u0026#34;yetAnotherBean\u0026#34;/\u0026gt; \u0026lt;constructor-arg type=\u0026#34;int\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;anotherExampleBean\u0026#34; class=\u0026#34;examples.AnotherBean\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;yetAnotherBean\u0026#34; class=\u0026#34;examples.YetAnotherBean\u0026#34;/\u0026gt; 下面的例子展示了对应的 ExampleBean 类：\npublic class ExampleBean { private AnotherBean beanOne; private YetAnotherBean beanTwo; private int i; public ExampleBean( AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) { this.beanOne = anotherBean; this.beanTwo = yetAnotherBean; this.i = i; } } bean 定义中指定的构造函数中的参数，被用作 ExampleBean 构造函数中的参数。\n现在考虑这个例子的一个变形，而不是使用构造函数。Spring 被告知调用静态工厂方法来返回一个对象的实例。\n\u0026lt;bean id=\u0026#34;exampleBean\u0026#34; class=\u0026#34;examples.ExampleBean\u0026#34; factory-method=\u0026#34;createInstance\u0026#34;\u0026gt; \u0026lt;constructor-arg ref=\u0026#34;anotherExampleBean\u0026#34;/\u0026gt; \u0026lt;constructor-arg ref=\u0026#34;yetAnotherBean\u0026#34;/\u0026gt; \u0026lt;constructor-arg value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;anotherExampleBean\u0026#34; class=\u0026#34;examples.AnotherBean\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;yetAnotherBean\u0026#34; class=\u0026#34;examples.YetAnotherBean\u0026#34;/\u0026gt; 下面的例子展示了相应的 ExampleBean 类：\npublic class ExampleBean { // a private constructor private ExampleBean(...) { ... } // a static factory method; the arguments to this method can be // considered the dependencies of the bean that is returned, // regardless of how those arguments are actually used. public static ExampleBean createInstance ( AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) { ExampleBean eb = new ExampleBean (...); // some other operations... return eb; } } 元素提供了静态工厂方法中的参数，就如同一个构造函数被实际上使用。工厂方法返回 class 的类型，不一定要和包含静态方法的类是一个类型（尽管在这个例子中相同）。一个实例的非静态工厂方法可以用本质上同样的方式来使用（使用 factory-bean 属性代替 class 属性除外），所以我们在这里就不多赘述了。\n[全文完]\n","permalink":"http://localhost:1313/posts/spring_framework/core/the_ioc_container/dependencies/dependency_injection/","summary":"\u003cp\u003e在依赖注入（DI）里，对象通过构造函数参数、工厂方法参数或者在\n被工厂方法创建返回的对象中设置的属性定义他们的依赖。然后，容器在创建这些 bean 时，注入依赖。这个过程与 bean 自身使用所需要类的直接构造函数实例化，或者通过 Service Locator 模式来找到所需要的依赖这个过程正好相反。\u003c/p\u003e\n\u003cp\u003e使用 DI 原则的代码更加干净整洁，并且提供给对象的依赖时，解耦也更加高效。对象并不找他们的依赖也并不知道这些依赖的地址或者类。这样的结果就是，你的类变得更易测试，尤其是当依赖是接口或者抽象的父类时，在单元测试可以对这些依赖进行打桩或者mock他们的实现。\u003c/p\u003e\n\u003ch1 id=\"基于构造函数的依赖注入\"\u003e基于构造函数的依赖注入\u003c/h1\u003e\n\u003cp\u003e基于构造函数的依赖注入，是通过容器调用构造函数，并且传入若干参数来实现的，每一个参数都代表了一个依赖。调用静态工厂方法并传入特定的参数来构造一个 bean 也是一样的，在本讨论中，对待构造函数的参数和静态方法的参数也是相似的。下面的这里展示了一个之能通过构造函数来进行依赖注入的类：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Java\" data-lang=\"Java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eSimpleMovieLister\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\t\u003c/span\u003e\u003cspan class=\"c1\"\u003e// the SimpleMovieLister has a dependency on a MovieFinder\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\t\u003c/span\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003efinal\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eMovieFinder\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003emovieFinder\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\t\u003c/span\u003e\u003cspan class=\"c1\"\u003e// a constructor so that the Spring container can inject a MovieFinder\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\t\u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003eSimpleMovieLister\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eMovieFinder\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003emovieFinder\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\t\t\u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003emovieFinder\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003emovieFinder\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\t\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\t\u003c/span\u003e\u003cspan class=\"c1\"\u003e// business logic that actually uses the injected MovieFinder is omitted...\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e注意，对于这个类没有更多特殊的地方。它仅仅是一个POJO，并且对容器特定接口、父类或者注解没有任何依赖。【译者按：没有任何代码侵入性】\u003c/p\u003e","title":"[译] 依赖注入"},{"content":"中秋绝句\n癸卯秋夜，虽炎热潮湿，开窗无月，然心情大好，咏志抒怀，无碍也，是为序。\n自来霜雪映吴钩，半生浮云半生幽\n未有三旬寂寞守，何能一夜照清秋\n","permalink":"http://localhost:1313/posts/essays/poems/","summary":"\u003cp\u003e中秋绝句\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e癸卯秋夜，虽炎热潮湿，开窗无月，然心情大好，咏志抒怀，无碍也，是为序。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e自来霜雪映吴钩，半生浮云半生幽\u003c/p\u003e\n\u003cp\u003e未有三旬寂寞守，何能一夜照清秋\u003c/p\u003e","title":"中秋绝句"},{"content":"AOP 通过提供另外一种关于程序结构的思考方式补充了面向对象编程（OOP ）。在 OOP 中模块的关键单元是 class，而在 AOP 中，模块的关键是 Aspect（切面）。切面支持跨多个对象和类型的关注点模块化（比如事务的管理）。在 AOP 中这种关注点通常被叫做 “跨领域” 关注点。\nSpring 的一个核心组件就是 AOP 框架。虽然 Spring IoC 容器并不依赖于 AOP（意思是如果不想用 AOP 可以不用），但是 AOP 对 Spring IoC 做了一个补充，提供了一种功能非常强大的中间件解决方案。\nSpring AOP 和 切面切点\nSpring 提供了简单而高效的方式来自定义切面，可以通过基于 schema 的方法也可以通过 @AspectJ 注解的风格。当使用 Spring AOP 来织入时，这两种风格都提供了充分类型的 advice 和 AspectJ 的切点语言。\n这张主要讨论 schema 和 @Aspect 的 AOP 支持。AOP 底层的支持在下面的一章节会讨论到。\nAOP 在 Spring 框架中的用途：\n提供声明式的企业级服务。最重要的就是声明式事务管理 让用户实现自定义的切面作为他们用 AOP 实现 OOP 的补充。 Note：如果你对通用的声明式服务或者其他预先打包的声明式中间件服务感兴趣，你不用直接和 Spring AOP 直接打交道，可以跳过本章的大部分地方。\nAOP 概念 让我们从一些核心的 AOP 概念和术语出发。这些术语并不只是 Spring 特有的。不幸地是，AOP 术语并不符合直觉。然而，如果 Spring 使用它自己的术语，或许会更加令人迷惑。\nAspect：跨多个 class 的关注点模块化。事务处理是一个在企业级 Java 应用中跨领域关注点的很好例子。在 Spring AOP 中，使用普通的类实现切面（基于 schema 的方式）或者使用带有 @Aspect 注解的普通类实现（@Aspect 风格） Join point：程序执行过程中的一个点，例如方法的执行或者异常的处理。在 Spring AOP 中，一个 Join point 总代表一个方法的执行。 Advice：Aspect 在一个特殊的 Join point 中要执行的操作，不同类型的 Advice 包括 around（环绕），before（事前） 和 after（事后）。（Advice 的类型会在稍后讨论）。许多 包括 Spring 在内的 AOP 的框架，对 advice 建模为一个拦截器，围绕着 Join point 维持一个拦截器的链路。 Pointcut：与 Join point 进行匹配的谓词。Advice 总是和一个 Pointcut 表达式联系在一起，并且会在任何匹配到 Pointcut 的 Join point 执行（例如，一个有特定的名字的方法的执行）。通过 Pointcut 表达式匹配的 Join point 的概念是 AOP 的核心，Spring 默认使用 AspectJ pointcut 表达式语言。 Introduction：代表一种类型声明其他的方法或者字段。Spring AOP 可以让你对任何 advised（被 Advice 的） 对象引入新的接口（包含一个相应的实现）。例如，你可以使用 Introduction 让一个 bean 实现一个 IsModified 接口，以此实现简单的缓存。（在 Aspect 社区里，一个 Introduction 被视作一个类型间的声明） 目标对象：被一个或者多个 Aspect 进行 Advice 的对象。同样也被视为 Advice 对象。因为 Spring AOP 通过使用动态代理实现，这个对象永远是一个代理对象。 AOP 代理：AOP 框架为了实现 Aspect 契约（如 advise 方法执行等等）而创建的一个对象。在 Spring 框架中，一个 AOP 代理就是 JDK 动态代理或者 CGLIB 代理 Weaving（织入）：连接 Aspect 和其他的应用类型或者对象来创建一个 advised 对象。它可以在编译时（例如使用 AspectJ编译器）、加载时、或者运行时完成。Spring AOP，如其他的纯 Java AOP 框架一样，在运行时执行织入。 【译者按：1. 这些技术术语翻译为中文有点怪，不太合适，与其强行翻译，不如直接用原生的英文术语。】 Spring AOP 包括下面类型的 advice：\n事前 advice ：在一个 join point 前执行的 advice，但并没有能力阻止下一个 join point 的执行（除非它抛出异常） 事后 advice ：在一个 join point 正常结束后，要运行的 advice（例如，一个没有抛出异常的方法的返回） 异常 advice ：如果一个方法异常退出，则运行该 advice 最终 advice后： join point 存在无论如何要执行的 advice（正常结束或者异常退出） 环绕 advice：在方法调用前后要执行的 advice。这是最强大的一种 advice。环绕 advice 可以在方法执行前后可以执行自定义的行为。它同时要对选择是否执行到下一个 joint point 还是通过正常返回值或者抛出异常来中断执行 advised 方法。 环绕 advice 是最常见的一种 advice。因为 Spring AOP，像 AspectJ 提供了 advice 的所有类型，我们推荐你使用可以实现预期行为的最小 advice 类型。例如，如果你仅仅需要在方法返回值后，更新缓存，你最好使用一个事后 advice 而不是一个环绕 advice，虽然环绕 advice 也可以完成相同的事情。使用最合适的 advice 类型可以提供一种简单的编程模型，尽可能地减少错误的发生率。例如，你不必要在环绕 advice 里面的 JoinPoint 调用 proceed 方法，因此，你就不会调用失败。\n所有的 advice 参数都是静态类型，以便你可以使用 合适类型的 advice 参数，而非 Object 数组。\n通过 pointcut 匹配的 join point 的概念是 AOP 的关键，这也是它与仅提供拦截器的老技术不同的地方。Pointcut 可以使 advice 能够更具有针对性，脱离面向对象的继承关系。例如，你可以通过提供一个声明式事务管理来对一系列跨多对象（例如 service 层的所有业务操作）的方法应用一个环绕 advice。\nSpring AOP 的能力和目标 Spring AOP 使用纯 Java 实现。没有特殊编译过程的必要。Spring AOP 不用控制类加载器关系，因此适合使用在 servelet 容器或者应用服务器中。\nSpring AOP 当前仅支持方法的 Join point （在 Spring 的 bean 里面的方法的执行添加 advice）。字段拦截没有实现，虽然无需破坏核心的 Spring AOP 接口就可以添加对字段的支持。如果你需要对字段的访问和更新进行 advice，考虑使用例如一种叫 AspectJ 的语言。\nSpring 的 AOP 方法和大部分其他的 AOP 框架的不同。它的目标不是为了提供最完备的 AOP 实现（虽然 Spring AOP 是非常强悍的）。它的目标是提供一个 AOP 实现和 Spring IoC 之间更加紧密的整合，以便能够帮助解决企业级应用的一些常见问题。\n因此，Spring 框架的 AOP 能力通常与 Spring IoC 容器一起使用。通过使用正常的 bean 定义语法可以对 Aspects 进行配置（尽管这允许强大的自动代理能力）。这是一个不同于其他 AOP 实现的显著不同点。你使用 Spring AOP 不能高效和轻易地做诸如对一个精细的对象（典型地，例如领域对象）进行 advice。AspectJ 在这些场景下是最好的选择。然而，我们的经验是，Spring AOP 提供对企业级 Java 应用大部分问题的非常出色的解决方案，这对 AOP 是一个补充。\nSpring AOP 从来不刻意和 AspectJ 进行竞争，来提供一个全面的解决方法。我们相信像 Spring AOP 这样的基于代理的框架和像 AspectJ 的非常成熟的框架都是非常有意义的，他们之间是互补的而不是竞争的。Spring 无缝整合了 Spring AOP、IoC 和 AspectJ，为了让基于 Spring 的应用架构能够使用所有的 AOP。这样的整合不影响 Spring AOP 接口或者 AOP 的 Alliance 接口。Spring AOP 保持向下兼容。对于 Spring AOP 接口的讨论，参考下一章。\nNote：Spring 框架的一个核心的原则就是无侵入性。这个观点就是你不应该被强迫引入框架专用的类和接口到你的业务模块或者领域模块。然而，在一些地方，Spring 框架确实给你了选择来引入 Spring 框架专用的依赖到你的代码库。给你这样的选择的理由就是在特定的场景下，或许使用这种方式能够使得代码更易读或者更易编写一些特定功能的代码。然而，Spring 框架（几乎）总是给你选择：你拥有慎重决定选择最适合你的使用场景的自由。\n与本章相关的这样一个决定就是选择哪种 AOP 框架（哪种 AOP 风格）。你可以选择 AspectJ，Spring AOP 或者两种都选择。你同样可以选择使用 @AspectJ 的注解风格方法或者 Spring XML 配置风格方法。本章首先选择引入 @Aspect 风格方法，并不是 Spring 团队偏好这种风格。\nAOP 代理 Spring AOP 默认使用标准 JDK 代理来做 AOP 代理。这让任何接口（或者接口集）都能够被代理。\nSpring AOP 同样可以使用 CGLIB 代理。代理类而非接口的场景下，这是必须的。默认情况，如果一个业务对象没有实现接口，就会用 CGLIB 。考虑面向接口而非类编程是一个最佳实践，业务类通常会实现一个或者多个业务接口。强制使用 CGLIB 也是可以的，在那些你需要对没有在接口中声明的方法进行 advice 或者你需要以一个具体的类型传递一个代理对象到一个方法的地方（希望这些场景不是很多）。\n牢牢把握 Spring AOP 是基于代理这个事实是非常重要的。\n@AspectJ 支持 @AspectJ 指的是一种将带有注解的普通类声明为 aspect 的风格。@AspectJ 风格在 AspectJ 5 中被 AspectJ 项目引入。Spring 使用 AspectJ 提供的库进行 pointcut 解析和匹配，对于同样的注解与 AspectJ 5 的相同。尽管如此，AOP 运行时仍然是纯 Spring AOP，且没有依赖任何 AspectJ 编译器或者织入器。\nNote：使用 AspectJ 编译器和织入器来允许完整的 AspectJ 语言，在 Using AspectJ with Spring Applications. 进行了讨论。\n打开 @AspectJ 为了在 Spring 配置中使用 @AspectJ ，你需要让 Spring 支持基于 @AspectJ 的 AOP 配置和基于是否被那些 Aspect advice 的 bean 做自动代理。通过自动代理，我们的意思是，如果 Spring 决定一个 bean 被一个或者多个 aspect advice，它通常会对那个 bean 来生成一个代理，来拦截方法的执行，在需要的时候，允许 advice 运行。\n@AspectJ 支持可以通过 XML 或者 Java 配置来打开。无论哪一种方法，你都需要确保 AspectJ 的 aspectjweaver.jar 库在你应用程序的类路径上。这个库在 AspectJ 的 lib 目录下或者 Maven 中央仓库里面都可以找到。\n使用 Java 配置打开 @AspectJ 通过 Java @Configuration 支持 @AspectJ，添加 @EnableAspectJAutoProxy 注解。如下面的例子所示：\n@Configuration @EnableAspectJAutoProxy public class AppConfig { } 通过 XML 配置打开 @AspectJ 通过基于 XML 的配置，使能 @AspectJ 的支持，需要使用 aop:aspectj-autoproxy 元素，如下面的例子所示：\n\u0026lt;aop:aspectj-autoproxy/\u0026gt; 这假设你使用了 schema 支持。\n声明一个 Aspect @AspectJ 支持打开后，在你应用 context 中任何带有 @AspectJ aspect 的 bean 类都会被 Spring 自动检测到，并用来配置 Spring AOP。下面的两个例子，展示了定义一个不是非常有用的 aspect 所必要的最少步骤。\n第一个例子展示了在应用 context 里面的一个普通定义，指向了一个带有 @Aspect 注解的 bean 类。\n\u0026lt;bean id=\u0026#34;myAspect\u0026#34; class=\u0026#34;com.xyz.NotVeryUsefulAspect\u0026#34;\u0026gt; \u0026lt;!-- configure properties of the aspect here --\u0026gt; \u0026lt;/bean\u0026gt; 第二个例子，展示了带有 @Aspect 注解的 NotVeryUsefulAspect 类定义：\npackage com.xyz; import org.aspectj.lang.annotation.Aspect; @Aspect public class NotVeryUsefulAspect { } Aspects（带有 @Aspect 注解的类），可以有方法和字段，和其他类一样。他们也可以包含 pointcut，advice 和 introduction。\nNote：你可以在 Spring 的 XML 配置中以普通 bean 的形式注册 aspect 类，通过在 @Configuration 类中使用 @Bean 的方法，或者让 Spring 通过类路径扫描的方式来自动检测 ———— 和其他 Spring 管理的 bean 一样。然而，注意 @Aspect 注解对于类路径的自动检测来讲，是不够的。出于这个目的，你需要增加一个独立的 @Component 注解（或者，作为备选，一个满足让 Spring 可以扫描到的自定义的注解类型）。\nNote：在 Spring AOP 中，aspect 不能是其他 Aspect 中 advice 的目标。@Aspect 注解标记这个类是一个 aspect，因此它不会被自动代理。\n声明一个 Pointcut Pointcut 决定感兴趣的 join point，因此当 advice 运行时，可以让我们实现控制。Spring AOP 仅支持 Spring bean 中方法执行的 join point，因此你可以认为一个 pointcut 就是 Spring bean 中药执行的方法的匹配。一个 point 声明有两部分：包含名称和任意参数的签名以及一个决定我们对哪些方法执行感兴趣的 pointcut 表达式。在一个 @AspectJ 注解风格的 AOP 中，一个 pointcut 的签名通过普通方法定义的的形式来提供，一个pointcut表达式通过使用 @Pointcut 注解来标明（作为 pointcut 签名方法必须有一个 void 返回类型）。\n下面一个例子或许会使 pointcut 的签名和 pointcut 表达式之间的区别更加明显。下面的例子定义了一个叫 anyOldTransfer 的 pointcut，它匹配了所有叫 transfer 的方法的执行。\n@Pointcut(\u0026#34;execution(* transfer(..))\u0026#34;) // the pointcut expression private void anyOldTransfer() {} // the pointcut signature 组成 pointcut 注解值的表达式是一个普通的 AspectJ 表达式。\n支持的 pointcut 指示符 Spring AOP 在 pointcut 表达式中支持下面的 AspectJ pointcut 指示符（PCD）：\nexecution：匹配方法执行的 join point。当使用 Spring AOP 时，这个是最主要的 PCD within：限制匹配具有特定类型的 join point（当使用 Spring AOP 时，在匹配类型内的声明方法的执行） this：限制匹配 join point，此时 bean 引用是一个给定类型的实例。 target：限制连接点的匹配，此时目标对象是一个给定类型的实例 args：限制匹配 join point，此时参数是给定类型的注解 @target：限制 join point 的匹配，此时被执行的对象的类有一个给定类型的注解 @args：限制 join point 的匹配，传递参数的运行类型有给定类型的注解 @within：限制匹配到有给定注解类型的 join point（使用 Spring AOP 时，具有给定注解类型的方法的执行） @annotation：限制匹配 join point （在 Spring AOP 中运行的方法），其主题有一个给定注解 其他 pointcut 类型\n完整的 AspectJ pointcut 语言支持额外在 Spring 中不支持的 pointcut 指示符：call, get, set, preinitialization, staticinitialization, initialization, handler, adviceexecution, withincode, cflow, cflowbelow, if, @this, 以及 @withincode. 在 Spring AOP 的 pointcut 表达式中使用这些指示符，会抛出 IllegalArgumentException 异常。\n这套 pointcut 指示符回叙在将来会被 Spring AOP 支持。\n因为 Spring AOP 限制了仅对方法执行的 join point 做匹配，前面的关于 pointcut 指示符的定义有了比你在 Aspect 语言指南中更狭义的定义。除此之外，AspectJ 自身也有基于类型的语义，而且，在一个 join point 执行的地方，this 和 target 都指向一个相同的对象：执行方法的对象。Spring AOP 是基于代理的系统，在代理对象本身和其后面所代理的对象之间会有所区分。\nNote：因为 Spring AOP 框架的基于代理的本质，根据定义，在目标对象里面的调用不会被拦截。对于 JDK 代理，仅仅调用 public 接口方法可以被拦截。在 CGLIB 中，在代理对象上的 public 和 protected 方法调用可以被拦截（如有必要，甚至包级别可见的方法）。然而，在代理之间的公共交互，应该设计为 public 签名\n注意，pointcut 定义一般会匹配到任何被拦截到的方法。如果一个 pointcut 严格意义上是仅为 public，即使在一个 CGLIB 代理场景中，通过代理进行潜在地非 public 的交互，也需要对其进行相应的定义。\n如果你的拦截需要包括在目标类中的方法调用甚至构造函数的调用，考虑基于 Spring 驱动的 native Aspect 织入，而非 Spring 的基于代理的 AOP 框架。这形成了一个具有不同特点的不同的 AOP 的使用，所以确保在做决定之前，要对织入比较熟悉。\nSpring AOP 同样支持一个额外的叫 bean 的 PCD。这个 PCD 能让你限制 join point 到一个特定的 Spring bean 或者一系列命名的 Spring Bean （当使用通配符）。这个 bean PCD 有下面的形式：\nbean(idOrNameOfBean)\nidOrNameOfBean 符号可以为任意 Spring bean 的名字。限制的通配符使用 * 符号，如果你建立了一些对 Spring beans 的命名习惯，你可以写一个 bean PCD 表达式来选择他们。这对于其他的 pointcut 指示符也适用，bean PCD 也可以与 \u0026amp;\u0026amp;（与），||（或），!（非） 操作符一起使用。\nNote：bean PCD 仅仅在 Spring AOP 中支持，而非 native AspectJ 织入中。它是一种 Spring 独有的对 AspectJ 定义的标准 PCD 的扩展，因此，在 @Aspect 模型中定义的 aspect 不能使用。\nbean PCD 在实例级别进行操作（在 Spring bean 命名概念上构建），而非仅在类级别。基于实例的 pointcut 指示符是一个基于 Spring 代理的 AOP 框架与 Spring bean 工厂之间的特殊能力，在此中，通过名字标识具体的 bean 非常自然和直观。\nPointcut 表达式之间的组合 你可以使用 \u0026amp;\u0026amp;,||,! 组合 pointcut 表达式，你也可以通过名字来引用 pointcut 表达式。下面的例子展示了三种 pointcut 表达式\npackage com.xyz; public class Pointcuts { @Pointcut(\u0026#34;execution(public * *(..))\u0026#34;) public void publicMethod() {} @Pointcut(\u0026#34;within(com.xyz.trading..*)\u0026#34;) public void inTrading() {} @Pointcut(\u0026#34;publicMethod() \u0026amp;\u0026amp; inTrading()\u0026#34;) public void tradingOperation() {} } publicMethod 匹配所有的 public 方法的 join point 的执行 inTrading 匹配 trading 模块下的方法执行 tradingOperation 匹配在 trading 模块下的任意 public 执行 在小的有名字的 pointcuts 的基础上构建更加复杂的 pointcut 表达式，是最佳实践。当通过名字引用 pointcut 时，普通的 Java 可见性规则同样适用（你可以看到同类型里的 private pointcut，继承关系中的 protected pointcut，任何地方的 public pointcuts 等等）。可见性并不影响 pointcut 的匹配。\n共享命名的 pointcut 定义 在使用企业级应用时，开发者经常需要引用应用的模块和在若干 aspects 中的特定的操作集合。出于此目的，我们建议定义一个能够包含常用的有名字的 pointcut 表达式专门的类。这样的一个类通常组合了下面的 CommonPointcuts 示例（怎么命名这个类取决于你）。\npackage com.xyz; import org.aspectj.lang.annotation.Pointcut; public class CommonPointcuts { /** * 这是一个在 web 层的 join point，定义在 com.xyz.web 包里面 * 或者这个包下面的任何子包 */ @Pointcut(\u0026#34;within(com.xyz.web..*)\u0026#34;) public void inWebLayer() {} /** * 这是一个服务层的 join point，如果一个方法定义在 com.xyz.service * 包中或者这个包下面的任意子包 */ @Pointcut(\u0026#34;within(com.xyz.service..*)\u0026#34;) public void inServiceLayer() {} /** * 定义在数据接入层的一个 join point，如果方法定义在 com.xyz.dao * 包中或者此包下面的任意子包 */ @Pointcut(\u0026#34;within(com.xyz.dao..*)\u0026#34;) public void inDataAccessLayer() {} /** * 一个业务类是在 service 接口上的定义的任意方法的执行。这个定义假设接口都在 service * 包中，所有的接口实现类都在子包中 * * 如果你通过功能对这些 service 接口分组（例如在 com.xyz.abc.service 包和 com.xyz.def.service 包，那么 pointcut 表达式 \u0026#34;execution(* com.xyz..service.*.*(..))\u0026#34; 就可以使用 * * 作为备选，你可以使用 bean PCD 来写表达式，例如 \u0026#34;bean(*Service)\u0026#34;。（这假设你已经以一个一贯的方式对你的 Spring service beans 命名 */ @Pointcut(\u0026#34;execution(* com.xyz..service.*.*(..))\u0026#34;) public void businessService() {} /** * 一个数据接入操作，是定义在 DAO 接口层中的任意方法的执行。这个定义假设接口在 dao 包内，实现类型在子包内 */ @Pointcut(\u0026#34;execution(* com.xyz.dao.*.*(..))\u0026#34;) public void dataAccessOperation() {} } 在任意你需要一个 pointcut 表达式的地方，你可以通过引用一个 class 的全限定名与 @Pointcut 方法名的组合引用定义在这样的类里面的 pointcut。例如，为了使你的服务层是事务的，你可以写下面的引用了 com.xyz.CommonPointcuts.businessService() 中的命名的 pointcut：\n\u0026lt;aop:config\u0026gt; \u0026lt;aop:advisor pointcut=\u0026#34;com.xyz.CommonPointcuts.businessService()\u0026#34; advice-ref=\u0026#34;tx-advice\u0026#34;/\u0026gt; \u0026lt;/aop:config\u0026gt; \u0026lt;tx:advice id=\u0026#34;tx-advice\u0026#34;\u0026gt; \u0026lt;tx:attributes\u0026gt; \u0026lt;tx:method name=\u0026#34;*\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;/tx:attributes\u0026gt; \u0026lt;/tx:advice\u0026gt; 例子 Spring AOP 用户很可能使用 execution pointcut 指示符最多。一个 execution 表达式的格式如下：\nexecution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?) 除了返回类型模式（在前面代码片段中的 ret-type-pattern）、命名模式、参数模式之外，所有的部分都是可选的。返回类型的模式决定了方法返回的类型必须是什么样才能匹配一个 join point。* 是作为返回类型最频繁使用的。它匹配任何返回类型。一个全限定类型名仅仅匹配返回类指定类型的方法。命名模式匹配方法名。你可以使用 * 通配符作为一个命名模式的部分或者全部。如果你指定了一个声明类型的模式，请添加一个后缀 . 来满足命名模式。参数模式稍微有些复杂：() 匹配一个无参方法，(..) 匹配有任意参数的方法（包含0个）。(*) 匹配有一个任意类型参数的方法。 (*,String) 匹配一个接受两个参数的方法。第一个可以为任意类型，第二个必须是一个 String。\n下面的例子展示了一些常用的 pointcut 表达式：\n任意 public 方法的执行 execution(public * *(..))\n任意以 set 开头作为方法名的方法 execution(* set*(..))\n任意通过 AccountService 接口定义的方法 execution(* com.xyz.service.AccountService.*(..)) 任意定义在 service 包里的方法的执行 execution(* com.xyz.service.*.*(..))\n定义在 service 包或者其中一个子包的任意方法的执行 execution(* com.xyz.service..*.*(..))\n任意在 service 包里面的 join point（仅在 Spring AOP 中的方法的执行） within(com.xyz.service.*)\n任意在 service 包里面或者子包里面的 join point（仅在 Spring AOP 方法执行） within(com.xyz.service..*)\n一个代理实现了 AccountService 接口的 join point（仅在 Spring AOP 中的方法执行） this(com.xyz.service.AccountService)\n目标对象实现了 AccountService 接口的 join point target(com.xyz.service.AccountService)\n接受一个参数，并且在运行时传入的时候是可序列化的（仅在 Spring AOP） args(java.io.Serializable)\n注意例子中给出的 pointcut 与 execution(* *(java.io.Serializable)) 不同。如果运行时传入的参数是可序列化的，并且如果方法签名声明了一个可序列化类型，执行版本匹配\n一个 target 对象有一个 @Transactional 注解的 join point。 @target(org.springframework.transaction.annotation.Transactional)\n目标对象的声明类型有一个 @Transactional 的 join point @within(org.springframework.transaction.annotation.Transactional)\n执行方法有一个 @Transactional 注解的 join point（仅在 Spring AOP） @annotation(org.springframework.transaction.annotation.Transactional)\n接受当个参数，且参数的运行时类型有 @Classified 注解的 join point @args(com.xyz.security.Classified)\n在一个叫 tradeService 的 Spring bean 中的 join point（仅在 Spring AOP 中适用） bean(tradeService)\n匹配通配符 *Service 的 Spring bean 中的 join point bean(*Service)\n写好 Pointcut 在编译过程中，Aspect 为了优化匹配性能，按顺序处理 pointcut 。检查代码，确定是否每一个匹配指定 pointcut 的 join point 为一个耗时的过程。（动态匹配意味着匹配不能通过静态分析完全确定，且代码中有相应的测试用例来确定在代码运行时是否真有一个匹配）。在第一次遇到 pointcut 声明时，AspectJ 为了匹配过程，会重写为一个优化格式。什么意思呢？简单说，pointcut 被重写为 DNF（Disjunctive Normal Form）而且 pointcut 的组件被排序，以便那些求值代价更小的被优先检测。这意味着你无需关心不同的 pointcut 指示符的性能，可以以任意顺序提供 pointcut 声明。\n然而，AspectJ 仅能按照命令行事。为了匹配性能的最大化，你应该考虑你想达到什么效果，并尽可能地在定义时缩小你的匹配空间。当前的指示符本质上可以归为三组：kinded、scoping、contextual。\nkinded 指示符选择一种特殊的 join point：execution、get、set、call、handler scoping 指示符从一组 join point 中选择：within、withincode contextual 指示符基于上下文进行匹配：this、target、@annotation 一个号的 pointcut 应该至少包括两个类型（kinded和 scoping）。你可以包含 contextual 指示符来基于 join point 上下文匹配或者在使用 advice 时绑定上下文。假设仅有一种指示符或者仅有一个 contextual 指示符可以起作用，但是会由于额外的处理或者分析影响织入性能（时间或者内存大小）。scoping 指示符匹配非常快，使用他们意味着 AspectJ 可以非常快地忽略无需进一步处理的 join point 组。一个好的 pointcut 应该尽可能地址包含一种。\n声明一个 advice TO BE CONTINUED\ncurl -H \u0026lsquo;Content-Type: application/json\u0026rsquo; -d \u0026lsquo;{\u0026ldquo;msgtype\u0026rdquo;: \u0026ldquo;text\u0026rdquo;, \u0026ldquo;text\u0026rdquo;: { \u0026ldquo;content\u0026rdquo;: \u0026ldquo;抢到票了！！！！\u0026rdquo; }\u0026rsquo; \u0026lsquo;https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=bbd844f1-f88e-4b6b-87bb-f5a47c78c217'\n","permalink":"http://localhost:1313/posts/spring_framework/core/spring_aop/concept/","summary":"\u003cp\u003eAOP 通过提供另外一种关于程序结构的思考方式补充了面向对象编程（OOP ）。在 OOP 中模块的关键单元是 class，而在 AOP 中，模块的关键是 Aspect（切面）。切面支持跨多个对象和类型的关注点模块化（比如事务的管理）。在 AOP 中这种关注点通常被叫做 “跨领域” 关注点。\u003c/p\u003e\n\u003cp\u003eSpring 的一个核心组件就是 AOP 框架。虽然 Spring IoC 容器并不依赖于 AOP（意思是如果不想用 AOP 可以不用），但是 AOP 对 Spring IoC 做了一个补充，提供了一种功能非常强大的中间件解决方案。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eSpring AOP 和 切面切点\u003c/p\u003e\n\u003cp\u003eSpring 提供了简单而高效的方式来自定义切面，可以通过基于 schema 的方法也可以通过 @AspectJ 注解的风格。当使用 Spring AOP 来织入时，这两种风格都提供了充分类型的 advice 和 AspectJ 的切点语言。\u003c/p\u003e\n\u003cp\u003e这张主要讨论 schema 和 @Aspect 的 AOP 支持。AOP 底层的支持在下面的一章节会讨论到。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003eAOP 在 Spring 框架中的用途：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e提供声明式的企业级服务。最重要的就是声明式事务管理\u003c/li\u003e\n\u003cli\u003e让用户实现自定义的切面作为他们用 AOP 实现 OOP 的补充。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNote：如果你对通用的声明式服务或者其他预先打包的声明式中间件服务感兴趣，你不用直接和 Spring AOP 直接打交道，可以跳过本章的大部分地方。\u003c/p\u003e\n\u003ch1 id=\"aop-概念\"\u003eAOP 概念\u003c/h1\u003e\n\u003cp\u003e让我们从一些核心的 AOP 概念和术语出发。这些术语并不只是 Spring 特有的。不幸地是，AOP 术语并不符合直觉。然而，如果 Spring 使用它自己的术语，或许会更加令人迷惑。\u003c/p\u003e","title":"[译] Spring AOP 概念"},{"content":"","permalink":"http://localhost:1313/posts/xxl_job/","summary":"","title":"XXL Job 调度框架源码解析"},{"content":"一个 Sring IoC 容器可以操作一个或者多个 bean。这些 bean 是通过你提供给容器的配置元数据生成的（例如，以 XML 中的 \u0026lt;bean/\u0026gt; ）。\n在容器内，这些 bean 的定义被表示成 BeanDefinition 对象的形式，包含了下面的元数据：\n包定义的类名：通常是定义的 bean 的真正实现类 bean 行为配置元素，表明了 bean 在 container 中的行为（scope，生命周期回调等等）。 对其他需要的 bean 的引用。这些引用也被称作协作器和依赖。 在一个新创建的对象中的其他配置设置 - 例如，池的数量限制或者一个操作连接池 bean 中的连接数量 这些元数据转换为构成这些 bean 定义的一系列属性。下表表示了这些属性值：\n属性 含义 Class 正在实例化的bean Name bean的名字 Scope Bean的Scope 构造函数参数 依赖注入 自动装配模式 装配的协作对象 懒加载模式 懒加载 Bean 初始化方法 初始化回调 析构方法 析构回调 除了包含怎么创建一个特定的 bean 的信息之外， ApplicationContext 的实现同样允许在容器外面已经创建好的对象注册到其中（用户创建）。这是通过 getBeanFactory 方法获取到 ApplicationContext 的 BeanFactory，得到 DefaultListableBeanFactory 实现来做到的。DefaultListableBeanFactory 支持通过调用 registerSingleton(..) 和 registerBeanDefinition(..) 方法来实现这样的注册。然而，典型的应用程序仅仅使用常规的 bean 定义元数据。\nNote：bean 的元数据和手工提供的单例对象，需要被尽可能早地注册，以便容器在自动装配期间和其他内省的步骤中，可以对他们做出合理的推断。尽管覆盖现有的元数据和单例对象在某种程度上可以支持，但是官方并不支持在运行时注册新的 bean，这很可能会导致并发获取的异常，bean 容器中不一致的状态，或者两者都有。\nBean 命名 每个 bean 都有至少一个标识。这些标识必须在持有 bean 的容器中保持唯一。一个 bean 通常仅有一个标识。然而，如果需要不止一个，额外的可以被认为是别名。\n在基于 XML 的配置元数据中，你可以使用 id 属性，name 属性或者两者一起确定唯一的 bean。id 属性让你确定唯一的一个 id。按照习惯，这些名字都由字母或者数字组成，但是他们也可以包含特殊字符。如果你想对这些 bean 引入其他的别名，你也可以通过使用 , ; 空格 作为分隔符的 name 属性。尽管 id属性已经被定义为 xsd:string 类型，容器中还是bean 的 id 唯一性是由容器强制执行的，而不是通过 XML 解析器。\n对一个 bean 提供 name 或者 id 属性并不是必须的。如果你不希望显式地提供 name 或者 id，容器会对这个 bean 生成一个唯一的名字。但是，如果你想通过名字引用这个 bean，通过 ref 元素或者 Service Locator 的模式来找，你必须提供 name 属性。在使用内部的 bean 或者自动装配时，可以不提供 name 属性。\nBean 名字惯例\n当给一个 bean 命名时，惯例是使用标准 Java 实例中对成员变量名。这也就是 bean 的名字必须以一个小写字母开始，并且是驼峰的形式。这样的例子如：accountManager，accountService，userDao，loginController 等等。\n对 bean 命名的一致性，可以使你的配置更易读且易懂。而且，如果你使用 Spring 的 AOP 机制，当通过名字来对一系列 bean 提供一个 bean 是非常有用的。\nNote：当在 classpath 下进行 component 扫描时，Spring 会遵循前面描述的规则对没有命名的 component 生成名字：实质上，就是采用一个简单的类名，并且把首字母变为小写。然而，在不止包含一个字母并且首字母和第二个字母都大写的特殊情形下，原来的就会被继续保留。这些规则与 java.beans.Introspector.decapitalize 中定义的相同（Spring 把他们用在这里了）。\n对在 BeanDefinition 之外的 bean 起别名 在 bean 定义自身中个，你可以通过使用 id 属性和在 name 属性中定义任意数量的名字对 bean 提供不止一个名字。这些名字相当于 bean 的别名，在某些情况下比较有用，例如，让应用程序中的每一个 component 都通过使用相对于这个 component 中的特定的 bean 名称来引用一个相同的依赖。\n但是，在 bean 实际上被定义的地方里设置所有的别名，并不总是合适的。当这个 bean 在别的地方也定义的时候，有时候需要引入这个 bean 的别名。这在一个配置文件跨越多个子系统的大系统时且每个子系统都有自己的一套 bean 定义时，是非常常见的。在基于 XML 的配置元数据中，你可以使用 \u0026lt;alias/\u0026gt; 元素来完成这项任务。下面的例子表示了怎么使用：\n\u0026lt;alias name=\u0026#34;fromName\u0026#34; alias=\u0026#34;toName\u0026#34;/\u0026gt; 在这个例子中，一个叫 fromName 的 bean，在使用这个别名定义后，也可以通过 toName 来引用到。\n例如，对子系统 A 中的配置元数据，可以通过 subsystemA-dataSource 引用到 DataSrouce。在子系统 B 中也可以通过使用 subsystemB-dataSource 引用到。当构成一个同时使用到这两个子系统的主应用程序时，主应用程序可以通过 myApp-dataSource 名字来引用到 DataSource。你可以在配置元数据中增加下面的别名定义，来使所有三个名字引用到相同的对象：\n\u0026lt;alias name=\u0026#34;myApp-dataSource\u0026#34; alias=\u0026#34;subsystemA-dataSource\u0026#34;/\u0026gt; \u0026lt;alias name=\u0026#34;myApp-dataSource\u0026#34; alias=\u0026#34;subsystemB-dataSource\u0026#34;/\u0026gt; 现在每一个 component 和主应用都可以通过一个唯一且不与其他 bean 定义冲突的名字引用到dataSource。，但他们都指向同一个 bean。\nJava 配置\n如果你使用 Java 配置，@Bean 注解同样也可以用来提供别名。\nBean 的实例化 一个 bean 定义本质上就是创建一个或者对个对象的菜谱。当容器被索要 bean 的时候，容器查看这个 bean 的菜谱，使用被 bean 定义封装好的配置元数据来创建一个真正的对象。\n如果你使用 XML 配置元数据，你可以在 元素的 class 属性中，指定要实例化对象的类型或者（类名）。这个 class 属性通常是强制的（通常是 BeanDefinition 实例中的 Class 属性）。你可以使用下面两种方法之一来使用 Class 属性：\n通常，在容器本身直接通过反射调用构造函数创建 bean 的地方，直接指定要被构建的类，在某种程度上相当于在 Java 代码中使用new 操作符\n通过指定包含创建这个对象静态工厂方法的类，容器调用这个类的静态工厂方法创建 bean，这是一个不太常见的用法。静态工厂方法返回的对象类型也许和此类相同或者完全不同\n嵌套的类名\n如果你想对一个嵌套类定义配置 bean 定义，你可以使用这个嵌套类的二进制名或者源文件名\n例如，如果在 com.example 包里有一个类叫 SomeThing，并且这个 SomeThing 类有一个叫 OtherThing 的静态嵌套类，他们可以通过 $ 或者 . 符号分割，所以 bean 定义中的 class 属性值会是：com.example.SomeThing$OtherThing 或者 com.example.SomeThing.OtherThing.\n通过构造器实例化 当你通过构造器的方式来创建 bean，所有普通类都可以被使用并且与 Spring 兼容。也就是说，正在被开发的类没必要实现任何特殊的接口或者用一种特殊的方式编码。只需要指定 bean 的类就足够了。然而，根据你为了创建特定 bean 选择的 IoC类型，你也许会需要一个默认（空的）构造器。\nSpring IoC 容器几乎可以操作任何你想操作的类。并不仅限于操作真正的 JavaBean。大部分 Spring 的用户更偏爱使用只包含一个无参构造器，合适的 setter 和 getter 建模的 JavaBean。你也可以在你的容器中使用更多的非 bean 风格的类。例如，如果你需要使用一个遗留下来的绝对没有遵循 JavaBean 规范的连接池，Spring 同样操作它。\n在下面的基于 XML 配置元数据例子中，你可以指定你的 bean 类：\n\u0026lt;bean id=\u0026#34;exampleBean\u0026#34; class=\u0026#34;examples.ExampleBean\u0026#34;/\u0026gt; \u0026lt;bean name=\u0026#34;anotherExample\u0026#34; class=\u0026#34;examples.ExampleBeanTwo\u0026#34;/\u0026gt; 通过静态方法实例化 当定义一个你想通过静态工厂方法创建的 bean 时，需要使用 class 属性指定包含这个静态工厂方法的类，使用 factory-method 属性，指定这个工厂方法本身。你能够调用这个方法（通过可选参数，这个待马上会讲到）返回一个对象，随后，这个对象看做是通过构造函数创建的。这样定义 bean 的一个使用场景就是调用遗留代码中的静态工厂。\n下面的 bean 定义，指定了将要通过工厂方法创建的 bean。这个定义不会指定返回对象的类型，而是指定包含静态方法的类。在这个例子中，createInstance() 方法必须是一个静态方法。下面的例子展示了怎么去指定一个工厂方法。\n\u0026lt;bean id=\u0026#34;clientService\u0026#34; class=\u0026#34;examples.ClientService\u0026#34; factory-method=\u0026#34;createInstance\u0026#34;/\u0026gt; 下面的例子展示了一个上面 bean 定义用到的类：\npublic class ClientService { private static ClientService clientService = new ClientService(); private ClientService() {} public static ClientService createInstance() { return clientService; } } 想了解关于如何给工厂方法传参并且在工厂返回的对象中设置对象实例的属性的细节，可以参考 Dependencies and Configuration in Detail.。\n通过实例的工厂方法 与通过静态工厂方法实例化相似，通过实例的工厂方法调用一个容器中一个现有 bean 的非静态方法来创建一个新的 bean。要想使用这个机制，需要将 class 属性置空并且在 factory-bean 属性指定当前容器（父容器或者祖父容器）中的 bean 的名称，此 bean 包含创建对象实例的方法。在 factory-method 属性中设置工厂方法本身的名字。下面的例子展示了如何配置这样一个 bean：\n\u0026lt;!-- the factory bean, which contains a method called createInstance() --\u0026gt; \u0026lt;bean id=\u0026#34;serviceLocator\u0026#34; class=\u0026#34;examples.DefaultServiceLocator\u0026#34;\u0026gt; \u0026lt;!-- inject any dependencies required by this locator bean --\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- the bean to be created via the factory bean --\u0026gt; \u0026lt;bean id=\u0026#34;clientService\u0026#34; factory-bean=\u0026#34;serviceLocator\u0026#34; factory-method=\u0026#34;createClientServiceInstance\u0026#34;/\u0026gt; 下面的例子展示了与之相应的类：\npublic class DefaultServiceLocator { private static ClientService clientService = new ClientServiceImpl(); public ClientService createClientServiceInstance() { return clientService; } } 一个工厂类，同样也可以包含更多的工厂方法，如下面的例子所示：\n\u0026lt;bean id=\u0026#34;serviceLocator\u0026#34; class=\u0026#34;examples.DefaultServiceLocator\u0026#34;\u0026gt; \u0026lt;!-- inject any dependencies required by this locator bean --\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;clientService\u0026#34; factory-bean=\u0026#34;serviceLocator\u0026#34; factory-method=\u0026#34;createClientServiceInstance\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;accountService\u0026#34; factory-bean=\u0026#34;serviceLocator\u0026#34; factory-method=\u0026#34;createAccountServiceInstance\u0026#34;/\u0026gt; 下面的例子展示了与之相对应的类：\npublic class DefaultServiceLocator { private static ClientService clientService = new ClientServiceImpl(); private static AccountService accountService = new AccountServiceImpl(); public ClientService createClientServiceInstance() { return clientService; } public AccountService createAccountServiceInstance() { return accountService; } } 这个方法展示了工厂 bean 本身是可以通过依赖注入机制被设置和配置的。\nNote：在 Spring 的文档中，\u0026ldquo;factory bean\u0026rdquo; 指的是一个在 Spring 容器中配置好并且通过实例或者静态工厂方法创建好的 bean。与之相对比，FactoryBean（注意首字母），指的是一个 Spring 特定的 FactoryBean 的实现类。\n确定一个 bean 的运行时类名 确定一个特定的bean的运行时类型并非易事。一个在 bean 元数据定义中指定的类仅仅是一个可能与一个声明的工厂方法组合的初始类引用，或者是一个会 让此 bean 的运行时类型完全不同的 FactoryBean 类，或者在实例级别的工厂方法（通过指定的 factory-bean 来解决）什么也不做。此外，AOP 代理也会通过bean 接口代理来包装一个bean实例，此接口代理会有限地暴露目标bean的实际类型（仅仅是已经实现的接口）。\n找出一个特定 bean 的实际运行时类型的推荐的方法是通过指定 bean 名字，调用 BeanFactory.getType 方法。这种方法将上面所有的情形考虑在内，并且返回对象的类型，此对象也是在相同名称下，调用 BeanFactory.getBean 方法会返回的。\n[全文完]\n","permalink":"http://localhost:1313/posts/spring_framework/core/the_ioc_container/bean_overview/","summary":"\u003cp\u003e一个 Sring IoC 容器可以操作一个或者多个 bean。这些 bean 是通过你提供给容器的配置元数据生成的（例如，以 XML 中的 \u003ccode\u003e\u0026lt;bean/\u0026gt;\u003c/code\u003e ）。\u003c/p\u003e\n\u003cp\u003e在容器内，这些 bean 的定义被表示成 \u003ccode\u003eBeanDefinition\u003c/code\u003e 对象的形式，包含了下面的元数据：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e包定义的类名：通常是定义的 bean 的真正实现类\u003c/li\u003e\n\u003cli\u003ebean 行为配置元素，表明了 bean 在 container 中的行为（scope，生命周期回调等等）。\u003c/li\u003e\n\u003cli\u003e对其他需要的 bean 的引用。这些引用也被称作协作器和依赖。\u003c/li\u003e\n\u003cli\u003e在一个新创建的对象中的其他配置设置 - 例如，池的数量限制或者一个操作连接池 bean 中的连接数量\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这些元数据转换为构成这些 bean 定义的一系列属性。下表表示了这些属性值：\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e属性\u003c/th\u003e\n          \u003cth\u003e含义\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eClass\u003c/td\u003e\n          \u003ctd\u003e正在实例化的bean\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eName\u003c/td\u003e\n          \u003ctd\u003ebean的名字\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eScope\u003c/td\u003e\n          \u003ctd\u003eBean的Scope\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e构造函数参数\u003c/td\u003e\n          \u003ctd\u003e依赖注入\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e自动装配模式\u003c/td\u003e\n          \u003ctd\u003e装配的协作对象\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e懒加载模式\u003c/td\u003e\n          \u003ctd\u003e懒加载 Bean\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e初始化方法\u003c/td\u003e\n          \u003ctd\u003e初始化回调\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e析构方法\u003c/td\u003e\n          \u003ctd\u003e析构回调\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e除了包含怎么创建一个特定的 bean 的信息之外， \u003ccode\u003eApplicationContext\u003c/code\u003e 的实现同样允许在容器外面已经创建好的对象注册到其中（用户创建）。这是通过 \u003ccode\u003egetBeanFactory\u003c/code\u003e 方法获取到 \u003ccode\u003eApplicationContext\u003c/code\u003e 的 \u003ccode\u003eBeanFactory\u003c/code\u003e，得到 \u003ccode\u003eDefaultListableBeanFactory\u003c/code\u003e 实现来做到的。\u003ccode\u003eDefaultListableBeanFactory\u003c/code\u003e 支持通过调用 \u003ccode\u003eregisterSingleton(..)\u003c/code\u003e  和 \u003ccode\u003eregisterBeanDefinition(..)\u003c/code\u003e 方法来实现这样的注册。然而，典型的应用程序仅仅使用常规的 bean 定义元数据。\u003c/p\u003e","title":"[译] Bean 概述"},{"content":"Spring IOC 和 bean 的简介 本章涵盖了 SpringFramework 中的控制反转原则（Ioc）的实现。IoC 也被称为依赖注入（DI）。它是这样的一种过程，在此期间对象仅通过构造函数参数、工厂方法的参数或者当对象实例被构造后或者通过工厂方法返回时在它上面设置的属性定义自己的依赖（即对象必须合作的其他对象）。\n当容器创建这些 bean 后，再注入这些依赖。\n这个过程本质上与bean 通过使用直接的类构造函数进行直接实例化或者通过类似 Service Locator模式来寻找依赖的位置是相反的（这也是 IoC 名字的由来）。\norg.springframework.beans 和 org.springframework.context 包是 SpringFramework IoC 容器的基石。BeanFactory 接口提供了一种更先进的能够控制人已类型对象的配置机制。ApplicationContext 是 BeanFactory 的子接口。它增加了下面的特性：\n与 Spring 的 AOP 特性更容易整合 消息资源处理（在国际化场景的使用） 事件发布 例如用于 Web 应用的 WebApplicationContext 应用层特定的上下文 总而言之，BeanFactory 提供了配置的框架和基本的功能。ApplicationContext 增加了更多的企业特定的功能。ApplicationContext 完全是 BeanFactory 的超集。在本章关于 Spring IoC 容器做专门描述时会用到。想要获取更多的关于使用 ApplicationContext 而非 BeanFactory 的信息，参见介绍 BeanFactory API 的部分。\n在 Spring 中，作为你应用基石同时可以被 Spring IoC 容器所操控的对象就被称之为 bean。bean 就是被 Spring IoC 容器实例化、组装和设置的对象。否则，一个 bean 就是你应用程序中诸多对象中的一个。 Beans 以及他们依赖关系，反映在容器使用的配置元数据中。\n","permalink":"http://localhost:1313/posts/spring_framework/core/the_ioc_container/container_and_beans/","summary":"\u003ch1 id=\"spring-ioc-和-bean-的简介\"\u003eSpring IOC 和 bean 的简介\u003c/h1\u003e\n\u003cp\u003e本章涵盖了 SpringFramework 中的控制反转原则（Ioc）的实现。IoC 也被称为依赖注入（DI）。它是这样的一种过程，在此期间对象仅通过构造函数参数、工厂方法的参数或者当对象实例被构造后或者通过工厂方法返回时在它上面设置的属性定义自己的依赖（即对象必须合作的其他对象）。\u003c/p\u003e\n\u003cp\u003e当容器创建这些 bean 后，再注入这些依赖。\u003c/p\u003e\n\u003cp\u003e这个过程本质上与bean 通过使用直接的类构造函数进行直接实例化或者通过类似 Service Locator模式来寻找依赖的位置是相反的（这也是 IoC 名字的由来）。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eorg.springframework.beans\u003c/code\u003e 和 \u003ccode\u003eorg.springframework.context\u003c/code\u003e 包是 SpringFramework IoC 容器的基石。\u003ccode\u003eBeanFactory\u003c/code\u003e 接口提供了一种更先进的能够控制人已类型对象的配置机制。\u003ccode\u003eApplicationContext\u003c/code\u003e 是 \u003ccode\u003eBeanFactory\u003c/code\u003e 的子接口。它增加了下面的特性：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e与 Spring 的 AOP 特性更容易整合\u003c/li\u003e\n\u003cli\u003e消息资源处理（在国际化场景的使用）\u003c/li\u003e\n\u003cli\u003e事件发布\u003c/li\u003e\n\u003cli\u003e例如用于 Web 应用的 \u003ccode\u003eWebApplicationContext\u003c/code\u003e 应用层特定的上下文\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e总而言之，\u003ccode\u003eBeanFactory\u003c/code\u003e 提供了配置的框架和基本的功能。\u003ccode\u003eApplicationContext\u003c/code\u003e 增加了更多的企业特定的功能。\u003ccode\u003eApplicationContext\u003c/code\u003e 完全是 \u003ccode\u003eBeanFactory\u003c/code\u003e 的超集。在本章关于 Spring IoC 容器做专门描述时会用到。想要获取更多的关于使用 \u003ccode\u003eApplicationContext\u003c/code\u003e 而非 \u003ccode\u003eBeanFactory\u003c/code\u003e 的信息，参见介绍 \u003ca href=\"https://docs.spring.io/spring-framework/reference/core/beans/beanfactory.html\"\u003eBeanFactory\u003c/a\u003e API 的部分。\u003c/p\u003e\n\u003cp\u003e在 Spring 中，作为你应用基石同时可以被 Spring IoC 容器所操控的对象就被称之为 bean。bean 就是被 Spring IoC 容器实例化、组装和设置的对象。否则，一个 bean 就是你应用程序中诸多对象中的一个。 Beans 以及他们依赖关系，反映在容器使用的配置元数据中。\u003c/p\u003e","title":"[译] Spring IOC 容器"},{"content":"容器概述 org.springframework.context.ApplicationContext 接口代表了 Spring IoC 容器，它主要负责通过读取配置文件对 bean 进行实例化、配置和组装。 容器通过读取配置元数据来获知要实例化、配置和组装那些对象。配置的元数据一般为 XML、Java 注解和 Java 代码的形式，它让你能够表达组成你应用程序的对象以及对象之间的丰富的相互依赖关系。\nSpring 提供了 ApplicationContext 接口的若干实现。在单体应用中，创建一个 ClassPathXmlApplicationContext 或者 FileSystemXmlApplicationContext 是很常见的。虽然 XML 是定义配置元数据的传统形式，但是你还可以通过在 XML 文件里面进行声明配置来告诉容器对于 Java 注解或者Java代码格式的支持。\n在大多数的应用场景中，并不需要显式的代码来实例化 Spring IoC 容器。例如，在 Web 应用的场景中，在 web.xml 文件中仅用简单的 8 行代码左右的样板 Web XML 描述符即可满足需要（参考 Convenient ApplicationContext Instantiation for Web Applications）。如果你使 Eclipse 中的 Spring 工具（在 Eclipse 开发环境中），你可以通过几下鼠标点击或者按键的敲击就能轻松创建这样一个样板配置文件。\n下图展示了关于 Spring 工作机制的一个全局视角。在 ApplicationContext 被创建和初始化后，你的应用类和配置元数据已经捆绑在一起了，这样一来，你就有一个充分配置并且可执行的系统或者应用程序。\n配置元数据 如上图所示，Spring Ioc 容器接收到一种格式的配置元数据。这个配置元数据代表了，作为一个应用开发者你告诉 Spring 容器在应用程序中，如何实例化、配置和组装对象。\n传统的配置元数据是一种简单并且符合直觉的 XML 形式，在本章的大部分地方，也用此来表达关键的概念和 Spring IoC 容器的特性。\n基于 XML 的元数据不是配置元数据的唯一允许的形式。Spring IoC 容器自身与配置元数据实际上是什么格式完全解耦。目前许多开发者在应用程序中选择基于Java 的配置。\n在 Spring 容器中使用其他格式的配置元数据，可参考：\n基于注解的配置：通过基于注解的配置元数据定义 beans 基于Java的配置：通过使用 Java 而不是 XML 文件来定义你应用类之外的 beans。使用这些特性可以参考 @Configuration, @Bean, @Import, @DependsOn 注解。 Spring 的配置由至少一个，通常为1个以上容器可以操作的 bean 组成。基于 XML 的配置元数据，配置顶部根元素 里面的 元素。Java 配置通常在一个 @Configuration 类里面使用 @Bean 注解方法。\n这些 bean 的定义与组成你应用的实际对象相对应。通常地，你需要定义服务层对象，持久化层对象例如仓库或者数据接入对象（DAOs），例如 Web Controller 的表现层对象，例如一个 JPA EntityManagerFactory 的基础层对象，JMS 队列等等。通常不在容器里面对一个领域层对象进行精细化配置，因为创建和加载领域对象，通常是存储层和业务层的逻辑。\n下面的例子，展示了基于 XML 的配置元数据的基本结构：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;...\u0026#34; class=\u0026#34;...\u0026#34;\u0026gt; [1][2] \u0026lt;!-- collaborators and configuration for this bean go here --\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;...\u0026#34; class=\u0026#34;...\u0026#34;\u0026gt; \u0026lt;!-- collaborators and configuration for this bean go here --\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- more bean definitions go here --\u0026gt; \u0026lt;/beans\u0026gt; [1]：id 属性唯一标识一个独立的 bean 定义 [2]：class 属性定义了 bean的类型，并且使用类的全限定名\nid 属性的值可以被用来引用互相协作的对象。引用协作的对象的 XML并不在此例中，参考依赖部分获取更多的信息。\n初始化一个容器 提供给 ApplicationContext 构造器的位置路径是一些表示资源的字符串，这些字符串可以让容器从各种外部资源加载配置元数据，例如本地文件系统，Java 类路径等等。\nApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;services.xml\u0026#34;, \u0026#34;daos.xml\u0026#34;); 在你了解了 Spring 的 IoC 容器后，你也许想对 Spring 的“资源：抽象了解更多，这提供了一种方便的从 URI 语法标识中读取输入流的机制。特别是 Resource 路径用于构建应用的上下文。\n下面的例子展示了服务层的对象(services.xml)的配置文件：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!-- services --\u0026gt; \u0026lt;bean id=\u0026#34;petStore\u0026#34; class=\u0026#34;org.springframework.samples.jpetstore.services.PetStoreServiceImpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;accountDao\u0026#34; ref=\u0026#34;accountDao\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;itemDao\u0026#34; ref=\u0026#34;itemDao\u0026#34;/\u0026gt; \u0026lt;!-- additional collaborators and configuration for this bean go here --\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- more bean definitions for services go here --\u0026gt; \u0026lt;/beans\u0026gt; 下面的例子展示了数据接入层(daos.xml)文件：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;accountDao\u0026#34; class=\u0026#34;org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao\u0026#34;\u0026gt; \u0026lt;!-- additional collaborators and configuration for this bean go here --\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;itemDao\u0026#34; class=\u0026#34;org.springframework.samples.jpetstore.dao.jpa.JpaItemDao\u0026#34;\u0026gt; \u0026lt;!-- additional collaborators and configuration for this bean go here --\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- more bean definitions for data access objects go here --\u0026gt; \u0026lt;/beans\u0026gt; 在上面的例子中，服务层由 PetStoreServiceImpl 类和两种类型分别为 JpaAccountDao 和 JpaItemDao(基于JPA对象关系映射标准) 的数据接入对象。property name 元素引用 JavaBean 属性的名字，ref 元素引用另外一个 bean 定义的名字。id 和 ref 元素之间的联系，表达了两个互相协作对象之间的依赖关系。想了解更多配置对象依赖的细节，参考 依赖。\n组装基于 XML 的配置元数据 一个 bean 的定义跨越多个 XML 文件中有时候会非常有用。通常，每一个 XML 的配置文件代表你架构里面的一个逻辑层或者模块。\n你可以使用应用的上下文构造器从这些 XML 的片段中加载 bean 定义。这个构造器可以接受多 Resource 加载位置，就如前面表示的那样。你也可以使用一个或者多个 \u0026lt;import/\u0026gt; 元素去加载另一个（或者一些）文件中的 bean 定义。下面的例子展示了如何去做到这一点：\n\u0026lt;beans\u0026gt; \u0026lt;import resource=\u0026#34;services.xml\u0026#34;/\u0026gt; \u0026lt;import resource=\u0026#34;resources/messageSource.xml\u0026#34;/\u0026gt; \u0026lt;import resource=\u0026#34;/resources/themeSource.xml\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;bean1\u0026#34; class=\u0026#34;...\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;bean2\u0026#34; class=\u0026#34;...\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; 在上面的例子中，外部的 bean 定义从三个文件中加载到：services.xml,messageSource.xml,themeSource.xml 。所有的位置路径都是做引入的 bean 定义文件的相对路径。所以，services.xml 必须和正在引入的文件在相同的目录下或者类路径下。虽然 messageSource.xml 和 themeSource.xml 必须在导入文件的下面的路径的 resource 路径里。如你所见，前导的 / 符号被忽略了。然而，既然这些路径都是相对的，所以，最好不适用 / 。被引入文件的内容，必须是一个依据 Spring Schema 的有效 XML bean 定义，最外层是 \u0026lt;beans/\u0026gt; 元素。\n注意： 使用 ../ 路径引用父目录中的文件虽然是可以的，但是并不推荐。这样做，会使得当前的应用程序对外部的文件造成依赖。特别是，这个引用对类路径不推荐，例如：classpath:../services.xml，这样的情形下，运行时的进程会选择离 classpath 根路径最近的地方，然后去找它的父目录。类路径配置的修改，很可能会导致一个完全不同的错误的目录被选中。\n你可以永远选择一个全限定的资源路径而不是相对路径，例如 file:C:/config/services.xml 或者 classpath:/config/services.xml。然而，需要知道的是，你正在使你的应用配置和特定的绝对路径耦合。通常会选择对这样的绝对路径做一个间接地引用，例如，通过运行时，根据 JVM 的系统属性解析的${...} 占位符。\n名空间提供了引入原语的特性。在普通 bean 定义之外的特性可以在 Spring 提供的名空间————例如， context 和 util 中获取到。\nGrooy Bean 定义的 DSL 另外一个外部配置元数据的例子，同样可以使用 Spring 的 Groovy Bean 定义 DSL 来表达，如 Grails 框架所示。通常，在 .groovy 文件会采用下面的配置结构：\nbeans { dataSource(BasicDataSource) { driverClassName = \u0026#34;org.hsqldb.jdbcDriver\u0026#34; url = \u0026#34;jdbc:hsqldb:mem:grailsDB\u0026#34; username = \u0026#34;sa\u0026#34; password = \u0026#34;\u0026#34; settings = [mynew:\u0026#34;setting\u0026#34;] } sessionFactory(SessionFactory) { dataSource = dataSource } myService(MyService) { nestedBean = { AnotherBean bean -\u0026gt; dataSource = dataSource } } } 这样的配置风格基本和 Spring XML 配置名空间中的 bean 定义和事件相同。同样，通过 importBeans 指令引入 XML bean 定义也是可以的。\n容器的使用 ApplicationContext 是一个高级的工厂接口，它可以保存一个包含不同的 bean 和他们的依赖。通过使用方法 T getBean(String name, Class\u0026lt;T\u0026gt; requiredType)，你可以获取到你 bean 的实例。\nApplicationContext 让你可以读取并获取 bean 定义，如下面的例子所示：\n// create and configure beans ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;services.xml\u0026#34;, \u0026#34;daos.xml\u0026#34;); // retrieve configured instance PetStoreService service = context.getBean(\u0026#34;petStore\u0026#34;, PetStoreService.class); // use configured instance List\u0026lt;String\u0026gt; userList = service.getUsernameList(); 使用 Groovy 配置，启动过程也类似。它有一个不同的上下文可以感知 Groovy 的实现类（同时也可以理解 XML 的 bean 定义）。下面的例子展示了 Groovy 的配置：\nApplicationContext context = new GenericGroovyApplicationContext(\u0026#34;services.groovy\u0026#34;, \u0026#34;daos.groovy\u0026#34;); 最灵活的变化就是 GenericApplicationContext 和读取代理————例如，使用 XmlBeanDefinitionReader 读取 XML 文件中：\nGenericApplicationContext context = new GenericApplicationContext(); new XmlBeanDefinitionReader(context).loadBeanDefinitions(\u0026#34;services.xml\u0026#34;, \u0026#34;daos.xml\u0026#34;); context.refresh(); 你也可以使用 GroovyBeanDefinitionReader 读取 Groovy 文件：\nGenericApplicationContext context = new GenericApplicationContext(); new GroovyBeanDefinitionReader(context).loadBeanDefinitions(\u0026#34;services.groovy\u0026#34;, \u0026#34;daos.groovy\u0026#34;); context.refresh(); 你可以在 ApplicationContext 中混合匹配这样的读取代理，来分别兑取不同的配置文件源里面的 bean 定义。\n你也可以使用 getBean 来获取你的 bean 实例对象。ApplicationContext 接口有一些其他的方法用来获取 bean。但是，理想情况下，你的应用代码不会用到它。确实，你的应用代码如果没有对 Spring API 的任何依赖，就不应该调用 getBean() 方法。例如，Spring 和 Web 框架的整合提供了对各种 web 框架元组件的依赖注入，例如 Controller 和 JSF 的bean，这些都可以让你能够通过元数据（例如自动装配）来声明依赖。\n","permalink":"http://localhost:1313/posts/spring_framework/core/the_ioc_container/container_overview/","summary":"\u003ch1 id=\"容器概述\"\u003e容器概述\u003c/h1\u003e\n\u003cp\u003e\u003ccode\u003eorg.springframework.context.ApplicationContext\u003c/code\u003e 接口代表了 Spring IoC 容器，它主要负责通过读取配置文件对 bean 进行实例化、配置和组装。\n容器通过读取配置元数据来获知要实例化、配置和组装那些对象。配置的元数据一般为 XML、Java 注解和 Java 代码的形式，它让你能够表达组成你应用程序的对象以及对象之间的丰富的相互依赖关系。\u003c/p\u003e\n\u003cp\u003eSpring 提供了 \u003ccode\u003eApplicationContext\u003c/code\u003e 接口的若干实现。在单体应用中，创建一个 \u003ccode\u003eClassPathXmlApplicationContext\u003c/code\u003e 或者 \u003ccode\u003eFileSystemXmlApplicationContext\u003c/code\u003e 是很常见的。虽然 XML 是定义配置元数据的传统形式，但是你还可以通过在 XML 文件里面进行声明配置来告诉容器对于 Java 注解或者Java代码格式的支持。\u003c/p\u003e\n\u003cp\u003e在大多数的应用场景中，并不需要显式的代码来实例化 Spring IoC 容器。例如，在 Web 应用的场景中，在 \u003ccode\u003eweb.xml\u003c/code\u003e 文件中仅用简单的 8 行代码左右的样板 Web XML 描述符即可满足需要（参考 \u003ca href=\"https://docs.spring.io/spring-framework/reference/core/beans/context-introduction.html#context-create\"\u003eConvenient ApplicationContext Instantiation for Web Applications\u003c/a\u003e）。如果你使 Eclipse 中的 Spring 工具（在 Eclipse 开发环境中），你可以通过几下鼠标点击或者按键的敲击就能轻松创建这样一个样板配置文件。\u003c/p\u003e\n\u003cp\u003e下图展示了关于 Spring 工作机制的一个全局视角。在 \u003ccode\u003eApplicationContext\u003c/code\u003e 被创建和初始化后，你的应用类和配置元数据已经捆绑在一起了，这样一来，你就有一个充分配置并且可执行的系统或者应用程序。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/posts/spring_framework/core/the_ioc_container/container_overview/imgs/ioc.png\" type=\"\" alt=\"Spring\"  /\u003e\u003c/p\u003e\n\u003ch1 id=\"配置元数据\"\u003e配置元数据\u003c/h1\u003e\n\u003cp\u003e如上图所示，Spring Ioc 容器接收到一种格式的配置元数据。这个配置元数据代表了，作为一个应用开发者你告诉 Spring 容器在应用程序中，如何实例化、配置和组装对象。\u003c/p\u003e\n\u003cp\u003e传统的配置元数据是一种简单并且符合直觉的 XML 形式，在本章的大部分地方，也用此来表达关键的概念和 Spring IoC 容器的特性。\u003c/p\u003e","title":"[译] 容器概述"},{"content":" 概述 历史，设计哲学，反馈，开始\n核心 IoC容器，事件，资源，i18n，验证，数据绑定，类型转换，SpEL，AOP，AOT\n测试 对象 Mock，测试上下文框架，Spring MVC 测试，Web 测试客户端\n数据接入 事务，DAO 支持，JDBC，R2DBC，O/R 映射，XML 编码\nWeb Servlet SpringMVC,WebSocket,SockJS,STOMP 通信\nWeb 响应式 Spring WebFlux, WebClient, WebSocket, RSocket.\n[集成] REST 客户端, JMS, JCA, JMX, Email, 任务, 调度, 缓存, 可见性.\n语言 Kotlin, Groovy, Dynamic 语言.\n附录 Spring 属性\n","permalink":"http://localhost:1313/posts/spring_framework/directory/","summary":"\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"/posts/spring_framework/overview/\"\u003e概述\u003c/a\u003e 历史，设计哲学，反馈，开始\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"\"\u003e核心\u003c/a\u003e IoC容器，事件，资源，i18n，验证，数据绑定，类型转换，SpEL，AOP，AOT\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"\"\u003e测试\u003c/a\u003e 对象 Mock，测试上下文框架，Spring MVC 测试，Web 测试客户端\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"\"\u003e数据接入\u003c/a\u003e 事务，DAO 支持，JDBC，R2DBC，O/R 映射，XML 编码\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"\"\u003eWeb Servlet\u003c/a\u003e SpringMVC,WebSocket,SockJS,STOMP 通信\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"\"\u003eWeb 响应式\u003c/a\u003e Spring WebFlux, WebClient, WebSocket, RSocket.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e[集成] REST 客户端, JMS, JCA, JMX, Email, 任务, 调度, 缓存, 可见性.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"\"\u003e语言\u003c/a\u003e Kotlin, Groovy, Dynamic 语言.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"\"\u003e附录\u003c/a\u003e Spring 属性\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"[译] SpringFramework 文档"},{"content":"概述 Spring 使得创建 Java 企业级应用更加容易。它提供了你在企业环境下拥抱 Java 语言所需要的一切，支持 JVM 平台上的 Groovy 和 Kotlin 作为备选语言，并且提供了根据应用程序的需求创建多种架构的灵活性。从 SpringFramework 6.0 开始，Spring 需要 Java 17 以上的版本。\nSpring 支持广泛的应用场景。在一个大型企业里，应用程序经常会存在很长时间，并且必须运行在一个开发者不能控制升级周期的 JDK 和应用服务器上。 另外一些可能会作为一个内嵌服务器的单独 jar 包，运行在一个云环境里，还有一些可能是一个不需要服务器的独立应用程序（例如批处理或者集成处理工作）。\nSpring 是开源的。它有一个庞大而活跃的社群，基于各种实际用例，提供持续反馈。这也帮助了 Spring 在相当长一段时间内成功发展。。\n当我们在谈 Spring 时我们在谈什么 “Spring” 这个术语在不同的语境下有着不同的含义。它可以用来表示 SpringFramework 这个项目自身，一切都是从这里开始的（-译者按：梦开始的地方）。随着时间的推移，又构建了一些以 SpringFramework 为基础的 Spring 项目。大部分情况下，当人们谈论 Spring，他们的意思是 Spring 整个系列（-译者按：俗称全家桶）。本参考文档只针对这个基础进行介绍：SpringFramework 本身。\nSpringFramework 被分成不同的模块。应用程序可以根据他们所需要的模块进行选择。这些模块中处于核心的是 core container，包括配置模型和依赖注入机制。除此之外，SpringFramework 还对于不同应用架构提供基础支持，包括消息传递、事务以及持久化和 web。它同时也包含了基于 Servlet 的 SpringMVC web 框架以及Spring WebFlux 响应式web框架。\n关于这些模块需要注意的是：\nSpring 的框架，允许部署到 JDK 9 的模块路径（\u0026ldquo;Jigsaw\u0026rdquo;）。对于在支持 “Jigsaw” 的应用程序中的使用，Spring Framework 5 的 jar 包里面，携带了 “Automatic-Module-Name” 的 manifest entries，它定义了稳定的语言级别模块名（例如：“spring.core”，“spring.context” 等等），它与 jar 的 artifact 名字独立（ 这些 jar 遵循同样的模式，例如 “spring-core” 和 “spring-context”。 “-” 代替 “.”\n译者按：本人对于 Jigsaw 不太熟悉，等后面熟悉了，再过来修正这一段的翻译。目前，是不知道这段说了什么的。\n当然，Spring 框架中的 jar 包，在 JDK 9 和 JDK 9+ 的 classpath 中，可以继续正常工作。\nSpring 和 Spring Framework 的历史 在 2003 年，为了应对 J2EE 早期规范的复杂性，Spring 应运而生。 虽然一些人认为 Java EE 和他的现代继承者 Jakarta EE 与 Spring 势不两立，但是他们实际上是互为补充的。 Spring 的编程模型不会拥抱 Jakarta EE 平台的规范，相反，它从传统的 EE 的笼罩下面，精心挑选了一些规范，并与之整合：\nServlet API (JSR 340)\nWebSocket API (JSR 356)\nConcurrency Utilities (JSR 236)\nJSON Binding API (JSR 367)\nBean Validation (JSR 303)\nJPA (JSR 338)\nJMS (JSR 914)\n如果有必要的话，还有 JTA/JCA 用于事务协商的设置\nSpringFramework 还支持应用开发者使用依赖注入规范（JSR 330）和通用注解规范（JSR 250），代替 SpringFramework 提供的 Spring 规范机制。最初，他们都是基于 javax 包的。\n译者按：自由即长久。\nSpringFramework 6.0 里，Spring 已经升级到 Jakarta EE 9（例如：Servlet 5.0+，JPA 3.0+），基于 Jakarta 名称空间，而非传统的 javax 包。 从 EE 9 开始到现在已经支持的 EE 10，Spring 准备对 Jakarta EE 接口的进一步发展提供开箱即用的支持。\nSpringFramework 6.0 已经完全兼容 Tomcat 10.1，Jetty 11 和 Undertow 2.3 作为 web 服务器，这其中也抱愧 Hibernate ORM 6.1.\n随着时间的推移，Java/Jakarta EE 在应用开发中的角色在不断演进。在 J2EE 和 Spring 的早期，应用被创建后，部署到一个应用服务器上。\n今天，在 Spring Boot 的帮助下，应用可以以一种 devops 和云友好的方式创建，内嵌 Servlet 容器，并且易于修改。从 SpringFramework 5 开始，WebFlux 应用甚至不直接使用 Servlet API 就可以在非 Servlet 的服务器上运行起来（例如 Netty）\nSpring 持续创新和演进。除了 SpringFramework 之外，还有很多项目，例如 Spring Boot，Spring Security，Spring Data，Spring Cloud，Spring Batch。 值得记住的是：每一个项目都有它自己的源码仓库，问题追踪和发版节奏。可以在 spring.io/projects 看到 Spring 项目的完整清单。\n设计哲学 当你了解一个框架时，重要的不是知道它做了什么而是它遵循什么样的准则。SpringFramework 的指导准则如下：\n在每一个级别上提供选择。Spring 可以让你尽可能晚地推迟做出设计决策。比如，你可以在不更改代码的情况下，改变你的持久化方案。对于其他的基础设施问题，整合其他第三方的 API，这一点同样适用。 兼容并包。Spring 拥抱灵活性，并不介意事情是怎么被完成的。它提供了在不同观念下的诸多需要。 保持较强的向后兼容性。Spring 的演进经过精心管理，在版本之间，几乎没有特别大的变化。Spring 精心挑选 JDK 版本号范围以及第三方库，以方便维护依赖于 Spring 的应用以及库。 精心设计 API。Spring 团队投入了较多的时间和精力设计 API，目的是让 API 更加符合直觉，可以使用很多年，跨越多个版本。 对代码质量设置较高的标准。SpringFramework 重点强调有意义的、及时、精确的 javadoc。它是为数不多的声称拥有干净的代码架构且在不同的包之间没有循环引用的项目之一。 开始 如果你刚开始接触 Spring，你也许会从创建一个基于 SpringBoot 应用开始使用 SpringFramework。SpringBoot 提供了一个快速（固定）的方式来创建可部署生产环境的基于 Spring 的应用。它基于 SpringFramework，喜欢约定优于配置的风格，设计它就是为了让你能够尽可能快地启动和运行。\n你可以使用start.spring.io来生成一个基本的项目，或者遵循\u0026ldquo;Getting Started\u0026rdquo; 指南 例如 Getting Started Building a RESTful Web Service。\n这些指南都是任务导向且易于理解的，他们中的大部分是基于 SpringBoot。它同时也涵盖了 Spring 产品中的其他项目，这些你可能会在解决某个具体的问题时会使用到。\n","permalink":"http://localhost:1313/posts/spring_framework/overview/","summary":"\u003ch1 id=\"概述\"\u003e概述\u003c/h1\u003e\n\u003cp\u003eSpring 使得创建 Java 企业级应用更加容易。它提供了你在企业环境下拥抱 Java 语言所需要的一切，支持 JVM 平台上的 Groovy 和 Kotlin 作为备选语言，并且提供了根据应用程序的需求创建多种架构的灵活性。从 SpringFramework 6.0 开始，Spring 需要 Java 17 以上的版本。\u003c/p\u003e\n\u003cp\u003eSpring 支持广泛的应用场景。在一个大型企业里，应用程序经常会存在很长时间，并且必须运行在一个开发者不能控制升级周期的 JDK 和应用服务器上。\n另外一些可能会作为一个内嵌服务器的单独 jar 包，运行在一个云环境里，还有一些可能是一个不需要服务器的独立应用程序（例如批处理或者集成处理工作）。\u003c/p\u003e\n\u003cp\u003eSpring 是开源的。它有一个庞大而活跃的社群，基于各种实际用例，提供持续反馈。这也帮助了 Spring 在相当长一段时间内成功发展。。\u003c/p\u003e\n\u003ch1 id=\"当我们在谈-spring-时我们在谈什么\"\u003e当我们在谈 Spring 时我们在谈什么\u003c/h1\u003e\n\u003cp\u003e“Spring” 这个术语在不同的语境下有着不同的含义。它可以用来表示 SpringFramework 这个项目自身，一切都是从这里开始的（-译者按：梦开始的地方）。随着时间的推移，又构建了一些以 SpringFramework 为基础的 Spring 项目。大部分情况下，当人们谈论 Spring，他们的意思是 Spring 整个系列（-译者按：俗称全家桶）。本参考文档只针对这个基础进行介绍：SpringFramework 本身。\u003c/p\u003e\n\u003cp\u003eSpringFramework 被分成不同的模块。应用程序可以根据他们所需要的模块进行选择。这些模块中处于核心的是 core container，包括配置模型和依赖注入机制。除此之外，SpringFramework 还对于不同应用架构提供基础支持，包括消息传递、事务以及持久化和 web。它同时也包含了基于 Servlet 的 SpringMVC web 框架以及Spring WebFlux 响应式web框架。\u003c/p\u003e\n\u003cp\u003e关于这些模块需要注意的是：\u003c/p\u003e\n\u003cp\u003eSpring 的框架，允许部署到 JDK 9 的模块路径（\u0026ldquo;Jigsaw\u0026rdquo;）。对于在支持 “Jigsaw” 的应用程序中的使用，Spring Framework 5 的 jar 包里面，携带了 “Automatic-Module-Name” 的 manifest entries，它定义了稳定的语言级别模块名（例如：“spring.core”，“spring.context” 等等），它与 jar 的 artifact 名字独立（ 这些 jar 遵循同样的模式，例如 “spring-core” 和 “spring-context”。 “-” 代替 “.”\u003c/p\u003e","title":"[译] SpringFramework 概述"},{"content":"谈心的文章好久没有写了，初秋的夜晚，键盘的敲击声格外响亮，一时竟然不知道从哪儿说起。我从今年开始，格外的怀旧起来。不只是怀念那个青春的八十年代，质朴的九十年代，而且竟然怀念起仿佛刚刚过去的两千年。也许是现在回看，带着滤镜和光影的原因吧。但我着实相信，过去确实比现在更加美丽一些。试问，现在还有什么歌曲能像过去的八九十年代扣人心弦，还有谁能写出像罗大佑那样充满人文情怀的歌词？我不是一个保守的人，现在的歌曲我也会经常听，但摇滚光是呐喊、嘶吼没有反思，民谣只有情绪没有韵味，流行歌曲更是惨不忍听。现在一首歌有四句比较朗朗上口一些，就能风靡一时，然后人们快速遗忘，寻找下一个。人们没法不遗忘，因为实在没有什么好怀念的。\n人们在路上疯狂且快速的奔跑着，前面有人但凡有一点点挡道，便会怒从心头起。也许在快速奔跑中，人们才来不及为过去伤怀，风驰电掣，麻木一生。\n如果我也这样，多好！\n可是，我偏偏要将步伐放慢，歪着头想想，于是总感觉自己是个慢半拍的人。\n今年一整年，几乎没有在公众号上发表任何文章，我想找个没人的地方，倾吐一下自己的想法。\n失落与大门 今年是让我特别失落的一年，特别失落。\n还有几年，就到传说中的中年危机了。坦白说，我直到今年才有些许明白，中年危机的真实含义。\n所谓中年危机，并不单单是一个经济的问题，而是方方面面。\n这个尴尬的年纪，朋友帮不上你，于是友情危机；妻子不理解你，于是婚姻危机；父母埋怨你，于是亲情危机。各方面的危机，想汹涌的几股暗流，汇集而来，向涉世未深的你迎面击来。\n这个年纪，看似血气方刚，实则是最脆弱的年纪，没有经验的积淀，没有人脉的积淀，只有你自己硬抗，像不喝药，凭借自己的身体素质对抗一场重感冒。\n扛过去，就会好很多。后面遇到再多糟心事，有了前面的抗体，总是会好过一些。\n呵，男人四十！\n今年的夏天格外热，但是在每次下班骑车回家的路上，听着歌，经常感觉浑身一阵冷战。也许是突然被某句歌词所触动，伤怀往事、怀疑信念。\n于是有一阵子，我囤了很多书。最明显的变化是，我开始看外国小说了，以前硬着头皮两次入门、两次放弃的《安娜卡列尼娜》，这次竟然能够看的津津有味，甚至有时候，会有冲动，买下托尔斯泰的《战争与和平》这部据说很冗长的巨著一看。\n年龄大了，学会妥协了。年少时，看那些翻译过来的腔调，就是不喜欢看不下去，我从来不理解为什么要冗长的心理描写，为什么人物的每一句台词，中间都要被“xxx说”拦腰斩为两截，如此种种。\n今年突然明白了，这就是文化差异，不同地区的表达习惯，是会有不同的，不只是语汇的区分。我们应该注重的是书里面的所蕴含的光辉思想以及作者倾注的满腔热情。我们在《史记-项羽本纪》里面看不到一句项羽的心理描写，仅凭几句念白，几句描写，一个英雄就这样被人千年。\n所以，中国会有山水画，笔墨留白，却依然已经满怀，而西方的工笔画、油画也依然是情绪饱满的。\n留白也有水货，浓墨重彩也有精品。\n这么想着，一道艺术的大门就这样为我敞开。\n思想越包容，视野越广阔。有些时候，就是需要换一个视角和思维的转变。\nAI 与艺术 AI 是今年的热词，仿佛一夜之间，什么都可以用 AI 做了。\n就在这孤独的一年，我的阅读量和艺术视角，刻意地伸长，触及到了我之前出于懒惰不会触及的地方。就凭我简单的探索，我就知道 AI 根本没戏，虽然，我是一个技术人，但是我从来不认为 AI 能够写出那些不朽的作品，能够勾勒出那些美妙的线条。\n很简单，因为 AI 不是人，没有意识和灵魂。\n不是人，所以不会像人一样犯错，与此同时，也缺少了很多偶然。须知，很多艺术就是来源于偶然的灵光一现。\n当然，还有一个重要的因素，就是伟大的读者催生伟大的作品，我们很难想象，被 AI 和短视频喂饱的读者们会有什么眼光去苛求那些内容的生产者。\n想来也荒唐，到底是谁训练了谁？\n将来的市场，AI 肯定是能挤掉一部分人的作品的。那些平庸的、毫无新意和灵魂的作品，会被 AI 取而代之。这或许倒是一个良币驱逐劣币的过程。\n试看当今的歌坛，有多惨不忍睹就知道，科技能帮助人在艺术道路上走一段路，可是，剩下的路还是要靠人类自己走。\n这是人类的宿命。\nAI 也没有用。\n也许，将来 AI 可能会突然大爆发，像人一样有了意识，但也是需要和人一样有痛苦的经历的。这样，AI 既有了人的意识，又有了人的经历和痛苦，那就是人类无疑了。\n也许是 AI 被我们人类同化了吧？不知道是否可以当成人类的一场惨胜。\n人文与科技 自己今年的时间，比往年多了一些，想做的事情太多，结果现在一件事也没有做成。自己不甘于只做一个消费者，也想做一个内容的生产者。\n但生成什么内容，却让自己又一次开始了犹豫和纠结。\n也许，这也是我的宿命，我注定会饿死在人文与科技的十字路口。\n人文类的内容，是我的兴趣所在，但是目前的境况很是不尽人意，言论管控空前，万马齐喑。再加上饭圈文化和粉丝量的有限和题材内容的饱和，很难找到一个切入口完成一些看似“伟大”的事情。\n科技类的内容，也是我想做的，看起来比人文的圈子要简单一些，但是，也比较枯燥一些，而且，自己驾驭起来，并不如人文类的容易一些，粉丝量的成长幅度，肯定比不上人文类的 up 主，毕竟大家都想在下班后，躺在床上，听听历史的八卦，谁会主动坐在桌前，听你分享一些你自己以为讲的很明白的原理和架构？\n但是，自己毕竟是吃技术这碗饭的，而且自己在今年换工作之后，看到身边有的人无知的像一头猪一样，不禁觉得可笑之余，转念一想，自己是否在另一些人的眼里，也无知得可笑呢？于是，我立志，要把自己的技术短板填补上，尽量不看起来像一头猪。\n综合起来，貌似技术up这条路，自己会走得更踏实一些，而且人文类的内容，要想做得出彩，关键在于自己阅历的积淀和对世情的理解。同样是看《潜伏》，有的人能分析地头头是道，非经一番历练之人，不可懂其中深味也。\n希望与失望 当蜘蛛网无情地查封了我的炉台，\n当灰烬的余烟叹息着贫困的悲哀，\n我依然固执地铺平失望的灰烬，\n用美丽的雪花写下：相信未来。\n当我的紫葡萄化为深秋的露水，\n当我的鲜花依偎在别人的情怀，\n我依然固执地用凝霜的枯藤，\n在凄凉的大地上写下：相信未来。\n我要用手指那涌向天边的排浪，\n我要用手掌那托起太阳的大海，\n摇曳着曙光那支温暖漂亮的笔杆，\n用孩子的笔体写下：相信未来。\n我之所以坚定地相信未来，\n是我相信未来人们的眼睛——她有拨开历史风尘的睫毛，\n她有看透岁月篇章的瞳孔。\n不管人们对于我们腐烂的皮肉，\n那些迷途的惆怅，失败的苦痛，\n是寄予感动的热泪，深切的同情，\n还是给以轻蔑的微笑，辛辣的嘲讽。\n我坚信人们对于我们的脊骨，\n那无数次地探索、迷途、失败和成功，\n一定会给予热情、客观、公正的评定，\n是的，我焦急地等待着他们的评定。\n朋友，坚定地相信未来吧，\n相信不屈不挠的努力，\n相信战胜死亡的年轻，\n相信未来，热爱生命。\n—————————— 食指《相信未来》\n诗人食指，在那个黑暗的年代，竟然依然能写出来如此光明的诗；我们当今，虽然也在往更糟的方向狂奔，但是至少目前还比那个年代强一些。 或许，我们应该用饱含热泪的眼睛，永远期待未来。\n2023 年 8 月 31 日夜。\n","permalink":"http://localhost:1313/posts/essays/saysomething/","summary":"\u003cp\u003e谈心的文章好久没有写了，初秋的夜晚，键盘的敲击声格外响亮，一时竟然不知道从哪儿说起。我从今年开始，格外的怀旧起来。不只是怀念那个青春的八十年代，质朴的九十年代，而且竟然怀念起仿佛刚刚过去的两千年。也许是现在回看，带着滤镜和光影的原因吧。但我着实相信，过去确实比现在更加美丽一些。试问，现在还有什么歌曲能像过去的八九十年代扣人心弦，还有谁能写出像罗大佑那样充满人文情怀的歌词？我不是一个保守的人，现在的歌曲我也会经常听，但摇滚光是呐喊、嘶吼没有反思，民谣只有情绪没有韵味，流行歌曲更是惨不忍听。现在一首歌有四句比较朗朗上口一些，就能风靡一时，然后人们快速遗忘，寻找下一个。人们没法不遗忘，因为实在没有什么好怀念的。\u003c/p\u003e\n\u003cp\u003e人们在路上疯狂且快速的奔跑着，前面有人但凡有一点点挡道，便会怒从心头起。也许在快速奔跑中，人们才来不及为过去伤怀，风驰电掣，麻木一生。\u003c/p\u003e\n\u003cp\u003e如果我也这样，多好！\u003c/p\u003e\n\u003cp\u003e可是，我偏偏要将步伐放慢，歪着头想想，于是总感觉自己是个慢半拍的人。\u003c/p\u003e\n\u003cp\u003e今年一整年，几乎没有在公众号上发表任何文章，我想找个没人的地方，倾吐一下自己的想法。\u003c/p\u003e\n\u003ch1 id=\"失落与大门\"\u003e失落与大门\u003c/h1\u003e\n\u003cp\u003e今年是让我特别失落的一年，特别失落。\u003c/p\u003e\n\u003cp\u003e还有几年，就到传说中的中年危机了。坦白说，我直到今年才有些许明白，中年危机的真实含义。\u003c/p\u003e\n\u003cp\u003e所谓中年危机，并不单单是一个经济的问题，而是方方面面。\u003c/p\u003e\n\u003cp\u003e这个尴尬的年纪，朋友帮不上你，于是友情危机；妻子不理解你，于是婚姻危机；父母埋怨你，于是亲情危机。各方面的危机，想汹涌的几股暗流，汇集而来，向涉世未深的你迎面击来。\u003c/p\u003e\n\u003cp\u003e这个年纪，看似血气方刚，实则是最脆弱的年纪，没有经验的积淀，没有人脉的积淀，只有你自己硬抗，像不喝药，凭借自己的身体素质对抗一场重感冒。\u003c/p\u003e\n\u003cp\u003e扛过去，就会好很多。后面遇到再多糟心事，有了前面的抗体，总是会好过一些。\u003c/p\u003e\n\u003cp\u003e呵，男人四十！\u003c/p\u003e\n\u003cp\u003e今年的夏天格外热，但是在每次下班骑车回家的路上，听着歌，经常感觉浑身一阵冷战。也许是突然被某句歌词所触动，伤怀往事、怀疑信念。\u003c/p\u003e\n\u003cp\u003e于是有一阵子，我囤了很多书。最明显的变化是，我开始看外国小说了，以前硬着头皮两次入门、两次放弃的《安娜卡列尼娜》，这次竟然能够看的津津有味，甚至有时候，会有冲动，买下托尔斯泰的《战争与和平》这部据说很冗长的巨著一看。\u003c/p\u003e\n\u003cp\u003e年龄大了，学会妥协了。年少时，看那些翻译过来的腔调，就是不喜欢看不下去，我从来不理解为什么要冗长的心理描写，为什么人物的每一句台词，中间都要被“xxx说”拦腰斩为两截，如此种种。\u003c/p\u003e\n\u003cp\u003e今年突然明白了，这就是文化差异，不同地区的表达习惯，是会有不同的，不只是语汇的区分。我们应该注重的是书里面的所蕴含的光辉思想以及作者倾注的满腔热情。我们在《史记-项羽本纪》里面看不到一句项羽的心理描写，仅凭几句念白，几句描写，一个英雄就这样被人千年。\u003c/p\u003e\n\u003cp\u003e所以，中国会有山水画，笔墨留白，却依然已经满怀，而西方的工笔画、油画也依然是情绪饱满的。\u003c/p\u003e\n\u003cp\u003e留白也有水货，浓墨重彩也有精品。\u003c/p\u003e\n\u003cp\u003e这么想着，一道艺术的大门就这样为我敞开。\u003c/p\u003e\n\u003cp\u003e思想越包容，视野越广阔。有些时候，就是需要换一个视角和思维的转变。\u003c/p\u003e\n\u003ch1 id=\"ai-与艺术\"\u003eAI 与艺术\u003c/h1\u003e\n\u003cp\u003eAI 是今年的热词，仿佛一夜之间，什么都可以用 AI 做了。\u003c/p\u003e\n\u003cp\u003e就在这孤独的一年，我的阅读量和艺术视角，刻意地伸长，触及到了我之前出于懒惰不会触及的地方。就凭我简单的探索，我就知道 AI 根本没戏，虽然，我是一个技术人，但是我从来不认为 AI 能够写出那些不朽的作品，能够勾勒出那些美妙的线条。\u003c/p\u003e\n\u003cp\u003e很简单，因为 AI 不是人，没有意识和灵魂。\u003c/p\u003e\n\u003cp\u003e不是人，所以不会像人一样犯错，与此同时，也缺少了很多偶然。须知，很多艺术就是来源于偶然的灵光一现。\u003c/p\u003e\n\u003cp\u003e当然，还有一个重要的因素，就是伟大的读者催生伟大的作品，我们很难想象，被 AI 和短视频喂饱的读者们会有什么眼光去苛求那些内容的生产者。\u003c/p\u003e\n\u003cp\u003e想来也荒唐，到底是谁训练了谁？\u003c/p\u003e\n\u003cp\u003e将来的市场，AI 肯定是能挤掉一部分人的作品的。那些平庸的、毫无新意和灵魂的作品，会被 AI 取而代之。这或许倒是一个良币驱逐劣币的过程。\u003c/p\u003e\n\u003cp\u003e试看当今的歌坛，有多惨不忍睹就知道，科技能帮助人在艺术道路上走一段路，可是，剩下的路还是要靠人类自己走。\u003c/p\u003e\n\u003cp\u003e这是人类的宿命。\u003c/p\u003e\n\u003cp\u003eAI 也没有用。\u003c/p\u003e\n\u003cp\u003e也许，将来 AI 可能会突然大爆发，像人一样有了意识，但也是需要和人一样有痛苦的经历的。这样，AI 既有了人的意识，又有了人的经历和痛苦，那就是人类无疑了。\u003c/p\u003e\n\u003cp\u003e也许是 AI 被我们人类同化了吧？不知道是否可以当成人类的一场惨胜。\u003c/p\u003e\n\u003ch1 id=\"人文与科技\"\u003e人文与科技\u003c/h1\u003e\n\u003cp\u003e自己今年的时间，比往年多了一些，想做的事情太多，结果现在一件事也没有做成。自己不甘于只做一个消费者，也想做一个内容的生产者。\u003c/p\u003e\n\u003cp\u003e但生成什么内容，却让自己又一次开始了犹豫和纠结。\u003c/p\u003e\n\u003cp\u003e也许，这也是我的宿命，我注定会饿死在人文与科技的十字路口。\u003c/p\u003e\n\u003cp\u003e人文类的内容，是我的兴趣所在，但是目前的境况很是不尽人意，言论管控空前，万马齐喑。再加上饭圈文化和粉丝量的有限和题材内容的饱和，很难找到一个切入口完成一些看似“伟大”的事情。\u003c/p\u003e\n\u003cp\u003e科技类的内容，也是我想做的，看起来比人文的圈子要简单一些，但是，也比较枯燥一些，而且，自己驾驭起来，并不如人文类的容易一些，粉丝量的成长幅度，肯定比不上人文类的 up 主，毕竟大家都想在下班后，躺在床上，听听历史的八卦，谁会主动坐在桌前，听你分享一些你自己以为讲的很明白的原理和架构？\u003c/p\u003e\n\u003cp\u003e但是，自己毕竟是吃技术这碗饭的，而且自己在今年换工作之后，看到身边有的人无知的像一头猪一样，不禁觉得可笑之余，转念一想，自己是否在另一些人的眼里，也无知得可笑呢？于是，我立志，要把自己的技术短板填补上，尽量不看起来像一头猪。\u003c/p\u003e\n\u003cp\u003e综合起来，貌似技术up这条路，自己会走得更踏实一些，而且人文类的内容，要想做得出彩，关键在于自己阅历的积淀和对世情的理解。同样是看《潜伏》，有的人能分析地头头是道，非经一番历练之人，不可懂其中深味也。\u003c/p\u003e\n\u003ch1 id=\"希望与失望\"\u003e希望与失望\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e当蜘蛛网无情地查封了我的炉台，\u003c/p\u003e\n\u003cp\u003e当灰烬的余烟叹息着贫困的悲哀，\u003c/p\u003e\n\u003cp\u003e我依然固执地铺平失望的灰烬，\u003c/p\u003e\n\u003cp\u003e用美丽的雪花写下：相信未来。\u003c/p\u003e","title":"聊点什么"},{"content":"碎碎念。\n","permalink":"http://localhost:1313/posts/gold_bottle/1/","summary":"\u003cp\u003e碎碎念。\u003c/p\u003e","title":"《金瓶梅》"},{"content":"个人读《红楼梦》之所感所思，想到哪儿，写到哪儿，不拘章法，也无体系，不求闻达，但求深思。\n","permalink":"http://localhost:1313/posts/stone/summary/","summary":"\u003cp\u003e个人读《红楼梦》之所感所思，想到哪儿，写到哪儿，不拘章法，也无体系，不求闻达，但求深思。\u003c/p\u003e","title":"《红楼梦》碎碎念"},{"content":" 读书从来都是从第一个字读到最后一个字的事情。—— 乌江亭长\n下笨功夫，从巧处思考。——乌江亭长\n在读 《深入理解Java虚拟机》(二刷) 《Redis设计与实现》（黄建宏） 《张居正》（熊召政） 《红楼梦》 《红楼》碎碎念 《金瓶梅》 一刷 《毛泽东选集》 《乔布斯传》 《三国演义》 《安娜*卡列宁娜》 《坛经》 读完 《Unix传奇》（布莱恩·W·克尼汉） 《邓小平时代》(傅高义) 《置身事内》（兰小欢） 《富爸爸穷爸爸》（罗伯特·清崎） 《万历十五年》（黄仁宇） (二刷) (三刷) 想读 《数据库系统内幕》 《人生的智慧》 ","permalink":"http://localhost:1313/booklist/","summary":"\u003cblockquote\u003e\n\u003cp\u003e读书从来都是从第一个字读到最后一个字的事情。—— 乌江亭长\u003c/p\u003e\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e下笨功夫，从巧处思考。——乌江亭长\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch3 id=\"在读\"\u003e在读\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e《深入理解Java虚拟机》(二刷)\u003c/li\u003e\n\u003cli\u003e《Redis设计与实现》（黄建宏）\u003c/li\u003e\n\u003cli\u003e《张居正》（熊召政）\u003c/li\u003e\n\u003cli\u003e《红楼梦》\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://anriclee.github.io/posts/stone/summary\"\u003e《红楼》碎碎念\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e《金瓶梅》\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"\"\u003e一刷\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e《毛泽东选集》\u003c/li\u003e\n\u003cli\u003e《乔布斯传》\u003c/li\u003e\n\u003cli\u003e《三国演义》\u003c/li\u003e\n\u003cli\u003e《安娜*卡列宁娜》\u003c/li\u003e\n\u003cli\u003e《坛经》\u003c/li\u003e\n\u003cli\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"读完\"\u003e读完\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e《Unix传奇》（布莱恩·W·克尼汉）\u003c/li\u003e\n\u003cli\u003e《邓小平时代》(傅高义)\u003c/li\u003e\n\u003cli\u003e《置身事内》（兰小欢）\u003c/li\u003e\n\u003cli\u003e《富爸爸穷爸爸》（罗伯特·清崎）\u003c/li\u003e\n\u003cli\u003e《万历十五年》（黄仁宇）\n\u003cul\u003e\n\u003cli\u003e(\u003ca href=\"https://anriclee.github.io/posts/readings/booklist/\"\u003e二刷\u003c/a\u003e)\u003c/li\u003e\n\u003cli\u003e(\u003ca href=\"https://anriclee.github.io/posts/readings/booklist/\"\u003e三刷\u003c/a\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"想读\"\u003e想读\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e《数据库系统内幕》\u003c/li\u003e\n\u003cli\u003e《人生的智慧》\u003c/li\u003e\n\u003c/ul\u003e","title":"书单"},{"content":"","permalink":"http://localhost:1313/posts/java/gc/","summary":"","title":"GC"},{"content":"bind listen\naccept\naccept 的方法签名如下：\n#include \u0026lt;sys/socket.h\u0026gt; int accept(int sockfd, struct sockaddr *restrict addr, socklen_t *restrict addrlen); The accept() system call is used with connection-based socket types (SOCK_STREAM, SOCK_SEQPACKET).\nSOCK_STREAM 代表 TCP 连接方式 SOCK_SEQPACKET 代表 UDP 连接方式\n签名中的 sockfd 代表监听的 socket 连接\nIt extracts the first connection request on the queue of pending connections for the listening socket, sockfd, creates a new connected socket, and returns a new file descriptor referring to that socket. The newly created socket is not in the listening state. The original socket sockfd is unaffected by this call.\n这段话给出的信息较多：\nsockfd 是所监听的 socket 的文件描述符； 不知道有多少 client 向该 socket 发起请求，但是这些请求都会排到该 socket 的请求队列中，队列的长度最长可以有多长？？？； accept 方法每次仅从请求队列中取队头进行处理； 处理请求时，会创建一个新的 socket，并返回一个指向该 socket 的文件描述符； 新创建的这个 socket 不在 listen 状态 此次 accept 调用，不影响原来的 socket 的状态 Reference https://www.tutorialspoint.com/unix_sockets/socket_server_example.htm https://man7.org/linux/man-pages/man2/accept.2.html https://www.geeksforgeeks.org/tcp-server-client-implementation-in-c/ https://devarea.com/linux-io-multiplexing-select-vs-poll-vs-epoll/#.YtLNMpdBxQJ https://stevens.netmeister.org/631/09-io-multiplexing.pdf ","permalink":"http://localhost:1313/posts/socket/","summary":"\u003cp\u003ebind\nlisten\u003c/p\u003e\n\u003cp\u003eaccept\u003c/p\u003e\n\u003cp\u003eaccept 的方法签名如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-C\" data-lang=\"C\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;sys/socket.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003eaccept\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003esockfd\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003esockaddr\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"kr\"\u003erestrict\u003c/span\u003e \u003cspan class=\"n\"\u003eaddr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003esocklen_t\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"kr\"\u003erestrict\u003c/span\u003e \u003cspan class=\"n\"\u003eaddrlen\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003eThe accept() system call is used with \u003cstrong\u003econnection-based\u003c/strong\u003e socket types (SOCK_STREAM, SOCK_SEQPACKET).\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003eSOCK_STREAM 代表 TCP 连接方式\nSOCK_SEQPACKET 代表 UDP 连接方式\u003c/p\u003e\n\u003cp\u003e签名中的 sockfd 代表监听的 socket 连接\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eIt extracts the \u003cstrong\u003efirst connection request\u003c/strong\u003e on the queue of pending connections for the listening socket, \u003ccode\u003esockfd\u003c/code\u003e, creates a \u003cstrong\u003enew connected socket\u003c/strong\u003e, and returns a \u003cstrong\u003enew file descriptor\u003c/strong\u003e referring to that socket.  The newly created socket is not in the listening state.  The original socket sockfd is unaffected by this call.\u003c/p\u003e","title":"使用 Socket 创建 TCP 服务器"},{"content":"Reference https://jacktang816.github.io/post/mallocandfree/ ","permalink":"http://localhost:1313/posts/malloc/","summary":"\u003ch1 id=\"reference\"\u003eReference\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://jacktang816.github.io/post/mallocandfree/\"\u003ehttps://jacktang816.github.io/post/mallocandfree/\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e","title":"Linux 系统中的 Malloc 和 Free 到底是什么"},{"content":"0x00 多路复用是什么 0x01 select 官方定义 0x02 视频清晰易懂地介绍了 IO 多路复用中的 select。\nhttps://www.youtube.com/watch?v=Y5PiHboUctw\n","permalink":"http://localhost:1313/posts/io_multiplex/","summary":"\u003ch1 id=\"0x00-多路复用是什么\"\u003e0x00 多路复用是什么\u003c/h1\u003e\n\u003ch1 id=\"0x01-select-官方定义\"\u003e0x01 select 官方定义\u003c/h1\u003e\n\u003ch1 id=\"0x02\"\u003e0x02\u003c/h1\u003e\n\u003cp\u003e视频清晰易懂地介绍了 IO 多路复用中的 select。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.youtube.com/watch?v=Y5PiHboUctw\"\u003ehttps://www.youtube.com/watch?v=Y5PiHboUctw\u003c/a\u003e\u003c/p\u003e","title":"当我们在谈IO多路复用我们在谈论什么系列之 SELECT"},{"content":"","permalink":"http://localhost:1313/posts/redis/redis_design_ch8/","summary":"","title":"Redis_design_ch8"},{"content":"","permalink":"http://localhost:1313/posts/redis/redis_design_ch9/","summary":"","title":"Redis 源码阅读之 AOF 持久化"},{"content":"","permalink":"http://localhost:1313/posts/group_chat/","summary":"","title":"Group_chat"},{"content":"什么是 Bot Bot 的概念在官网的介绍稍微有点繁琐和，详细可以了解官网介绍，\n简单来说，bot 就是你在 telegram 中的一个特殊账号，你申请了 bot，这个 bot 就是你的代理人，你发号施令到 bot，bot 会响应你的指令，仅此而已。\n申请 bot 需要找 BotFather（名字起的很形象），具体过程官网说的比较详细，此处不赘言。但是需要强调的一点是，bot 仅仅是你的代理人而已，真正执行你指令的是你自己部署的脚本，如果你不部署自己的脚本，在 bot 中输入指令，是没有任何响应的。\n你、bot和你部署的脚本关系如下:\n脚本 上面说过了，bot 只是你在 telegram 的一个代理，真正干活的是你的脚本。既然自己写脚本，就会存在两个问题：接受指令、做出响应。\n接受指令 对于如何让脚本接受指令，官方提供了两种思路：推模式 、拉模式。\n拉模式 这种模式，官方不太推荐。简单而言，就是自己部署一个脚本，不断执行 get 请求，获取自己 bot 的更新信息，就好比一个仆人一直在问你：\n有没有需要我做的？\n有没有需要我做的？\n有没有需要我做的？\n询问的方式也比较简单：\ncurl -X GET https://api.telegram.org/bot[token]/getUpdates 这里的 token，就是上面申请 bot 完毕后，得到的 token， 出于脱敏，我使用 [token] 代替，下同。这种方法比较笨拙，轮询的频次太高和太低都不行，而且你在 bot 中发布一条指令后，可能并不能够马上得到执行，会有延迟。\n这种方式的好处是：可以让 bot 启在本地，不需要部署到服务器上，因为 telegram 不知道你的存在，他也不需要知道你的存在。\n推模式 这种方式是官方比较推荐的一种方式，这种类似事件驱动的原理。只有有任务了，才会通知脚本去做。但前提是：在向 bot 发号施令前，需要在 bot 中注册一个 callback url。\nbot 在接受你的指令后，会调用此 url，通知你的脚本，让他执行任务。\n注册方式也比较简单：\ncurl -X POST https://api.telegram.org/bot[token]/setWebhook -H \u0026#34;Content-type: application/json\u0026#34; -d \u0026#39;{\u0026#34;url\u0026#34;: \u0026#34;[YOUR_URL]\u0026#34;} 使用这种方式，会比上一种稍微麻烦一点，需要你部署的服务能够支持 https（这也是为了安全起见）。\n响应指令 收到 telegram 的指令后，如何发送消息到 telegram 频道呢？笔者对 golang 较为熟悉，所以采用了 golang 的方式进行响应。\nfunc Handler(w http.ResponseWriter, r *http.Request) { err := r.ParseForm() if err != nil { log.Printf(\u0026#34;parse form values failed:%+v\u0026#34;, err) } body, _ := r.GetBody() bytes, _ := io.ReadAll(body) msg := string(bytes) // ...... 读取到 query 参数和 body 后，可以进行各种逻辑操作 fmt.Fprintf(w, \u0026#34;result:\u0026#34;+content) } 上面的代码使用到了一个开源库，他替我们封装好了api（当然也可以自己按照 telegram 的协议组装消息）。\n部署脚本 现在有了 bot，也有了响应 bot 的脚本逻辑，只剩部署脚本到服务器了。我们当然不能仅仅为了响应一条指令租一个个人服务器吧（土豪除外）。\n笔者用的是 Vercel 平台，使用 Vercel 部署 ServeLess 的 Function 还是比较方便的，部署过程，跟随步骤指导一步一步来比较容易。\nhttps://vercel.com/\n部署好之后，可以先在本地执行下 curl 请求，测试没问题后，将该 url 设置为 telegram bot 的 callback 函数即可。\n使用 学会一个东西的主要方法，就是疯狂的使用它。本人出入办公单位，都需要扫门禁二维码，不胜其烦，需要关注微信小程序，然后点击门禁二维码，全程既慢且麻烦。\n在一次偶然抓包之后，发现获取二维码的请求是一个简单的 http post 请求，且密码为明文。\n这次体验到了 Serveless 的方便，出于 bot 练习之故，可以将该请求封装到 script 中，部署到 vercel 平台上，在 telegram 申请一个门禁机器人，打开之后，发送指令到 script，script 发起 post 调用，获取到结果后，渲染为二维码即可。\n渲染二维码使用到的开源包\n请求安全性校验 为了安全起见，有人恶意调用你的脚本 url，可以将自己脚本服务的 api 的前缀设置为 token（token 没有人知道，所以也无法知道的 api）。vercel 平台支持通过 vercel.json 进行请求的重定向，可以通过正则表达式，将 randomwdocd23123123[token 示例]/api 转发到 /api。\n{ \u0026#34;routes\u0026#34;:[ { \u0026#34;src\u0026#34;:\u0026#34;/random/(?\u0026lt;id\u0026gt;[^/]*)/api/hello/\u0026#34;, \u0026#34;dest\u0026#34;:\u0026#34;/api/hello.go?id=$id\u0026#34; } ] } 这是利用了官方提供的重定向的特性，详细可以参考官网\nreference 1.Build a serverless Telegram chatbot deployed using Vercel\n","permalink":"http://localhost:1313/posts/telegram_bot/","summary":"\u003ch1 id=\"什么是-bot\"\u003e什么是 Bot\u003c/h1\u003e\n\u003cp\u003eBot 的概念在官网的介绍稍微有点繁琐和，详细可以了解\u003ca href=\"https://core.telegram.org/bots\"\u003e官网介绍\u003c/a\u003e，\u003c/p\u003e\n\u003cp\u003e简单来说，bot 就是你在 telegram 中的一个特殊账号，你申请了 bot，这个 bot 就是你的代理人，你发号施令到 bot，bot 会响应你的指令，仅此而已。\u003c/p\u003e\n\u003cp\u003e申请 bot 需要找 BotFather（名字起的很形象），具体过程官网说的比较详细，此处不赘言。但是需要强调的一点是，bot 仅仅是你的代理人而已，真正执行你指令的是你自己部署的脚本，如果你不部署自己的脚本，在 bot 中输入指令，是没有任何响应的。\u003c/p\u003e\n\u003cp\u003e你、bot和你部署的脚本关系如下:\u003c/p\u003e\n\u003cp\u003e\n  \u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/anriclee/diagramStorage/master/telegram.drawio.png\" alt=\"\u0026ldquo;你、bot和你部署的脚本\u0026rdquo;\"  /\u003e\u003c/p\u003e\n\u003ch1 id=\"脚本\"\u003e脚本\u003c/h1\u003e\n\u003cp\u003e上面说过了，bot 只是你在 telegram 的一个代理，真正干活的是你的脚本。既然自己写脚本，就会存在两个问题：接受指令、做出响应。\u003c/p\u003e\n\u003ch2 id=\"接受指令\"\u003e接受指令\u003c/h2\u003e\n\u003cp\u003e对于如何让脚本接受指令，官方提供了两种思路：推模式 、拉模式。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e拉模式\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这种模式，官方不太推荐。简单而言，就是自己部署一个脚本，不断执行 get 请求，获取自己 bot 的更新信息，就好比一个仆人一直在问你：\u003c/p\u003e\n\u003cp\u003e有没有需要我做的？\u003c/p\u003e\n\u003cp\u003e有没有需要我做的？\u003c/p\u003e\n\u003cp\u003e有没有需要我做的？\u003c/p\u003e\n\u003cp\u003e询问的方式也比较简单：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ecurl -X GET https://api.telegram.org/bot[token]/getUpdates\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这里的 token，就是上面申请 bot 完毕后，得到的 token， 出于脱敏，我使用 [token] 代替，下同。这种方法比较笨拙，轮询的频次太高和太低都不行，而且你在 bot 中发布一条指令后，可能并不能够马上得到执行，会有延迟。\u003c/p\u003e\n\u003cp\u003e这种方式的好处是：可以让 bot 启在本地，不需要部署到服务器上，因为 telegram 不知道你的存在，他也不需要知道你的存在。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e推模式\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这种方式是官方比较推荐的一种方式，这种类似事件驱动的原理。只有有任务了，才会通知脚本去做。但前提是：在向 bot 发号施令前，需要在 bot 中注册一个 callback url。\u003c/p\u003e\n\u003cp\u003ebot 在接受你的指令后，会调用此 url，通知你的脚本，让他执行任务。\u003c/p\u003e\n\u003cp\u003e注册方式也比较简单：\u003c/p\u003e","title":"Telegram bot 入门实践"},{"content":"背景 2021年年初，探探上线了群聊功能，并且支持按照群名进行模糊搜索。\n对于复杂场景的搜索，业界一般使用非常流行的 ElasticSearch。由于我们的群数据较少，截止到目前还没有达到千万级的量级，且搜索场景比较简单，而 PostgreSQL 对全文搜索又支持得比较好，所以选择了 PostgreSQL 来实现群搜索需求。 在使用 PostgreSQL 做群搜索的过程中，也经历了由简单到复杂的迭代过程，中间也踩了不少坑。 下面的几个例子说明了方案的演进过程和我们的优化思路，希望能够对大家有所帮助。\nLIKE 模糊查询 提到模糊搜索，最简单的办法就是对搜索列进行 like 匹配： 在输入词的前后加上 % 即可,如下所示:\nSELECT * FROM groups WHERE name LIKE \u0026#39;%探探%\u0026#39;; 这种方案可行是可行了，但是实现过于简单粗暴。对此方案进行测试：\n建一张简单的表进行测试，表结构如下：\nlixuehan=# \\d groups; Table \u0026#34;public.groups\u0026#34; Column | Type | Collation | Nullable | Default --------+-----------------------+-----------+----------+------------------------------------ id | bigint | | not null | nextval(\u0026#39;groups_id_seq\u0026#39;::regclass) name | character varying(50) | | | Indexes: \u0026#34;groups_pkey\u0026#34; PRIMARY KEY, btree (id) 表中只有两列：主键 id 以及群名 name。\ncreate or replace function gen_hanzi(int) returns text as $$ declare res text; begin if $1 \u0026gt;=1 then select string_agg(chr(19968+(random()*20901)::int), \u0026#39;\u0026#39;) into res from generate_series(1,$1); return res; end if; return null; end; $$ language plpgsql strict; gen_hanzi 是一个随机生成汉字的函数，我们使用一个该函数构造 100w 条数据，插入到该表中。\nlixuehan=# insert into groups(name) select gen_hanzi(20) from generate_series(1,1000000); INSERT 0 1000000 lixuehan=# select count(*) from groups; count -------- 1000000 (1 row) 现在开始对上表根据 name 列进行 like 搜索。\nSELECT * FROM groups WHERE name LIKE \u0026#39;%探探%\u0026#39;; 查看其执行计划\nlixuehan=# explain analyze select * from groups where name like \u0026#39;%探探%\u0026#39;; QUERY PLAN ------------------------------------------------------------------------------------------------------------------------ Gather (cost=1000.00..20321.24 rows=110 width=69) (actual time=0.388..116.679 rows=1 loops=1) Workers Planned: 2 Workers Launched: 2 -\u0026gt; Parallel Seq Scan on groups (cost=0.00..19310.24 rows=46 width=69) (actual time=64.666..101.982 rows=0 loops=3) Filter: ((name)::text ~~ \u0026#39;%探探%\u0026#39;::text) Rows Removed by Filter: 366671 Planning Time: 0.182 ms Execution Time: 116.694 ms 搜索执行耗时接近 117ms，全表扫描，显然有优化空间。\n建 Btree 索引 在 PostgreSQL 官方网站上看到了这样一句话：\nThe optimizer can also use a B-tree index for queries involving the pattern matching operators LIKE and ~ if the pattern is a constant and is anchored to the beginning of the string — for example, col LIKE \u0026lsquo;foo%\u0026rsquo; or col ~ \u0026lsquo;^foo\u0026rsquo;, but not col LIKE \u0026lsquo;%bar\u0026rsquo;.\n官方推荐的做法是给搜索列建立 btree 索引，但是不支持前模糊查询（为避免歧义，这里的「前模糊查询」指的是前缀不确定的查询，「后模糊查询」指的是后缀不确定的查询，后面不再赘述）。\n于是，我们尝试对 name 列构建 btree 索引。\ncreate index group_name_idx on groups using btree(name); 然后再对该表执行查询，分别执行前模糊、后模糊和两边均模糊三种：\nlixuehan=# explain analyze select * from groups where name like \u0026#39;%探探大群%\u0026#39;; QUERY PLAN ------------------------------------------------------------------------------------------------------------------------- Gather (cost=1000.00..20321.24 rows=110 width=127) (actual time=0.158..108.548 rows=1 loops=1) Workers Planned: 2 Workers Launched: 2 -\u0026gt; Parallel Seq Scan on groups (cost=0.00..19310.24 rows=46 width=127) (actual time=66.183..101.712 rows=0 loops=3) Filter: ((name)::text ~~ \u0026#39;%探探大群%\u0026#39;::text) Rows Removed by Filter: 366671 Planning Time: 0.098 ms Execution Time: 108.756 ms (8 rows) lixuehan=# explain analyze select * from groups where name like \u0026#39;探探大群%\u0026#39;; QUERY PLAN ---------------------------------------------------------------------------------------------------------------------------- Index Scan using groups_name_idx on groups (cost=0.55..8.57 rows=110 width=127) (actual time=0.810..0.811 rows=1 loops=1) Index Cond: (((name)::text \u0026gt;= \u0026#39;探探大群\u0026#39;::text) AND ((name)::text \u0026lt; \u0026#39;探探大羥\u0026#39;::text)) Filter: ((name)::text ~~ \u0026#39;探探大群%\u0026#39;::text) Planning Time: 1.229 ms Execution Time: 0.829 ms (5 rows) lixuehan=# explain analyze select * from groups where name like \u0026#39;%探探大群\u0026#39;; QUERY PLAN ------------------------------------------------------------------------------------------------------------------------ Gather (cost=1000.00..20321.24 rows=110 width=127) (actual time=0.161..104.288 rows=1 loops=1) Workers Planned: 2 Workers Launched: 2 -\u0026gt; Parallel Seq Scan on groups (cost=0.00..19310.24 rows=46 width=127) (actual time=64.530..98.686 rows=0 loops=3) Filter: ((name)::text ~~ \u0026#39;%探探大群\u0026#39;::text) Rows Removed by Filter: 366671 Planning Time: 0.094 ms Execution Time: 104.315 ms (8 rows) 可以看到，只有在执行后模糊查询时，命中索引，耗时缩短到了 0.829ms。\n不支持前模糊查询没有关系，再建一个反向索引即可：\nCREATE INDEX ON groups(reverse(name)); 执行搜索时，执行反向查询，如下：\nselect * from groups where reverse(name) like reverse(\u0026#39;%探探\u0026#39;); 查看其执行计划：\nBitmap Heap Scan on groups (cost=292.93..10708.01 rows=5500 width=127) Filter: (reverse((name)::text) ~~ \u0026#39;探探%\u0026#39;::text) -\u0026gt; Bitmap Index Scan on groups_reverse_idx (cost=0.00..291.55 rows=5500 width=0) Index Cond: ((reverse((name)::text) \u0026gt;= \u0026#39;探探\u0026#39;::text) AND (reverse((name)::text) \u0026lt; \u0026#39;探掣\u0026#39;::text)) (4 rows) 可以看到已经命中了 groups_reverse_idx 索引。\n这样，在业务代码中最多执行两次，即可实现前后模糊搜索（虽然看起来比较笨，但是也勉强实现了需求）。但是接下来，遇到的问题让人感到头疼。\n在执行简单测试时，发现我们的测试环境可以走索引，但是生产环境却不能！！！\n在查询资料后，得知这种模糊查询命中索引的方案跟数据库的 Locale 设置有关系，而当时我们生产环境的设置和测试环境的 Locale 设置是不一样的。\n可以执行下面的命令查询一个库的 Locale 设置。\nlixuehan=# \\l+ lixuehan List of databases Name | Owner | Encoding | Collate | Ctype | Access privileges | Size | Tablespace | Description ----------+----------+----------+---------+-------+-------------------+-------+------------+------------- lixuehan | lixuehan | UTF8 | C | C | | 28 MB | pg_default | (1 row) 这里的 Collate 和 Ctype 就是跟 Locale 相关的两个参数，在 Ctype 为 en_US.UTF-8 时，直接对搜索列建 Btree 索引，无法实现预期效果。\n上面我们用来举例的数据库，正好 Ctype 和 Collate 均为 C，是支持模糊搜索的。对于这两个参数的设置，官网有如下描述：\nSome locale categories must have their values fixed when the database is created. You can use different settings for different databases, but once a database is created, you cannot change them for that database anymore. LC_COLLATE and LC_CTYPE are these categories.\n这里说的很明白，一旦数据库被创建了，就不能更改其 LC_COLLATE 和 LC_CTYPE 设置了（这两个参数分别对应上面的 Collate 和 Ctype）。\n为此，再建一个 Locale 非 C 的数据库，重复上面的查询。\ncreate database lixuehan2 LC_COLLATE \u0026#39;en_US.UTF-8\u0026#39; LC_CTYPE \u0026#39;en_US.UTF-8\u0026#39; TEMPLATE template0; lixuehan2=# explain analyze select * from groups where name like \u0026#39;探%\u0026#39;; QUERY PLAN ----------------------------------------------------------------------------------------------------------------------- Gather (cost=1000.00..20321.17 rows=110 width=69) (actual time=0.364..71.770 rows=59 loops=1) Workers Planned: 2 Workers Launched: 2 -\u0026gt; Parallel Seq Scan on groups (cost=0.00..19310.17 rows=46 width=69) (actual time=1.583..58.687 rows=20 loops=3) Filter: ((name)::text ~~ \u0026#39;探%\u0026#39;::text) Rows Removed by Filter: 366647 Planning Time: 0.225 ms Execution Time: 71.798 ms (8 rows) 可以看到，执行计划已经变为全表扫描，无法达到预期效果。\n那么 Locale 是什么？\n维基百科给出的解释：\n区域设置（locale），也称作“本地化策略集”、“本地环境”，是表达程序用户地区方面的软件设定。不同系统、平台、与软件有不同的区域设置处理方式和不同的设置范围，但是一般区域设置最少也会包括语言和地区。操作系统的区域设置通常比较复杂。区域设置的内容包括：数据格式、货币金额格式、小数点符号、千分位符号、度量衡单位、通货符号、日期写法、日历类型、文字排序、姓名格式、地址等等。\n简单来说，就是一个与区域文化相关的内容显示及解析问题。\n为什么 LC_TYPE 为 en_US.UTF-8 类型的 Locale，不能支持中文的 like 索引？\n这里摘抄 PostgreSQL 官方给出的解释：\nOn all platforms, the collations named default, C, and POSIX are available. Additional collations may be available depending on operating system support. The default collation selects the LC_COLLATE and LC_CTYPE values specified at database creation time. The C and POSIX collations both specify “traditional C” behavior, in which only the ASCII letters “A” through “Z” are treated as letters, and sorting is done strictly by character code byte values.\n总结就是：在所有平台上，名为 default、C 和 POSIX 的排序规则都可用，其他的排序必须操作系统支持。数据库默认只支持 C 和 POSIX 排序，而其排序方式就是最简单的按照 ASCII 字母表进行排序。所以，如果将 Locale 设置为 en_US.UTF-8，底层操作系统不支持，数据库自然也不会支持按照这种编码排序了。\nGIN 索引 实际上，使用 PostgreSQL 进行模糊搜索时，除了使用 Btree 索引，还可以使用 GIN 索引。\n什么是 GIN 索引呢？\nGIN，全称为通用倒排索引（Generalized Inverted Index）。倒排索引也被称为反向索引，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。 也就是说，知道某个词，就可以知道这个词出现在文档的哪些位置。\n在 GIN 中全文搜索的基本单元就是 document，在 GIN 中查询一个词，即查询出现这个词的所有 document。为了搜索方便，document 会被转化成一个特殊的类型：tsvector。\ntsvector 由 lexemes（语素） 和lexemes 出现在 document 中的位置组成。\n这里出现的术语较多，举个例子就明白了：\npostgres=# select to_tsvector(\u0026#39;There was a crooked man, and he walked a crooked mile\u0026#39;); to_tsvector ----------------------------------------- \u0026#39;crook\u0026#39;:4,10 \u0026#39;man\u0026#39;:5 \u0026#39;mile\u0026#39;:11 \u0026#39;walk\u0026#39;:8 (1 row) 上面的查询利用 PostgreSQL 自带的 to_tsvector 函数将一句话转换为了多个 tsvector。\n在上面的例子中，'crook':4,10 为第一个 tsvector，第一部分为语素：crook，第二部分为出现的位置：句中的第 4 个和第 10 个单词的位置（下标从 1 开始），以此类推。\n这里的停用词（\u0026ldquo;there\u0026rdquo;, \u0026ldquo;was\u0026rdquo;, \u0026ldquo;a\u0026rdquo;, \u0026ldquo;and\u0026rdquo;, \u0026ldquo;he\u0026rdquo;）全部被去掉（因为这些词出现的频率太高了，对于搜索起到的作用非常有限）。\n其实看到这里，大家已经明白，将所有待搜索内容转换为 tsvector，其实就是一个预处理的过程，单纯是为了后面执行搜索方便。\n待搜索内容要处理，要匹配的搜索内容当然也需要处理。\n在 PostgreSQL 中，tsquery 表示搜索词。一般而言，tsquery 由 lexemes 加上一些特殊符号组成，如下：\npostgres=# select to_tsquery(\u0026#39;man \u0026amp; (walking | running)\u0026#39;); to_tsquery ---------------------------- \u0026#39;man\u0026#39; \u0026amp; ( \u0026#39;walk\u0026#39; | \u0026#39;run\u0026#39; ) (1 row) PostgreSQL 提供了丰富的关系符号，用于 tsquery 和 tsvector 的操作，这里仅列出其中一部分：\n操作符 描述 例子 @@ tsvector 匹配 tsquery to_tsvector(\u0026lsquo;fat cats ate rats\u0026rsquo;) @@ to_tsquery(\u0026lsquo;cat \u0026amp; rat\u0026rsquo;) @\u0026gt; tsquery 包含另外一个 tsquery \u0026lsquo;cat\u0026rsquo;::tsquery @\u0026gt; \u0026lsquo;cat \u0026amp; rat\u0026rsquo;::tsquery \u0026lt;@ tsquery 包含在另外一个 tsquery \u0026lsquo;cat\u0026rsquo;::tsquery \u0026lt;@ \u0026lsquo;cat \u0026amp; rat\u0026rsquo;::tsquery 对 GIN 索引更加详细的介绍，这里不再展开，只需要知道它是一个能够加快全文搜索的倒排索引即可。\n我们马上对这个表建立 GIN 索引。\nCREATE EXTENSION pg_trgm; -- 需要依赖这个扩展 CREATE INDEX gin_index ON groups USING gin(name gin_trgm_ops); 再次执行查询：\npostgres=# explain analyze select * from groups where name like \u0026#39;%探探大%\u0026#39;; QUERY PLAN --------------------------------------------------------------------------------------------------------------------- Bitmap Heap Scan on groups (cost=28.77..403.03 rows=100 width=69) (actual time=0.142..0.171 rows=1 loops=1) Recheck Cond: ((name)::text ~~ \u0026#39;%探探大%\u0026#39;::text) Rows Removed by Index Recheck: 1 Heap Blocks: exact=2 -\u0026gt; Bitmap Index Scan on gin_index (cost=0.00..28.75 rows=100 width=0) (actual time=0.129..0.130 rows=2 loops=1) Index Cond: ((name)::text ~~ \u0026#39;%探探大%\u0026#39;::text) Planning Time: 0.165 ms Execution Time: 0.202 ms (8 rows) 可以看出，通过建立 GIN 索引，前后模糊查询均已经支持走索引，执行时间较短，无需执行正反两次查询。但是更换索引结构，还是不能解决对 Locale 的强依赖问题。\ntest=# explain analyze select * from groups where name like \u0026#39;探探大%\u0026#39;; QUERY PLAN -------------------------------------------------------------------------------------------------------------------------------- Bitmap Heap Scan on groups (cost=536.77..911.03 rows=100 width=69) (actual time=561.098..561.100 rows=0 loops=1) Recheck Cond: ((name)::text ~~ \u0026#39;探探大%\u0026#39;::text) Rows Removed by Index Recheck: 1000000 Heap Blocks: exact=12346 -\u0026gt; Bitmap Index Scan on gin_index (cost=0.00..536.75 rows=100 width=0) (actual time=269.319..269.319 rows=1000000 loops=1) Index Cond: ((name)::text ~~ \u0026#39;探探大%\u0026#39;::text) Planning Time: 0.200 ms Execution Time: 561.157 ms (8 rows) test=# \\l test List of databases Name | Owner | Encoding | Collate | Ctype | Access privileges ------+----------+----------+---------+-------+------------------- test | postgres | UTF8 | C | C | (1 row) 上面的例子说明：在 LC_CTYPE 为 C 时虽然走了索引，但是比全表查询还慢。再仔细看，大部分时间都耗在了 Recheck 上，说明，第一轮根据Bitmap 索引查询得到的结果，准确率很低。\n前面的 Like 查询在 LC_CTYPE 不为 C 时不支持，这里的 GIN 索引当LC_CTYPE 为 C 时又比较慢，人生为何如此艰难？\n问题有可能出现在了分词上。 好在 PostgreSQL 给出了一个调试函数 show_trgm 使用这个函数，可以测试分词结果。\ntest=# select show_trgm(\u0026#39;探探大群\u0026#39;); show_trgm ----------- {} (1 row) test=# select show_trgm(\u0026#39;tantanda\u0026#39;); show_trgm ----------------------------------------- {\u0026#34; t\u0026#34;,\u0026#34; ta\u0026#34;,and,ant,\u0026#34;da \u0026#34;,nda,nta,tan} (1 row) 再使用一个 Locale 为 en_US.UTF-8 的数据库执行分词：\npostgres=\u0026gt; \\l+ postgres 数据库列表 名称 | 拥有者 | 字元编码 | 校对规则 | Ctype | 存取权限 | 大小 | 表空间 | 描述 ----------+----------+----------+-------------+-------------+-----------------------+--------+------------+-------------------------------------------- postgres | postgres | UTF8 | en_US.UTF-8 | en_US.UTF-8 | =Tc/postgres +| 224 MB | pg_default | default administrative connection database | | | | | postgres=CTc/postgres+| | | | | | | | lixuehan=CTc/postgres | | | (1 行记录) postgres=\u0026gt; select show_trgm(\u0026#39;探探大群\u0026#39;); show_trgm ------------------------------------------------ {0x98caf4,0xe3fef2,0xfcd2fa,0xff676b,0x4cb10e} 虽然添加了 pg_trgm 扩展插件，但是在 LC_CTYPE 非 C 时，分词函数并没有对中文生效，查询时即使走了索引，但在返回数据时进行的 Recheck 操作，耗费了太多时间，导致查询速度变慢。\n再回到前面，我们在创建 GIN 索引时，先使用了 pg_trgm 这个扩展插件，这个插件是个什么东东呢？\n还是得查看 PostgreSQL 官方的介绍：\nThe pg_trgm module provides functions and operators for determining the similarity of ASCII alphanumeric text based on trigram matching, as well as index operator classes that support fast searching for similar strings.\npg_trgm 模块提供函数和操作符来测定字母，数字，文本基于三元模型匹配的相似性， 还有支持快速搜索相似字符串的索引操作符类。\n打个比方foo的三元模型的集合为：\n[][]f、[]fo、foo、oo[]\n这里用 [] 表示空，也就是说 pg_trgm 将字符串拆解成三个字符一组，如果不满三个，则用空格填充。\n那么问题来了，如果我使用了 pg_trgm 扩展插件，且 LC_CTYPE 为 en_US.UTF-8 ，是不是查询效率就一定高呢？\n不然。\n且看下面三个例子：\npostgres=# explain analyze select * from groups where name like \u0026#39;%探探大%\u0026#39;; QUERY PLAN --------------------------------------------------------------------------------------------------------------------- Bitmap Heap Scan on groups (cost=28.77..403.03 rows=100 width=69) (actual time=0.066..0.111 rows=1 loops=1) Recheck Cond: ((name)::text ~~ \u0026#39;%探探大%\u0026#39;::text) Rows Removed by Index Recheck: 1 Heap Blocks: exact=2 -\u0026gt; Bitmap Index Scan on gin_index (cost=0.00..28.75 rows=100 width=0) (actual time=0.049..0.050 rows=2 loops=1) Index Cond: ((name)::text ~~ \u0026#39;%探探大%\u0026#39;::text) Planning Time: 0.213 ms Execution Time: 0.149 ms (8 rows) postgres=# explain analyze select * from groups where name like \u0026#39;%探探%\u0026#39;; QUERY PLAN ------------------------------------------------------------------------------------------------------------------------- Gather (cost=1000.00..18564.33 rows=100 width=69) (actual time=0.666..238.445 rows=1 loops=1) Workers Planned: 2 Workers Launched: 2 -\u0026gt; Parallel Seq Scan on groups (cost=0.00..17554.33 rows=42 width=69) (actual time=146.700..225.407 rows=0 loops=3) Filter: ((name)::text ~~ \u0026#39;%探探%\u0026#39;::text) Rows Removed by Filter: 333333 Planning Time: 0.152 ms Execution Time: 238.469 ms (8 rows) postgres=# explain analyze select * from groups where name like \u0026#39;%探%\u0026#39;; QUERY PLAN ------------------------------------------------------------------------------------------------------------------------- Gather (cost=1000.00..18564.33 rows=100 width=69) (actual time=0.427..224.734 rows=980 loops=1) Workers Planned: 2 Workers Launched: 2 -\u0026gt; Parallel Seq Scan on groups (cost=0.00..17554.33 rows=42 width=69) (actual time=1.493..207.726 rows=327 loops=3) Filter: ((name)::text ~~ \u0026#39;%探%\u0026#39;::text) Rows Removed by Filter: 333007 Planning Time: 0.235 ms Execution Time: 224.913 ms (8 rows) 上面的例子中，分别对待搜索字数为 3 个、 2 个、 1 个三种情况进行测试，发现关键词很短的情况（1-2汉字）的情况下召回率很差，无法走索引，只能进行全表扫，查询时间超过了 200ms。\n业务分词 从前面分析可知，使用 PostgreSQL 自带分词扩展插件存在以下不足：\n1.关键词很短的情况（1-2汉字）的情况下召回率很差，特别是只有一个字时，是无法走索引的，只能进行全表扫。\n2.定制性太差，只能使用它自己定义的逻辑来定义字符串的相似度\n3.对 LC_CTYPE 有特殊的要求，可移植性较差 ，默认的 LC_CTYPE 无法正确对中文进行分词。\n于是，我们决定在业务中使用分词。\n分词：在维护阶段，每一个被模糊搜索的字段（例如应用名称），在业务代码中使用分词包加工处理成一系列关键词。 索引：在数据库中建立关键词到表记录的倒排索引 查询：将查询同样拆解为关键词，然后利用查询关键词通过倒排索引找出相关的记录来。 所以，我们打算采用业务代码分词 + PG查询的方式进行：\n在业务表中新增一列，专门用来存放搜索列的分词结果 更新或者新插入记录时，在业务代码中进行分词，将分词结果，以 tsvector 的形式存储到新增列中 执行查询时，同样使用业务代码对待搜索内容进行分词，转换为 tsquery 形式，与 tsvector 进行匹配 这样的好处：分词方法可以完全按照我们自己的定制的方案进行，如果后面需要支持拼音搜索、拼音首字母搜索等其他方式，在 DB 层面不需要更改，只需要更改业务代码中的分词逻辑即可。\n分词方案 常见的分词模式，主要分为：全模式、精确模式和单字模式三种。\n以对「我来到了北京清华大学」这句话为例：\n【全模式】: 我/ 来到/ 北京/ 清华/ 清华大学/ 华大/ 大学 【精确模式】: 我/ 来到/ 北京/ 清华大学 【单字模式】：我/ 来/ 到/ 北/ 京/ 清/ 华/ 大/ 学 【全模式+精确模式+单字模式】：我/ 来到/ 北京/ 清华/ 清华大学/ 华大/ 大学/ 我/ 来/ 到/ 北/ 京/ 清/ 华/ 大/ 学 上面的第四种模式，是在群聊业务中使用到的模式，在下面会介绍到。\n群聊业务中根据业务使用场景的不同，采用了不同的分词模式进行：\n在新增群或者群名变更时，由于对于群名要尽可能列举出来每一种分词的可能，所以采用了「全模式+精确模式+单字模式」结合的思路进行。\n比如群名：「爱宠物的单身男女们」\n使用分词包进行分词后，结果为：「爱、宠物、单身、男女」\n这时，如果输入「女」进行查询，则由于在插入群数据时，没有对该群名分出来「女」这个语素，所以是无法查询出来的。\n针对此缺陷，所以本次采用第四种的订制模式：「爱」「宠」「物」「的」「单」「身」「男」「女」「们」「宠物」「单身」「男女」。这样基本就把所有可能的模式尽可能列举出来了。\n搜索群时对于用户输入的字符串采用了「分词模式」进行。\n比如用户输入「女神经」，如果按照「全模式+分词模式」，结果就会为：「女」「神」「经」「神经」。\n这样就会把所有只包含「女」或者「神」字的记录也查询出来，而只包含「神」的记录大概率是用户不想搜出来的，如果返回这些记录会让用户感觉莫名其妙，用户体验较差。\n如果只采用「分词模式」，则会只搜索「女」或者「神经」，在体验上较好一些，匹配效率更高。\n分词包 目前使用比较多的分词包主要有：gojieba 、 jiebago、sego、gse。\n给定相同词典，大小为 9.2MB，让这四种分词包分别加载后，分析其指标（使用 pprof 方法分析）。\n由于我们业务场景中使用的是对短句切分（不超过14个字），这几个包官方给出的分词效率都是 KB/s 级别，对于我们的使用场景，性能绰绰有余，所以我们重点放在了内存占用指标的对比上。\n执行下面命令，查看这四个分词包内存情况：\ngo tool pprof -inuse_space http://127.0.0.1:6060/debug/pprof/heap gse 包\n(pprof) top Showing nodes accounting for 116.65MB, 100% of 116.65MB total Showing top 10 nodes out of 19 flat flat% sum% cum cum% 50.04MB 42.90% 42.90% 50.04MB 42.90% github.com/go-ego/cedar.(*Cedar).addBlock 33.11MB 28.38% 71.28% 83.15MB 71.28% github.com/go-ego/gse.(*Dictionary).addToken 28.50MB 24.43% 95.71% 28.50MB 24.43% github.com/go-ego/gse.(*Segmenter).SplitTextToWords 3MB 2.57% 98.29% 116.65MB 100% github.com/go-ego/gse.(*Segmenter).Reader 2MB 1.71% 100% 2MB 1.71% fmt.(*ss).convertString 0 0% 100% 2MB 1.71% fmt.(*ss).doScan 0 0% 100% 2MB 1.71% fmt.(*ss).scanOne 0 0% 100% 2MB 1.71% fmt.Fscanln 0 0% 100% 50.04MB 42.90% github.com/go-ego/cedar.(*Cedar).Insert 0 0% 100% 50.04MB 42.90% github.com/go-ego/cedar.(*Cedar).findPlaces 内存占用为 116.65MB。\nsego 包\nType: inuse_space Time: May 17, 2021 at 11:43am (CST) Entering interactive mode (type \u0026#34;help\u0026#34; for commands, \u0026#34;o\u0026#34; for options) (pprof) top Showing nodes accounting for 122.61MB, 99.59% of 123.11MB total Dropped 3 nodes (cum \u0026lt;= 0.62MB) Showing top 10 nodes out of 16 flat flat% sum% cum cum% 41.39MB 33.62% 33.62% 78.60MB 63.85% github.com/huichen/sego.(*Dictionary).addToken 36.71MB 29.82% 63.44% 36.71MB 29.82% github.com/adamzy/cedar-go.(*cedar).addBlock 33MB 26.81% 90.25% 33MB 26.81% github.com/huichen/sego.splitTextToWords 8.50MB 6.90% 97.16% 123.11MB 100% github.com/huichen/sego.(*Segmenter).LoadDictionary 3MB 2.44% 99.59% 3MB 2.44% fmt.(*ss).convertString 0 0% 99.59% 3MB 2.44% fmt.(*ss).doScan 0 0% 99.59% 3MB 2.44% fmt.(*ss).scanOne 0 0% 99.59% 3MB 2.44% fmt.Fscanln 0 0% 99.59% 36.71MB 29.82% github.com/adamzy/cedar-go.(*Cedar).Insert 0 0% 99.59% 36.71MB 29.82% github.com/adamzy/cedar-go.(*cedar).findPlaces 内存占用 123.11MB。\njiebago\nType: inuse_space Time: May 17, 2021 at 11:38am (CST) Entering interactive mode (type \u0026#34;help\u0026#34; for commands, \u0026#34;o\u0026#34; for options) (pprof) top Showing nodes accounting for 25.30MB, 100% of 25.30MB total Showing top 10 nodes out of 11 flat flat% sum% cum cum% 21.72MB 85.84% 85.84% 21.72MB 85.84% github.com/wangbin/jiebago.(*Dictionary).addToken 2.58MB 10.21% 96.05% 2.58MB 10.21% github.com/wangbin/jiebago/finalseg.init.0 1MB 3.95% 100% 1MB 3.95% bufio.(*Scanner).Text 0 0% 100% 21.72MB 85.84% github.com/wangbin/jiebago.(*Dictionary).Load 0 0% 100% 21.72MB 85.84% github.com/wangbin/jiebago.(*Dictionary).loadDictionary 0 0% 100% 21.72MB 85.84% github.com/wangbin/jiebago.(*Segmenter).LoadDictionary 0 0% 100% 21.72MB 85.84% github.com/wangbin/jiebago/dictionary.LoadDictionary 0 0% 100% 1MB 3.95% github.com/wangbin/jiebago/dictionary.loadDictionary.func1 0 0% 100% 21.72MB 85.84% my-project/src/tokens/jiebago.init.0 0 0% 100% 24.30MB 96.05% runtime.doInit 内存占用 25.30MB。\ngojieba\nType: inuse_space Time: May 17, 2021 at 11:42am (CST) Entering interactive mode (type \u0026#34;help\u0026#34; for commands, \u0026#34;o\u0026#34; for options) (pprof) top Showing nodes accounting for 520.04kB, 100% of 520.04kB total flat flat% sum% cum cum% 520.04kB 100% 100% 520.04kB 100% runtime/pprof.writeHeapInternal 0 0% 100% 520.04kB 100% net/http.(*ServeMux).ServeHTTP 0 0% 100% 520.04kB 100% net/http.(*conn).serve 0 0% 100% 520.04kB 100% net/http.HandlerFunc.ServeHTTP 0 0% 100% 520.04kB 100% net/http.serverHandler.ServeHTTP 0 0% 100% 520.04kB 100% net/http/pprof.Index 0 0% 100% 520.04kB 100% net/http/pprof.handler.ServeHTTP 0 0% 100% 520.04kB 100% runtime/pprof.(*Profile).WriteTo 0 0% 100% 520.04kB 100% runtime/pprof.writeHeap 总共占用内存约为 520.04kB。\n在占用内存方面：gojieba \u0026lt; jiebago \u0026lt; gse \u0026lt; sego。\n除此之外，也对比了一些其他方面的指标：\n包名 维护情况（最近一次提交时间） start 数 contributor 数 自带分词库大小 不足 亮点 gojieba 2020年1月 1.4k 11 11M 1.不支持 mac 开发环境交叉编译 2.有issues提到在并发情况下会panic，亲测无此问题 3.底层使用 C++ 实现分词算法，通过 cgo 调用实现，测试环境由于缺少 g++ 执行文件，构建失败，对于环境依赖性较高。 号称是国内使用人数最多的 go 语言分词库 jiebago 2015年5月 358 1 5.1M 维护活跃度低，基本不维护了。 sego 2018年6月 1.5k 6 8.6M 仓库中给出的demo分词效果较差（“中华人民共和国”分为了7个字），代码风格较差，log.fatalf panic 满天飞 作者为前 Google 大佬，对 go 和分词熟悉 gse 2021年3月 1.6k 4 14M 加载自带的分词库占用内存较大。 代码风格较好，注释较为详尽 综合前面的对照表，可知每种包都有各自的优缺点，代码质量也良莠不齐。\n维护情况：jiebago \u0026lt; sego \u0026lt; gojieba \u0026lt; gse\nstar 数：jiebago \u0026lt; gojieba \u0026lt; sego \u0026lt; gse\n综合考虑以上因素，选择了对于代码更具掌控性的 gse 作为分词包，虽然内存占用较大，但是如果单独抽象出来一个公共服务，专门提供分词能力，不影响核心服务即可。\n倒排 如前所述，我们再业务表中新增一列存储分词结果：group_name_tokens。\nPostgreSQL 官方文档推荐两种方法建立索引：\n1）直接对 group_name_tokens 建立函数索引，比如：\nCREATE INDEX group_idx ON groups USING GIN (to_tsvector(config_name, body));--to_tsvector 是PG内置的函数 2）直接将该列设置为 tsvector 类型，直接对 tsvector 类型列建立索引。\nALTER TABLE groups ADD column group_name_tokens tsvector; 我们选择方案2，出于以下考虑：\n方案1，建立索引更简单一些，占用磁盘空间更小，因为 tsvector 并没有显式存储，但是每次查询都需要重新执行计算 to_tsvector 值，速度较慢;\n方案2，利用索引查询时，无需指定全文索引的配置（全文索引有一些跟 Locale 相关的配置），另外，由于在验证索引匹配时，无需重新计算 to_tsvector 值，所以查询速度更快。\n在群聊业务场景下，考虑到群的数量可控，所以占用空间不会增加太多，同时用户对于搜索速度的体验要求更高，所以采用了方案2。\n如果要对搜索结果按照相似度排序呢？\nsimilarity 这个是在 pg_trgm 扩展中包含的函数，其对中文分词支持不佳，所以业务中不采用。\n最小编辑距离 最小编辑距离，需要使用到 PostgreSQL 的扩展：\nCREATE EXTENSION fuzzystrmatch;---依赖该扩展为搜索结果排序 levenshtein 函数的一些相关 API：\nlevenshtein(text source, text target, int ins_cost, int del_cost, int sub_cost) returns int levenshtein(text source, text target) returns int levenshtein_less_equal(text source, text target, int ins_cost, int del_cost, int sub_cost, int max_d) returns int levenshtein_less_equal(text source, text target, int max_d) returns int 官方文档对 source 和 target 参数给出限制：不能超过 255 字节（由于群名称有长度限制，故适合我们的业务使用场景）。\ncost 参数分别指定了对于一个字符的插入、删除和代替的代价，个人理解，一定程度上就是字符串的这三种改变带来的权重。\n分别举几个例子就明白了：\n插入\nGUMBO 和 GUMBOL，后者相比前者，等价于插入了一个 L 字符。所以，影响最终结果的，只有 ins_cost 参数。\n--- 设置为 0，表示插入新字符带来的代价不影响 lixuehan=# SELECT levenshtein(\u0026#39;GUMBO\u0026#39;, \u0026#39;GUMBOL\u0026#39;,0,1,1); levenshtein ------------- 0 (1 row) --- 设置为 1，表示插入新字符带来的代价为 1 lixuehan=# SELECT levenshtein(\u0026#39;GUMBO\u0026#39;, \u0026#39;GUMBOL\u0026#39;,1,1,1); levenshtein ------------- 1 (1 row) 删除\nGUMBO 和 GUMO，后者相比前者，等价于删除了一个 B 字符。所以，影响最终比较结果的只有 del_cost 参数。\n--- 设置为 0，表示插入新字符带来的代价不影响 lixuehan=# SELECT levenshtein(\u0026#39;GUMBO\u0026#39;, \u0026#39;GUMO\u0026#39;,1,0,1); levenshtein ------------- 0 (1 row) --- 设置为 1，表示插入新字符带来的代价为 1 lixuehan=# SELECT levenshtein(\u0026#39;GUMBO\u0026#39;, \u0026#39;GUMO\u0026#39;,1,1,1); levenshtein ------------- 1 (1 row) 代替\nGUMBO 和 GUMLO，后者相比前者，等价于将 B 字符替换为 L 字符。所以，影响最终比较结果的只有 sub_cost 参数。\n--- 设置为 0，表示插入新字符带来的代价不影响 lixuehan=# SELECT levenshtein(\u0026#39;GUMBO\u0026#39;, \u0026#39;GUMLO\u0026#39;,1,1,0); levenshtein ------------- 0 (1 row) --- 设置为 1，表示插入新字符带来的代价为 1 lixuehan=# SELECT levenshtein(\u0026#39;GUMBO\u0026#39;, \u0026#39;GUMLO\u0026#39;,1,1,1); levenshtein ------------- 1 (1 row) 在实际的使用中，我们可以通过确定字符串这三种不同改变带来的权重来影响实际的比较结果。\nlevenshtein_less_equal 函数是一个加速版的 levenshtein。如果 levenshtein 距离大于 max_id ，则返回 levenshtein 距离值，反之，则返回 max_id+1。\n--- levenshtein 距离 --- lixuehan=# select levenshtein(\u0026#39;extensive\u0026#39;, \u0026#39;exhaustive\u0026#39;); levenshtein ------------- 4 (1 row) --- max_id 为 2，时返回 3 --- lixuehan=# SELECT levenshtein_less_equal(\u0026#39;extensive\u0026#39;, \u0026#39;exhaustive\u0026#39;,2); levenshtein_less_equal ------------------------ 3 (1 row) --- max_id 为 1，时返回 2 --- lixuehan=# SELECT levenshtein_less_equal(\u0026#39;extensive\u0026#39;, \u0026#39;exhaustive\u0026#39;,1); levenshtein_less_equal ------------------------ 2 (1 row) --- max_id 大于 levenshtein 值时，返回真正的 levenshtein 距离 --- lixuehan=# SELECT levenshtein_less_equal(\u0026#39;extensive\u0026#39;, \u0026#39;exhaustive\u0026#39;,7); levenshtein_less_equal ------------------------ 4 (1 row) 在我们的群搜索业务场景中，采取了简单的第二种 api ：\nlevenshtein(text source, text target) returns int 这种情况下，三种case带来的影响都默认是 1.\n更多介绍参见 官方文档。\n使用方式比较直观：\nSELECT id,levenshtein(name,?) AS distance FROM groups WHERE group_name_tokens @@ to_tsquery(\u0026#39;探探\u0026#39;) ORDER BY distance ASC 上线优化效果 利用分词+倒排的方案，实现了搜索功能与 PostgreSQL 的 Locale_Ctype 彻底解耦，同时提供了相似度排名特性，同时加快了搜索的速度，提升了性能，下面两张图就是上线前后的对比：\n上线前后对比\n优化上线前，搜索查询最长耗时 22.2ms，最短耗时 440us，平均耗时：6.6ms。\n优化上线后，最短耗时：456us，最长耗时：14ms，平均耗时：1.7ms。\n与之前的 Like 查询相比，最长耗时比原来少了 2ms，平均耗时缩短为原来的 1/4，提升效果显著。\n最后 下面是在实现需求时的一些参考链接，有兴趣可以点击链接详读，文章中有错误之处，恳请大家批评指针。\nhttps://github.com/digoal/blog/blob/master/201704/20170426_01.md https://www.postgresql.org/docs/13/locale.html http://pigsty.cc/zh/blog/2021/03/05/pg中的本地化排序规则/ Indexes in PostgreSQL https://postgrespro.com/blog/pgsql/4261647 ","permalink":"http://localhost:1313/posts/pg/","summary":"\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\n\u003cp\u003e2021年年初，探探上线了群聊功能，并且支持按照群名进行模糊搜索。\u003c/p\u003e\n\u003cp\u003e对于复杂场景的搜索，业界一般使用非常流行的 ElasticSearch。由于我们的群数据较少，截止到目前还没有达到千万级的量级，且搜索场景比较简单，而 PostgreSQL 对全文搜索又支持得比较好，所以选择了 PostgreSQL 来实现群搜索需求。\n在使用 PostgreSQL 做群搜索的过程中，也经历了由简单到复杂的迭代过程，中间也踩了不少坑。 下面的几个例子说明了方案的演进过程和我们的优化思路，希望能够对大家有所帮助。\u003c/p\u003e\n\u003ch2 id=\"like-模糊查询\"\u003eLIKE 模糊查询\u003c/h2\u003e\n\u003cp\u003e提到模糊搜索，最简单的办法就是对搜索列进行 like 匹配： 在输入词的前后加上 \u003ccode\u003e%\u003c/code\u003e 即可,如下所示:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eSELECT * FROM groups WHERE name LIKE \u0026#39;%探探%\u0026#39;;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这种方案可行是可行了，但是实现过于简单粗暴。对此方案进行测试：\u003c/p\u003e\n\u003cp\u003e建一张简单的表进行测试，表结构如下：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003elixuehan=# \\d groups;\n                                   Table \u0026#34;public.groups\u0026#34;\n Column |         Type          | Collation | Nullable |              Default\n--------+-----------------------+-----------+----------+------------------------------------\n id     | bigint                |           | not null | nextval(\u0026#39;groups_id_seq\u0026#39;::regclass)\n name   | character varying(50) |           |          |\nIndexes:\n    \u0026#34;groups_pkey\u0026#34; PRIMARY KEY, btree (id)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e表中只有两列：主键 \u003ccode\u003eid\u003c/code\u003e 以及群名 \u003ccode\u003ename\u003c/code\u003e。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ecreate or replace function gen_hanzi(int) returns text as $$\ndeclare\n    res text;\nbegin\n    if $1 \u0026gt;=1 then\n        select string_agg(chr(19968+(random()*20901)::int), \u0026#39;\u0026#39;) into res from generate_series(1,$1);\n        return res;\n    end if;\n    return null;\nend;\n$$ language plpgsql strict;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003egen_hanzi\u003c/code\u003e 是一个随机生成汉字的函数，我们使用一个该函数构造 100w 条数据，插入到该表中。\u003c/p\u003e","title":"基于 PostgreSQL 的群聊搜索实践"},{"content":"Intro We\u0026rsquo;ll be using yml/yaml format for all examples down below, I recommend using yml over toml as it is easier to read.\nYou can find any YML to TOML converters if necessary.\nOverride theme template By Hugo\u0026rsquo;s Lookup Order, you can override any part of a theme that you want. The following is a quick example.\nLet\u0026rsquo;s say you wish the list was different. All you have to do is copy the list template:\nyour-site/themes/papermod/layouts/_defaults/list.html And paste it under your own layouts folder:\nyour-site/layouts/_defaults/list.html Then you\u0026rsquo;re free to make any changes you want to the list. When Hugo builds your site, your copy of list.html will be used instead of the theme\u0026rsquo;s list.html.\nEnable Social-Metadata and SEO These include OpenGraph, Twitter Cards and Schema.\nparams: env: production or set HUGO_ENV as \u0026ldquo;production\u0026rdquo; in system env-vars\nFailed to find a valid digest in the \u0026lsquo;integrity\u0026rsquo; attribute for resource \u0026hellip; ? Read about How Subresource Integrity helps: Subresource_Integrity\nWhy was the asset not loading ? : How_browsers_handle_Subresource_Integrity\nSolution:\nSet the following in config.yml\nparams: assets: disableFingerprinting: true Linked Issues:\nhttps://stackoverflow.com/questions/65056585/hugo-theme-not-loading https://stackoverflow.com/questions/65040931/hugo-failed-to-find-a-valid-digest-in-the-integrity-attribute-for-resource https://blog.gerardbeckerleg.com/posts/hugo-failed-to-find-a-valid-digest-in-the-integrity-attribute-for-resource/ Bundling Custom css with theme\u0026rsquo;s assets For adding custom css to be bundled inside one minimized css Create folder in yout project directory as\n.(site root) ├── config.yml ├── content/ ├── theme/hugo-PaperMod/ └── assets/ └── css/ └── extended/ \u0026lt;--- ├── custom_css1.css \u0026lt;--- └── any_name.css \u0026lt;--- All css files inside assets/css/extended will be bundled !\nNote: blank.css is just the placeholder so that it doesn\u0026rsquo;t break the theme when no files are present under assets/css/extended\nLinked Issues:\nPapermod Theme: How to add custom CSS? Custom Head / Footer Custom css/js can be added by way mentioned below.\n.(site root) ├── config.yml ├── content/ ├── theme/hugo-PaperMod/ └── layouts ├── partials │ ├── comments.html │ ├── extend_footer.html \u0026lt;--- │ └── extend_head.html \u0026lt;--- └── robots.txt Create a html page in directory structure as shown above.\nContents of extend_head.html will be added to head of page.\nand contents of extend_footer.html will be added to bottom of page.\nAdd menu to site You can add menu entries which will appear in the header of every page.\nTo do so, add a menu section to your site\u0026rsquo;s config.yml:\nmenu: main: - identifier: categories name: categories url: /categories/ weight: 10 - identifier: tags name: tags url: /tags/ weight: 20 - identifier: example name: example.org url: https://example.org weight: 30 name controls what will be displayed for the menu entry. url sets the URL that the entry points to. weight is used to control the positioning of entries.\nFor more information on menus, see the Hugo wiki page.\nPin a Post Post can be pinned/ displayed top on the list by adding a weight=\u0026lt;num\u0026gt; var to page-variables\nexample:\n--- title: \u0026#34;My Important post\u0026#34; date: 2020-09-15T11:30:03+00:00 weight: 1 --- --- title: \u0026#34;My 2nd Important post\u0026#34; date: 2020-09-15T11:30:03+00:00 weight: 2 --- Adding Custom Favicon(s) We support the following paths under /static directory and can be added accordingly.\nfavicon.ico favicon-16x16.png favicon-32x32.png apple-touch-icon.png safari-pinned-tab.svg Favicon(s) can be generated by Favicon.io\nand can be simply put in /static folder.\nOther way is to add favicon(s) NOT located in /static folder.\nIn site config add the following:\nparams: assets: favicon: \u0026#34;\u0026lt;link / absolute url\u0026gt;\u0026#34; favicon16x16: \u0026#34;\u0026lt;link / absolute url\u0026gt;\u0026#34; favicon32x32: \u0026#34;\u0026lt;link / absolute url\u0026gt;\u0026#34; apple_touch_icon: \u0026#34;\u0026lt;link / absolute url\u0026gt;\u0026#34; safari_pinned_tab: \u0026#34;\u0026lt;link / absolute url\u0026gt;\u0026#34; absolute url means direct links to external resource: ex. https://web.site/someimage.png example:\nparams: assets: favicon: \u0026#34;/favicon.ico\u0026#34; favicon16x16: \u0026#34;/favicon-16x16.png\u0026#34; favicon32x32: \u0026#34;/favicon-32x32.png\u0026#34; apple_touch_icon: \u0026#34;/apple-touch-icon.png\u0026#34; safari_pinned_tab: \u0026#34;/safari-pinned-tab.svg\u0026#34; Centering image in markdown Add #center after image to center align an image\n![name](path/to/image.png#center) When using figure shortcode\nuse align=center to center image with captions\nex.\n{{\u0026lt; figure align=center src=\u0026#34;image.jpg\u0026#34; \u0026gt;}} Using Hugo\u0026rsquo;s Syntax highlighter \u0026ldquo;chroma\u0026rdquo; Set hugo\u0026rsquo;s markdown styling in site config.yml\nmarkup: highlight: noClasses: false noClasses has to be false to make highlight color follows the theme.\nSearch not working ? If you are using a CDN to server assets from a different domain, search would break\nWhy? Take a look at fastsearch.js#L35.\nWe fetch the index.json (where the search function looks for the keywords typed) one level up of the website search.min.js is hosted on.\nWe have used this insted of assigning baseURL so as to work with multilingual websites ex. example.com/fr/ and websites being placed under a subdirectory ex. example.com/blog/.\nTo fix for single language websites hosting assets from CDN, this you may override fastsearch.js#L35 and placing appropriate URL as in\nxhr.open(\u0026#34;GET\u0026#34;, \u0026#34;https://example.com/index.json\u0026#34;); References Override a Hugo theme ","permalink":"http://localhost:1313/docs/faq/","summary":"Frequently Asked Questions","title":"FAQs"},{"content":"Social Icons Go to Icons Preview to see a complete list of icons\nUsage :\nsocialIcons: - name: \u0026#34;kofi\u0026#34; url: \u0026#34;https://kofi.com\u0026#34; - name: \u0026#34;twitter\u0026#34; url: \u0026#34;https://twitter.com\u0026#34; Share Icons No. Platform 1 twitter (also generates hash tags from tags linked with post) 2 linkedin 3 reddit 4 facebook 5 whatsapp 6 telegram Usage:\nparams: ShowShareButtons: true ","permalink":"http://localhost:1313/docs/icons/","summary":"Explain how to use icons in PaperModX","title":"Icons"},{"content":"Intro We\u0026rsquo;ll be using yml/yaml format for all examples down below, I recommend using yml over toml as it is easier to read. You can find any YML to TOML converters if necessary. Guide Follow Quick Start guide to setup hugo and create a new site.\nNote: Use -f to select yml format\nhugo new site \u0026lt;name of site\u0026gt; -f yml\nMake sure you install latest version of hugo(\u0026gt;=0.83.0).\nAfter you have created a new site, at Step 3 follow the steps:\nMethod 1 Inside the folder of your Hugo site, run:\ngit clone https://github.com/reorx/hugo-PaperModX themes/PaperModX --depth=1 Note: You may use --branch v5.0 to end of above command if you want to stick to specific release.\nUpdating theme :\ncd themes/PaperModX git pull Method 2 You can use as submodule with\ngit submodule add https://github.com/reorx/hugo-PaperModX.git themes/PaperModX --depth=1 git submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) Note: You may use --branch v5.0 to end of above command if you want to stick to specific release.\nUpdating theme :\ngit submodule update --remote --merge Method 3 Or you can Download as Zip from Github Page and extract in your themes directory\nDirect Links:\nMaster Branch (Latest) v5.0 v4.0 v3.0 v2.0 v1.0 Finally \u0026hellip; Add in config.yml:\ntheme: \u0026#34;PaperModX\u0026#34; Method 4 Install Go programming language in your operating system.\nIntialize your own hugo mod\nhugo mod init YOUR_OWN_GIT_REPOSITORY Add PaperModX in your config.yml file module: imports: - path: github.com/reorx/hugo-PaperModX Update theme hugo mod get -u Quick Links Papermod - Features Papermod - FAQs Papermod - Variables Papermod - Icons ChangeLog Sample config.yml Example Site Structure is present here: exampleSite\nUse appropriately\nbaseURL: \u0026#34;https://examplesite.com/\u0026#34; title: ExampleSite paginate: 5 theme: PaperModX enableRobotsTXT: true buildDrafts: false buildFuture: false buildExpired: false pygmentsUseClasses: true googleAnalytics: UA-123-45 minify: disableXML: true minifyOutput: true params: env: production # to enable google analytics, opengraph, twitter-cards and schema. title: ExampleSite description: \u0026#34;ExampleSite description\u0026#34; keywords: [Blog, Portfolio, PaperModX] author: Me # author: [\u0026#34;Me\u0026#34;, \u0026#34;You\u0026#34;] # multiple authors images: [\u0026#34;\u0026lt;link or path of image for opengraph, twitter-cards\u0026gt;\u0026#34;] DateFormat: \u0026#34;January 2, 2006\u0026#34; defaultTheme: auto # dark, light disableThemeToggle: false ShowReadingTime: true ShowShareButtons: true ShowPostNavLinks: true ShowBreadCrumbs: true ShowCodeCopyButtons: false disableSpecial1stPost: false disableScrollToTop: false comments: false hidemeta: false hideSummary: false showtoc: false tocopen: false assets: # disableFingerprinting: true favicon: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; favicon16x16: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; favicon32x32: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; apple_touch_icon: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; safari_pinned_tab: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; label: text: \u0026#34;Home\u0026#34; icon: /apple-touch-icon.png iconHeight: 35 # profile-mode profileMode: enabled: false # needs to be explicitly set title: ExampleSite subtitle: \u0026#34;This is subtitle\u0026#34; imageUrl: \u0026#34;\u0026lt;img location\u0026gt;\u0026#34; imageWidth: 120 imageHeight: 120 imageTitle: my image buttons: - name: Posts url: posts - name: Tags url: tags # home-info mode homeInfoParams: Title: \u0026#34;Hi there \\U0001F44B\u0026#34; Content: Welcome to my blog socialIcons: - name: twitter url: \u0026#34;https://twitter.com/\u0026#34; - name: stackoverflow url: \u0026#34;https://stackoverflow.com\u0026#34; - name: github url: \u0026#34;https://github.com/\u0026#34; analytics: google: SiteVerificationTag: \u0026#34;XYZabc\u0026#34; bing: SiteVerificationTag: \u0026#34;XYZabc\u0026#34; yandex: SiteVerificationTag: \u0026#34;XYZabc\u0026#34; cover: hidden: true # hide everywhere but not in structured data hiddenInList: true # hide on list pages and home hiddenInSingle: true # hide on single page editPost: URL: \u0026#34;https://github.com/\u0026lt;path_to_repo\u0026gt;/content\u0026#34; Text: \u0026#34;Suggest Changes\u0026#34; # edit text appendFilePath: true # to append file path to Edit link # for search # https://fusejs.io/api/options.html fuseOpts: isCaseSensitive: false shouldSort: true location: 0 distance: 1000 threshold: 0.4 minMatchCharLength: 0 keys: [\u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;content\u0026#34;] menu: main: - identifier: categories name: categories url: /categories/ weight: 10 - identifier: tags name: tags url: /tags/ weight: 20 - identifier: example name: example.org url: https://example.org weight: 30 # Read: https://github.com/reorx/hugo-PaperModX/wiki/FAQs#using-hugos-syntax-highlighter-chroma # pygmentsUseClasses: true # markup: # highlight: # # anchorLineNos: true # codeFences: true # guessSyntax: true # lineNos: true # style: monokai Sample Page.md --- title: \u0026#34;My 1st post\u0026#34; date: 2020-09-15T11:30:03+00:00 # weight: 1 # aliases: [\u0026#34;/first\u0026#34;] tags: [\u0026#34;first\u0026#34;] author: \u0026#34;Me\u0026#34; # author: [\u0026#34;Me\u0026#34;, \u0026#34;You\u0026#34;] # multiple authors showToc: true TocOpen: false draft: false hidemeta: false comments: false description: \u0026#34;Desc Text.\u0026#34; canonicalURL: \u0026#34;https://canonical.url/to/page\u0026#34; disableShare: false hideSummary: false searchHidden: true ShowReadingTime: true ShowBreadCrumbs: true ShowPostNavLinks: true cover: image: \u0026#34;\u0026lt;image path/url\u0026gt;\u0026#34; # image path/url alt: \u0026#34;\u0026lt;alt text\u0026gt;\u0026#34; # alt text caption: \u0026#34;\u0026lt;text\u0026gt;\u0026#34; # display caption under cover relative: false # when using page bundles set this to true hidden: true # only hide on current single page editPost: URL: \u0026#34;https://github.com/\u0026lt;path_to_repo\u0026gt;/content\u0026#34; Text: \u0026#34;Suggest Changes\u0026#34; # edit text appendFilePath: true # to append file path to Edit link --- You can use it by creating archetypes/post.md\nhugo new --kind post \u0026lt;name\u0026gt; ","permalink":"http://localhost:1313/docs/installation/","summary":"Read Install and Update instructions here","title":"Installation | Update"},{"content":" source: https://adityatelange.github.io/hugo-PaperMod/posts/papermod/papermod-features/\nIntro We\u0026rsquo;ll be using yml/yaml format for all examples down below, I recommend using yml over toml as it is easier to read.\nYou can find any YML to TOML converters if necessary.\nAssets (js/css) The following is enabled by default\nminification - makes the assets size smallest as possible. bundling - bundles all the styles in one single asset fingerprint/integrity check. Default Theme light/dark/auto params: # defaultTheme: light # defaultTheme: dark defaultTheme: auto # to switch between dark or light according to browser theme Theme Switch Toggle (enabled by default) Shows icon besides title of page to change theme\nTo disable it :\ndisableThemeToggle: true You can refer following table for better understanding\u0026hellip;\ndefaultTheme disableThemeToggle checks local storage? checks system theme? Info auto true No Yes only system theme false Yes (if not-\u0026gt;2) Yes (2) switch present dark true No No force dark only false Yes No switch present light true No No force light only false Yes No switch present Archives Layout Create a page with archive.md in content directory with following content\n. ├── config.yml ├── content/ │ ├── archives.md \u0026lt;--- Create archive.md here │ └── posts/ ├── static/ └── themes/ └── PaperModX/ and add the following to it\n--- title: \u0026#34;Archive\u0026#34; layout: \u0026#34;archives\u0026#34; url: \u0026#34;/archives/\u0026#34; summary: archives --- Note: Archives Layout does not support Multilingual Month Translations.\nRegular Mode (default-mode) Home-Info Mode Use 1st entry as some Information\nadd following to config file\nparams: homeInfoParams: Title: Hi there wave Content: Can be Info, links, about... socialIcons: # optional - name: \u0026#34;\u0026lt;platform\u0026gt;\u0026#34; url: \u0026#34;\u0026lt;link\u0026gt;\u0026#34; - name: \u0026#34;\u0026lt;platform 2\u0026gt;\u0026#34; url: \u0026#34;\u0026lt;link2\u0026gt;\u0026#34; Profile Mode Shows Index/Home page as Full Page with Social Links and Image\nadd following to config file\nparams: profileMode: enabled: true title: \u0026#34;\u0026lt;Title\u0026gt;\u0026#34; # optional default will be site title subtitle: \u0026#34;This is subtitle\u0026#34; imageUrl: \u0026#34;\u0026lt;image link\u0026gt;\u0026#34; # optional imageTitle: \u0026#34;\u0026lt;title of image as alt\u0026gt;\u0026#34; # optional imageWidth: 120 # custom size imageHeight: 120 # custom size buttons: - name: Archive url: \u0026#34;/archive\u0026#34; - name: Github url: \u0026#34;https://github.com/\u0026#34; socialIcons: # optional - name: \u0026#34;\u0026lt;platform\u0026gt;\u0026#34; url: \u0026#34;\u0026lt;link\u0026gt;\u0026#34; - name: \u0026#34;\u0026lt;platform 2\u0026gt;\u0026#34; url: \u0026#34;\u0026lt;link2\u0026gt;\u0026#34; Search Page PaperModX uses Fuse.js Basic for seach functionality\nAdd the following to site config, config.yml\noutputs: home: - HTML - RSS - JSON # is necessary Create a page with search.md in content directory with following content\n--- title: \u0026#34;Search\u0026#34; # in any language you want layout: \u0026#34;search\u0026#34; # is necessary # url: \u0026#34;/archive\u0026#34; # description: \u0026#34;Description for Search\u0026#34; summary: \u0026#34;search\u0026#34; --- To hide a particular page from being searched, add it in post\u0026rsquo;s fron\u0026rsquo;t matter\n--- searchHidden: true Search Page also has Key bindings:\nArrow keys to move up/down the list Enter key (return) or Right Arrow key to Go to highlighted page Escape key to clear searchbox and results For Multilingual use search.\u0026lt;lang\u0026gt;.md ex. search.es.md.\nNote: Search will work only on current language, user is currently on !\nCustomizing Fusejs Options\nRefer https://fusejs.io/api/options.html for Options, Add those as shown below.\nparams: fuseOpts: isCaseSensitive: false shouldSort: true location: 0 distance: 1000 threshold: 0.4 minMatchCharLength: 0 keys: [\u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;content\u0026#34;] Draft Page indication adds [draft] mark to indicate draft pages.\nPost Cover Image In post\u0026rsquo;s page-variables add :\ncover: image: \u0026#34;\u0026lt;image path/url\u0026gt;\u0026#34; # can also paste direct link from external site # ex. https://i.ibb.co/K0HVPBd/paper-mod-profilemode.png alt: \u0026#34;\u0026lt;alt text\u0026gt;\u0026#34; caption: \u0026#34;\u0026lt;text\u0026gt;\u0026#34; relative: false # To use relative path for cover image, used in hugo Page-bundles When you include images in the Page Bundle, multiple sizes of the image will automatically be provided using the HTML5 srcset field.\nTo reduce generation time and size of the site, you can disable this feature using\nparams: cover: responsiveImages: false To enable hyperlinks to the full image size on post pages, use\nparams: cover: linkFullImages: true Share Buttons on post Displays Share Buttons at Bottom of each post\nto show share buttons add\nparams: ShowShareButtons: true Show post reading time Displays Reading Time (the estimated time, in minutes, it takes to read the content.)\nTo show reading time add\nParams: ShowReadingTime: true Show Table of Contents (Toc) on blog post Displays ToC on blog-pages\nTo show ToC add following to page-variables\nShowToc: true To keep Toc Open by default on a post add following to page-variables:\nTocOpen: true BreadCrumb Navigation Adds BreadCrumb Navigation above Post\u0026rsquo;s Title to show subsections and Navigation to Home\nparams: ShowBreadCrumbs: true Can be diabled for particular page\u0026rsquo;s front-matter\n--- ShowBreadCrumbs: false --- Edit Link for Posts Add a button to suggest changes by using the file path of the post to link to a edit destination.\nFor site config use:\nParams: editPost: URL: \u0026#34;https://github.com/\u0026lt;path_to_repo\u0026gt;/content\u0026#34; Text: \u0026#34;Suggest Changes\u0026#34; # edit text appendFilePath: true # to append file path to Edit link Can be modified for individual pages\n--- editPost: URL: \u0026#34;https://github.com/\u0026lt;path_to_repo\u0026gt;/content\u0026#34; Text: \u0026#34;Suggest Changes\u0026#34; # edit text appendFilePath: true # to append file path to Edit link --- The example above would yield the following link for the post file posts/post-name.md: https://github.com/\u0026lt;path_to_repo\u0026gt;/content/posts/post-name.md\nParameter Required Default Value editPost.URL true - editPost.appendFilePath false false editPost.Text false \u0026ldquo;Edit\u0026rdquo; Since the link generated is a regular HTML anchor tag \u0026lt;a href=...\u0026gt;, you can also use other URL schemas like mailto://, e.g. URL: \u0026quot;mailto://mail@example.com?subject=Suggesting changes for \u0026quot;\nOther Posts suggestion below a post Adds a Previous / Next post suggestion under a single post\nparams: ShowPostNavLinks: true Multiple Authors To Use multiple authors for a post, in post-variables:\n--- author: [\u0026#34;Me\u0026#34;, \u0026#34;You\u0026#34;] --- To use Multiple Authors Site-wide, in config.yml:\nparams: author: [\u0026#34;Me\u0026#34;, \u0026#34;You\u0026#34;] Comments to add comments, create a html file\nlayouts/partials/comments.html\nand paste code provided by your comments provider\nalso in config add this\nparams: comments: true read more about this hugo-comments\nAccessKeys c - ToC Open/Close g - Go To Top h - Home (according to current lang) t - Theme toggle / - Jumps to search page if in menu What\u0026rsquo;s AccessKeys ?\nEnhanced SEO Enabled only when env: production\nRich Results/Snippets Support Twitter Cards Support The Twitter Cards metadata, except twitter:image should not require additional configuration, since it is generated from metadata that you should already have (for instance the page title and description). The twitter:image uses the Post Cover Image, if present. In the absence of a cover images, the first image from the images frontmatter (a list) is used. images: - image_01.png - image_02.png Finally, if neither of those are provided, twitter:image comes from the first Page Bundle image with feature in the name, with a fallback to the first image with cover or thumbnail in the name. OpenGraph support The OpenGraph metadata, except og:image should not require additional configuration, since it is generated from metadata that you should already have (for instance the page title and description). The og:image uses the Post Cover Image, if present. In the absence of a cover images, the first image from the images frontmatter (a list) is used. images: - image_01.png - image_02.png Finally, if neither of those are provided, og:image comes from the first Page Bundle image with feature in the name, with a fallback to the first image with cover or thumbnail in the name. For pages, you can also add audio (using frontmatter audio: filename.ext) and/or videos. videos: - filename01.mov - filename02.avi Multilingual Support Misc Scroll-Bar themed (by default) Smooth Scroll between in-page links (by default) Scroll-to-Top Button (by default) Displays a Scroll-to-Top button in right-bottom corner Google Analytics integration Syntax highlighting RSS feeds ","permalink":"http://localhost:1313/docs/features/","summary":"Learn About All Features in original PaperMod","title":"PaperMod Features"},{"content":"Below are variables used with this theme\u0026hellip;\nSite Variables under Params name type example Description env string \u0026lsquo;production\u0026rsquo; To set env to production title string \u0026lsquo;My Blog\u0026rsquo; To set title description string \u0026lsquo;This is a blog of mine\u0026rsquo; To set site description author string |list \u0026lsquo;Me\u0026rsquo; | [\u0026lsquo;Me\u0026rsquo;,\u0026lsquo;You\u0026rsquo;] To show multiple Authors images string \u0026lsquo;myimage.png\u0026rsquo; Link or path of image for opengraph, twitter-cards keywords list [blog, page] Add keywords for Home page DateFormat string \u0026ldquo;January 2, 2006\u0026rdquo; The format of date strings in the website. Details languageAltTitle string \u0026ldquo;English\u0026rdquo; Alternate title in Multilingual Mode ShowReadingTime boolean true | false To show read time in post meta ShowShareButtons boolean true | false To show/hide share buttons under post ShowCodeCopyButtons boolean true | false To show/hide Code Copy button ShowFullTextinRSS boolean true | false To show Content in RSS feed defaultTheme string light | dark | auto To set default theme disableThemeToggle boolean true | false To disable theme toggle icon shown besides label disableSpecial1stPost boolean true | false To disable no-card special appearance of 1st post disableScrollToTop boolean true | false To disable ScrollToTop button disableAnchoredHeadings boolean true | false To disable Anchored Headings hideMeta boolean true | false To Hide meta elements : date, read-time, author and available-translations for page hideSummary boolean true | false To Hide summary being shown in list pages showtoc boolean true | false To show/hide Table of Contents tocopen boolean true | false To keep open ToC by default on page load ShowPostNavLinks boolean true | false Show Previous and Next Posts below a Post ShowBreadCrumbs boolean true | false Show BreadCrumb Navigation above single post/page comments boolean true | false To show/hide comments analytics.google.SiteVerificationTag string \u0026ldquo;XYZabc\u0026rdquo; Site Verification Tag for Google Analytics analytics.bing.SiteVerificationTag string \u0026ldquo;XYZabc\u0026rdquo; Site Verification Tag for Bing analytics.yandex.SiteVerificationTag string \u0026ldquo;XYZabc\u0026rdquo; Site Verification Tag for Yandex schema - - Details fuseOpts - - Details socialIcons - - Details label - - Details assets - - Details cover - - Details profileMode - - Details editPost - - Details Site Variables name type example Description copyright string **[example.site](https://example.site)** This is HUGO\u0026rsquo;s site variable, which can also render markdown content label name type example Description label.text string \u0026lsquo;Home\u0026rsquo; To display different label text other than title label.icon string \u0026lsquo;/apple-touch-icon.png\u0026rsquo; To display a logo image in label label.iconHeight integer 35 To set size of label logo image profileMode name type example Description profileMode.enabled boolean true | false For enabling profileMode, needs to be explicitly set profileMode.title string \u0026ldquo;Title\u0026rdquo; Title profileMode.subtitle string \u0026ldquo;subtitle here\u0026rdquo; Subtitle profileMode.imageUrl string \u0026ldquo;image.png\u0026rdquo; | \u0026ldquo;https://example.com/image.jpg\" Image URL or Link profileMode.imageWidth string \u0026ldquo;150\u0026rdquo; Width of image profileMode.imageHeight string \u0026ldquo;150\u0026rdquo; Height of image profileMode.imageTitle string \u0026ldquo;This image is a picture of ..\u0026rdquo; Title of image profileMode.buttons - - Details profileMode.buttons profileMode: buttons: - name: Archive url: \u0026#34;/archive\u0026#34; - name: Github url: \u0026#34;https://github.com/\u0026#34; assets name type example Description assets.favicon string \u0026lsquo;icon.ico\u0026rsquo; To set favicon, can be path or external link assets.disableFingerprinting boolean true | false To disable Sub-Resource integrity for assets cover name type example Description cover.linkFullImages boolean true | false To open full size cover images on click on cover cover.responsiveImages boolean true | false To enable/disable generation of responsive cover images cover.hidden boolean true | false To hide everywhere but not in structured data cover.hiddenInList boolean true | false To hide on list pages and home cover.hiddenInSingle boolean true | false To hide on list pages and home schema name type example Description schema.publisherType string \u0026lsquo;Organization\u0026rsquo; https://schema.org/publisher schema.sameAs list [\u0026ldquo;URL1\u0026rdquo;, \u0026ldquo;URL2\u0026rdquo;] Set https://schema.org/sameAs fuseOpts Refer: https://fusejs.io/api/options.html\nfuseOpts: isCaseSensitive: false shouldSort: true location: 0 distance: 1000 threshold: 0.4 minMatchCharLength: 0 keys: [\u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;content\u0026#34;] ## can be less but not more than shown in list socialIcons socialIcons: - name: \u0026#34;\u0026lt;platform\u0026gt;\u0026#34; url: \u0026#34;\u0026lt;link\u0026gt;\u0026#34; - name: \u0026#34;\u0026lt;platform 2\u0026gt;\u0026#34; url: \u0026#34;\u0026lt;link2\u0026gt;\u0026#34; editPost editPost: URL: \u0026#34;https://github.com/\u0026lt;path_to_repo\u0026gt;/content\u0026#34; Text: \u0026#34;Suggest Changes\u0026#34; # edit text appendFilePath: true # to append file path to Edit link Note: Same format is being used by Page Variables\nPage Variables Name Type Example Description showtoc boolean true | false To show/hide Table of Contents tocopen boolean true | false To keep open ToC by default on page load hidemeta boolean true | false To Hide meta elements : date, read-time, author and available-translations for page comments boolean true | false To show/hide comments description string \u0026lsquo;description text\u0026rsquo; Show Post Description under Title canonicalURL string \u0026ldquo;https://canonical.url/to/page\" To add canonical URL to posts disableShare boolean true | false To hide/show share icons under a page disableAnchoredHeadings boolean true | false To disable Anchored Headings searchHidden boolean true | false Hide page from search hideSummary boolean true | false To Hide summary being shown in list pages ShowReadingTime boolean true | false To show read time in post meta ShowBreadCrumbs boolean true | false Show BreadCrumb Navigation above single post/page ShowPostNavLinks boolean true | false Show Previous and Next Posts below a Post author string |list \u0026lsquo;Me\u0026rsquo; | [\u0026lsquo;Me\u0026rsquo;,\u0026lsquo;You\u0026rsquo;] To show multiple Authors cover.image string \u0026lsquo;featured.jpg\u0026rsquo; To add a cover image cover.caption string \u0026lsquo;caption for image\u0026rsquo; To add caption to cover image cover.alt string \u0026rsquo;this is cover image\u0026rsquo; Alternate text to show if image doesn\u0026rsquo;t load/show up cover.relative boolean true | false To use relative path for cover image, used in hugo Page-bundles cover.hidden boolean true | false To hide on current single page weight integer 5 To set page order or to pin a post to Top of list ","permalink":"http://localhost:1313/docs/variables/","summary":"List of Front Matter variables used by PaperModX","title":"Variables | Front Matter"},{"content":"最近在用 hugo 构建了个人博客之后，便有兴趣想研究下其源码。但是源码的体量之大，逻辑之复杂出乎我的意料。不过好在源码的结构比较清晰，有许多地方值得借鉴。\n比如它的程序入口，非常简洁：\nfunc main() { resp := commands.Execute(os.Args[1:]) if resp.Err != nil { if resp.IsUserError() { resp.Cmd.Println(\u0026#34;\u0026#34;) resp.Cmd.Println(resp.Cmd.UsageString()) } os.Exit(-1) } } 它将所有根据命令行参数传入的指令统一封装到 commands 包中。后面有新命令需求时，只需要新建一个 cmd 文件即可。\n它是怎么做到的呢？\n简而言之，就是在程序入口处将所有的命令类汇总，然后再根据输入参数args，决定要执行哪个cmd，看似增加了代码的复杂度，但是对于后续命令的扩展显得非常方便。\nhugo 中使用了 builder 模式将所有的命令汇总，我这里简单起见，只初始化了一个数组，主要是体会其开闭原则的思想即可。\nTalk is cheap, show me the code\n借鉴它的思路，我写了一个简化版，可以参看，代码链接.\n","permalink":"http://localhost:1313/posts/hugo_cmd_pattern/","summary":"\u003cp\u003e最近在用 hugo 构建了个人博客之后，便有兴趣想研究下其源码。但是源码的体量之大，逻辑之复杂出乎我的意料。不过好在源码的结构比较清晰，有许多地方值得借鉴。\u003c/p\u003e\n\u003cp\u003e比如它的程序入口，非常简洁：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Golang\" data-lang=\"Golang\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunc\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003eresp\u003c/span\u003e \u003cspan class=\"o\"\u003e:=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecommands\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eExecute\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003eos\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eArgs\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e:])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"nx\"\u003eresp\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eErr\u003c/span\u003e \u003cspan class=\"o\"\u003e!=\u003c/span\u003e \u003cspan class=\"kc\"\u003enil\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"nx\"\u003eresp\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eIsUserError\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"nx\"\u003eresp\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eCmd\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003ePrintln\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"nx\"\u003eresp\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eCmd\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003ePrintln\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003eresp\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eCmd\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eUsageString\u003c/span\u003e\u003cspan class=\"p\"\u003e())\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nx\"\u003eos\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eExit\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e它将所有根据命令行参数传入的指令统一封装到 \u003ccode\u003ecommands\u003c/code\u003e 包中。后面有新命令需求时，只需要新建一个 cmd 文件即可。\u003c/p\u003e\n\u003cp\u003e它是怎么做到的呢？\u003c/p\u003e\n\u003cp\u003e简而言之，就是在程序入口处将所有的命令类汇总，然后再根据输入参数\u003ccode\u003eargs\u003c/code\u003e，决定要执行哪个\u003ccode\u003ecmd\u003c/code\u003e，看似增加了代码的复杂度，但是对于后续命令的扩展显得非常方便。\u003c/p\u003e\n\u003cp\u003ehugo 中使用了 builder 模式将所有的命令汇总，我这里简单起见，只初始化了一个数组，主要是体会其开闭原则的思想即可。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eTalk is cheap, show me the code\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e借鉴它的思路，我写了一个简化版，可以参看，\u003ca href=\"https://github.com/anriclee/GoPatterns/tree/main/cmdpattern\"\u003e代码链接\u003c/a\u003e.\u003c/p\u003e","title":"Hugo 中的命令行模式"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates (extend_head.html) like so: refer ISSUE #236 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: \\(\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…\\) Block math:\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","permalink":"http://localhost:1313/docs/math-typesetting/","summary":"\u003cp\u003eMathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\u003c/p\u003e","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n.emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","permalink":"http://localhost:1313/docs/emoji-support/","summary":"\u003cp\u003eEmoji can be enabled in a Hugo project in a number of ways.\u003c/p\u003e","title":"Emoji Support"}]