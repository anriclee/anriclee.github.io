<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | ReadByWord</title>
<meta name=keywords content><meta name=description content="Posts - ReadByWord"><meta name=author content="anriclee"><link rel=canonical href=https://anriclee.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.min.7da7716a1f2d0725f74c6ae7f8d6adafc43aabe2b366b65bfbf433448e2a2001.css integrity="sha256-fadxah8tByX3TGrn+Natr8Q6q+KzZrZb+/QzRI4qIAE=" rel="preload stylesheet" as=style><link rel=icon href=https://anriclee.github.io/favicon.ico><link rel=apple-touch-icon href=https://anriclee.github.io/apple-touch-icon.png><link rel=alternate type=application/rss+xml href=https://anriclee.github.io/posts/index.xml><link rel=alternate hreflang=en href=https://anriclee.github.io/posts/><link rel=alternate hreflang=zh href=https://anriclee.github.io/zh/posts/><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts | ReadByWord"><meta name=twitter:description content="ReadbyWord - https://anriclee.github.io"><meta property="og:title" content="Posts | ReadByWord"><meta property="og:description" content="ReadbyWord - https://anriclee.github.io"><meta property="og:type" content="website"><meta property="og:url" content="https://anriclee.github.io/posts/"><meta property="og:image" content="https://anriclee.github.io/cover.png"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://anriclee.github.io/posts/"}]}</script><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list-page{background:var(--theme)}.list-page:not(.dark)::-webkit-scrollbar-track{background:0 0}.list-page:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body class="list-page type-posts kind-section layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="auto",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://anriclee.github.io/ accesskey=h title="ReadByWord (Alt + H)">ReadByWord</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://anriclee.github.io/docs/ title=Docs>Docs</a></li><li><a href=https://anriclee.github.io/tags/ title=Tags>Tags</a></li><li><a href=https://anriclee.github.io/archives/ title=Archive>Archive</a></li><li><a href=https://anriclee.github.io/search/ title="Search (Alt + /)" data-no-instant accesskey=/>Search</a></li><li><a href=https://anriclee.github.io/ title=@Author class=active target=_blank>@Author<span class=external-link><svg class="icon icon-tabler icon-tabler-external-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M11 7H6A2 2 0 004 9v9a2 2 0 002 2h9a2 2 0 002-2v-5"/><line x1="10" y1="14" x2="20" y2="4"/><polyline points="15 4 20 4 20 9"/></svg></span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://anriclee.github.io/>Home</a></div><h1>Posts</h1><div class=inline-links><span><a href=https://anriclee.github.io/posts/index.xml target=_blank>RSS</a></span></div></header><article class=post-entry><header class=entry-header><h2>英雄与时势</h2></header><section class=entry-content><p>最近恒大的暴雷，许家印的败落，一时间甚嚣尘上、沸沸扬扬。之前的时间，许家印还是一个英雄，而现在已经成为了狗熊。看了一些介绍许家印的视频，让我对时势和英雄的关系有了一些思考。
许家印借着国家发展的东风扶摇直上，凭借敢闯敢干，成为中国首富，又凭借敢闯和敢干，盘子闹得太大，一时无法调头，而致惨淡收场，真是成也萧何，败也萧何。
时势造英雄还是英雄造时势，这个问题一直争论不休。但是在我心里，有了初步的答案。
时势和英雄，脱离英雄谈时势与脱离时势谈英雄，都不太妥当。英雄不能超出其所处时代的局限，这就好比，诸葛亮不能想到计算机、曹操不能想到土地革命一样。英雄的思想和观念很大程度上受到当时的教育、观点的传播方式以及科学生产力的影响，他不可能 发明或者创造超越该时代生产力的东西。英雄诞生之后，在很大程度上可以改变一些历史的走向，反而又影响时势，比如没有希特勒这样的人物，二战的进程，可能会推迟很多，没有海森堡这样的科学家推波助澜，原子弹的产生，可能又要往后推迟好多年。
一句话：时势决定了英雄的上限，英雄决定了自己的下限。
三国演义开篇词就谈到了英雄。
浪花淘尽英雄
英雄只是大江中的几朵大浪而已。
在我看来，有些人，趁势而起而已，不能算作英雄，只能算作在时代的浪潮中的幸运儿而已。比如我们改革开放时期，借助双轨制的东风，趁势而起的一批人；有些人是随势而起，凭借一己之力，改变了一些东西的，这才可称之为英雄。
突发奇想，可以对三国期间的人杰按此分类，看看哪些人到底是乘势而起的幸运儿，哪些人乘势而起的英雄。我想一定会非常有趣。
PS：
年纪越大，就越对三国演义感兴趣。目光所及，唯有曹老板与刘备二人，曹老板真的是有人格魅力的人，刘老板的矢志不渝，亦颇为动人。在职场中，无论选中的是哪位老板，亦无所憾矣。</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2023-10-08</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://anriclee.github.io/tags/%E7%85%AE%E9%85%92%E9%97%B2%E8%81%8A/>煮酒闲聊</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select:text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z" style="user-select:text"/><polyline points="14 2 14 8 20 8" style="user-select:text"/><line x1="16" y1="13" x2="8" y2="13" style="user-select:text"/><line x1="16" y1="17" x2="8" y2="17" style="user-select:text"/><polyline points="10 9 9 9 8 9" style="user-select:text"/></svg>
<span>13 words</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>1 min</span></span></footer><a class=entry-link aria-label="post link to 英雄与时势" href=https://anriclee.github.io/posts/essays/sanguo/></a></article><article class=post-entry><header class=entry-header><h2>毛选与AI与风水学</h2></header><section class=entry-content><p>我们离AI越近，就离自己的判断越远。AI 到底会成为人类历史前进的助力还是阻力？这越来越成为在我脑中盘旋的问题。
AI 的发展，得益于世界上的少数精英对于算法的精进。然而，剩下的大多数，就沦为算法黑盒之外的芸芸众生了。
当下，开谈不说 AI，读尽诗书也枉然。资本鼓吹大行其道，什么代码会被 AI 代替，艺术会被 AI 代替，一时间，仿佛就差造物主会被 AI 代替了，然而，我们了解自己的痛点么？
我们以为 AI 可以代替我们做任何事情，实际上，却只能干一小部分事情，剩下的很多事情，AI 并不能替我们做出选择。一句话，因为算法并不是万能的。我们生活中有很多决策，并非是一个公式一个概率所能决定的。比如，婆媳关系，比如，中年危机。
我们总是倾向于用最省力的办法，解决最复杂的事情。
先问一下 AI。
AI 的回答不使我们满意，于是我们请教传统的 AI：风水与命理。
我们就是不愿意，自己去分析一下当下的处境，调查一下当下所面临的环境，搞清楚当下要解决的事情。
而这些分析问题的方法、模板以及结论，就在《毛选》中。
只是，我们从《毛选》中获取到的只是“渔”而非“鱼”。
在这个快节奏的时代，谁还需要“渔”？即使懂得了“渔”，又有多少时间去实践“渔”？
思考，是这个时代，最缺乏的东西。
系统思考，更是稀缺物品。</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2023-09-26</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://anriclee.github.io/tags/%E6%AF%9B%E9%80%89/>毛选</a><a href=https://anriclee.github.io/tags/%E7%85%AE%E9%85%92%E9%97%B2%E8%81%8A/>煮酒闲聊</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select:text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z" style="user-select:text"/><polyline points="14 2 14 8 20 8" style="user-select:text"/><line x1="16" y1="13" x2="8" y2="13" style="user-select:text"/><line x1="16" y1="17" x2="8" y2="17" style="user-select:text"/><polyline points="10 9 9 9 8 9" style="user-select:text"/></svg>
<span>28 words</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>1 min</span></span></footer><a class=entry-link aria-label="post link to 毛选与AI与风水学" href=https://anriclee.github.io/posts/essays/mao/></a></article><article class=post-entry><header class=entry-header><h2>乔布斯传</h2></header><section class=entry-content><p></p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2023-09-24</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select:text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z" style="user-select:text"/><polyline points="14 2 14 8 20 8" style="user-select:text"/><line x1="16" y1="13" x2="8" y2="13" style="user-select:text"/><line x1="16" y1="17" x2="8" y2="17" style="user-select:text"/><polyline points="10 9 9 9 8 9" style="user-select:text"/></svg>
<span>0 words</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>0 min</span></span></footer><a class=entry-link aria-label="post link to 乔布斯传" href=https://anriclee.github.io/posts/bookreading/jobs/></a></article><article class=post-entry><header class=entry-header><h2>关于技术知识点的战术和战略问题</h2></header><section class=entry-content><p>最近有计划做一个系列的技术分享，当然前提是自己需要了解很多东西，去查很多资料。
平时也看了很多技术分享视频，坦白说，能带给我收获和启发的寥寥。所以，国内的工程师（对，我希望大家都能称为工程师，而不是码农或者程序员）查资料，能看国外的就不会看国内的。
国内的技术，并不是一定落后于国外很多，但是为什么我们很难有高质量的技术文章出来呢？这可能和我们从小的教育模式有关。
国内的技术人做的分享，干货最多的，我推左耳朵耗子。前段时间听说他走了的消息，我还一度很悲伤。我的很多技术观念的转变，对于技术人的看法，都是从他的文章受到的启发。他的文章总能带给你不一样的启发，总是能够做到 干货满满。可惜，这么一位我认为纯粹的技术人，就这么走了。健康果然永远是第一位的。不知怎么，我总感觉从这几年开始，一切精致的、理想主义的好的东西，都逐渐在远离我们。
对于在探探的三年，我学到的技术方面比较硬核的东西不算多，但是，在这段经历中，我受到的一个最大的启发就是，如何去思考技术（这是一位96年的同事带给我的启发）。当今的技术新名词、概念、框架、编程语言等等，层出不穷， 大家都在感叹，要学的东西太多了，自己学不动了。
出现这种情况的原因，就在于我们永远是被动的接受知识。
出现一个新的东西，我们总在亦步亦趋地跟学，而很少去主动思考，为什么出现这个东西，这个东西的出现能够解决什么问题？比如最近 Java 21 版本发布，有一个史诗级的更新就是 Java 协程。我们如果不去想，Java 到底出现什么瓶颈 为什么要引入协程的概念，当时设计语言的时候为什么不考虑协程，或者为什么现在才引入，引入后对原来的语言架构有什么破坏性影响等等问题。这些问题没有考虑清楚，就一头扎到协程的实现细节中，我们必然会疲于奔命。
个人以为学一个新技术需要从以下步骤入手：
一、搞清楚解决的问题。
先把这个技术点的前世今生搞清楚，如果这个技术点的引入，只是为了炫技，只是为了蹭热点，那我宁可不学，吾生也有涯，要学的东西实在太多，我才没有必要为此浪费时间呢！而这一层分析，是好多技术文章或者技术视频里面 缺乏的。
二、如何解决
搞清楚要解决的现实痛点之后，接着就是要想如果是我们遇到了这个问题，我们该怎么办，它又是怎么做得？这一点可能比第一点更重要。思考这一点的好处多多。
首先，它能够帮你对这个技术点有个宏观的把握，之后研究这个技术点的时候，你永远有一个明确地导向，你不再会被里面天花乱坠的细节所误导和迷惑。 这就跟交朋友一样，你知道这个人所处的立场后，无论这个人怎么对你施加糖衣炮弹，你都不会为其所展现的表象所迷惑。你永远能够认清楚这个人的本质。用老毛的话来说，就是抓住事务的主要矛盾，透过现象看本质。
其次，如果我们冥思苦想也想不出更好的方案，然后看人家的实现，觉得既优雅，又简单，这个时候，你就会被它的设计所吸引。你的技术水平便会在无形中有所提高。下次你遇到类似的问题，或者别的问题时，你就会将此想法从此处迁移到彼处。 这就好比写文章一样，给到一个命题，我们自己写一篇，然后再看人家是怎么写的。二者一对比，高下立判。他和你实现的肯定有不同的地方，那么这些不同的地方，不外乎三种情形：
它不如你 这个时候一定不能傲慢，认为它这样做，就一定不如你。需要慎重考虑为什么这里出现一个表面看起来很明显的不太好的设计（这种情况，往往是因为一些历史原因或者有其特殊的需求背景）。
如果反复考虑之后，确实没有想出来更好的理由，那么你就可以理解你的设计比他的要高明（它的设计，并不一定都是最优方案，所谓战略上藐视，战术上重视），可以小小地得意一下。
你不如它 这个时候，你要暗自欣喜，因为你挖到矿了。这个技术点，没有白花时间研究。这就好比，你跟高手过招后，学到了几招新的武功，这是能够提升你的战力的。
殊途同归 你们的实现方案，各有利弊，各有其明显的缺点或者优点。
情形 2 和情形 3，都能在很大程度上拓宽你的视野，让你的技术品味升级。
最后，当前的技术点可能和你的工作没有太直接的关系（比如研究操作系统内核和写业务CRUD），但是里面的一些精髓的设计理念，其实完全可以迁移到业务中去（比如缓存、异步）。操作系统在有些时候，是追求极致的准确和性能的，这一点要求是比 99% 的业务高的。
三、总结和梳理
在前两步完成之后，基本上你对这个技术点，算是完全吃透了。这个时候别忘记及时梳理和总结，梳理过后的才会有条理的放在你的技能仓库中，不至遗忘或者记忆错乱。</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2023-09-24</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://anriclee.github.io/tags/%E7%85%AE%E9%85%92%E9%97%B2%E8%81%8A/>煮酒闲聊</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select:text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z" style="user-select:text"/><polyline points="14 2 14 8 20 8" style="user-select:text"/><line x1="16" y1="13" x2="8" y2="13" style="user-select:text"/><line x1="16" y1="17" x2="8" y2="17" style="user-select:text"/><polyline points="10 9 9 9 8 9" style="user-select:text"/></svg>
<span>42 words</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>1 min</span></span></footer><a class=entry-link aria-label="post link to 关于技术知识点的战术和战略问题" href=https://anriclee.github.io/posts/essays/tech/></a></article><article class=post-entry><header class=entry-header><h2>[译] 细谈依赖和配置</h2></header><section class=entry-content><p>依赖项的详细配置
正如前面所提到的那样，你可以定义 bean 的属性和构造函数参数，去引用其他已经设置好的 bean 或者内联定义的值。 为了达到这个目的，Spring 的基于 XML 配置元数据支持在 和 元素内增加子元素。
直接值（基本类型，字符串等等） 元素的 value 值，把一个属性值或者构造函数参数定义为一个可读字符串。Spring 的转换服务被用来将这些值从字符串转换为属性或者参数的实际类型。下面的例子展示了可以被设置的多种值：
&lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"> &lt;!-- results in a setDriverClassName(String) call --> &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/> &lt;property name="url" value="jdbc:mysql://localhost:3306/mydb"/> &lt;property name="username" value="root"/> &lt;property name="password" value="misterkaoli"/> &lt;/bean> 下面的例子使用 p-namespace 来让 XML 配置更加简明：
&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd"> &lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close" p:driverClassName="com.mysql.jdbc.Driver" p:url="jdbc:mysql://localhost:3306/mydb" p:username="root" p:password="misterkaoli"/> &lt;/beans> 上面的 XML 更加的简明。然而，类型是在运行时而不是设计时发现的，除非你在创建 bean 定义的时候，用支持自动属性完成的 IDE（例如 Intellij IDEA 或者 Eclipse 的 Spring 工具）。这些辅助都是高度推荐的。 你同样可以配置 java.util.Properties 的实例，如下：
...</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2023-09-11</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://anriclee.github.io/tags/spring/>Spring</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select:text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z" style="user-select:text"/><polyline points="14 2 14 8 20 8" style="user-select:text"/><line x1="16" y1="13" x2="8" y2="13" style="user-select:text"/><line x1="16" y1="17" x2="8" y2="17" style="user-select:text"/><polyline points="10 9 9 9 8 9" style="user-select:text"/></svg>
<span>653 words</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>4 min</span></span></footer><a class=entry-link aria-label="post link to [译] 细谈依赖和配置" href=https://anriclee.github.io/posts/spring_framework/core/the_ioc_container/dependencies/dependencies_configuration_in_detail/></a></article><article class=post-entry><header class=entry-header><h2>[译] 依赖注入</h2></header><section class=entry-content><p>在依赖注入（DI）里，对象通过构造函数参数、工厂方法参数或者在 被工厂方法创建返回的对象中设置的属性定义他们的依赖。然后，容器在创建这些 bean 时，注入依赖。这个过程与 bean 自身使用所需要类的直接构造函数实例化，或者通过 Service Locator 模式来找到所需要的依赖这个过程正好相反。
使用 DI 原则的代码更加干净整洁，并且提供给对象的依赖时，解耦也更加高效。对象并不找他们的依赖也并不知道这些依赖的地址或者类。这样的结果就是，你的类变得更易测试，尤其是当依赖是接口或者抽象的父类时，在单元测试可以对这些依赖进行打桩或者mock他们的实现。
基于构造函数的依赖注入 基于构造函数的依赖注入，是通过容器调用构造函数，并且传入若干参数来实现的，每一个参数都代表了一个依赖。调用静态工厂方法并传入特定的参数来构造一个 bean 也是一样的，在本讨论中，对待构造函数的参数和静态方法的参数也是相似的。下面的这里展示了一个之能通过构造函数来进行依赖注入的类：
public class SimpleMovieLister { // the SimpleMovieLister has a dependency on a MovieFinder private final MovieFinder movieFinder; // a constructor so that the Spring container can inject a MovieFinder public SimpleMovieLister(MovieFinder movieFinder) { this.movieFinder = movieFinder; } // business logic that actually uses the injected MovieFinder is omitted... } 注意，对于这个类没有更多特殊的地方。它仅仅是一个POJO，并且对容器特定接口、父类或者注解没有任何依赖。【译者按：没有任何代码侵入性】
...</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2023-09-11</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://anriclee.github.io/tags/spring/>Spring</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select:text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z" style="user-select:text"/><polyline points="14 2 14 8 20 8" style="user-select:text"/><line x1="16" y1="13" x2="8" y2="13" style="user-select:text"/><line x1="16" y1="17" x2="8" y2="17" style="user-select:text"/><polyline points="10 9 9 9 8 9" style="user-select:text"/></svg>
<span>768 words</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>4 min</span></span></footer><a class=entry-link aria-label="post link to [译] 依赖注入" href=https://anriclee.github.io/posts/spring_framework/core/the_ioc_container/dependencies/dependency_injection/></a></article><article class=post-entry><header class=entry-header><h2>中秋绝句</h2></header><section class=entry-content><p>中秋绝句
癸卯秋夜，虽炎热潮湿，开窗无月，然心情大好，咏志抒怀，无碍也，是为序。
自来霜雪映吴钩，半生浮云半生幽
未有三旬寂寞守，何能一夜照清秋</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2023-09-06</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select:text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z" style="user-select:text"/><polyline points="14 2 14 8 20 8" style="user-select:text"/><line x1="16" y1="13" x2="8" y2="13" style="user-select:text"/><line x1="16" y1="17" x2="8" y2="17" style="user-select:text"/><polyline points="10 9 9 9 8 9" style="user-select:text"/></svg>
<span>4 words</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>1 min</span></span></footer><a class=entry-link aria-label="post link to 中秋绝句" href=https://anriclee.github.io/posts/essays/poems/></a></article><article class=post-entry><header class=entry-header><h2>[译] Spring AOP 概念</h2></header><section class=entry-content><p>AOP 通过提供另外一种关于程序结构的思考方式补充了面向对象编程（OOP ）。在 OOP 中模块的关键单元是 class，而在 AOP 中，模块的关键是 Aspect（切面）。切面支持跨多个对象和类型的关注点模块化（比如事务的管理）。在 AOP 中这种关注点通常被叫做 “跨领域” 关注点。
Spring 的一个核心组件就是 AOP 框架。虽然 Spring IoC 容器并不依赖于 AOP（意思是如果不想用 AOP 可以不用），但是 AOP 对 Spring IoC 做了一个补充，提供了一种功能非常强大的中间件解决方案。
Spring AOP 和 切面切点
Spring 提供了简单而高效的方式来自定义切面，可以通过基于 schema 的方法也可以通过 @AspectJ 注解的风格。当使用 Spring AOP 来织入时，这两种风格都提供了充分类型的 advice 和 AspectJ 的切点语言。
这张主要讨论 schema 和 @Aspect 的 AOP 支持。AOP 底层的支持在下面的一章节会讨论到。
AOP 在 Spring 框架中的用途：
提供声明式的企业级服务。最重要的就是声明式事务管理 让用户实现自定义的切面作为他们用 AOP 实现 OOP 的补充。 Note：如果你对通用的声明式服务或者其他预先打包的声明式中间件服务感兴趣，你不用直接和 Spring AOP 直接打交道，可以跳过本章的大部分地方。
AOP 概念 让我们从一些核心的 AOP 概念和术语出发。这些术语并不只是 Spring 特有的。不幸地是，AOP 术语并不符合直觉。然而，如果 Spring 使用它自己的术语，或许会更加令人迷惑。
...</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2023-09-05</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select:text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z" style="user-select:text"/><polyline points="14 2 14 8 20 8" style="user-select:text"/><line x1="16" y1="13" x2="8" y2="13" style="user-select:text"/><line x1="16" y1="17" x2="8" y2="17" style="user-select:text"/><polyline points="10 9 9 9 8 9" style="user-select:text"/></svg>
<span>1369 words</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>7 min</span></span></footer><a class=entry-link aria-label="post link to [译] Spring AOP 概念" href=https://anriclee.github.io/posts/spring_framework/core/spring_aop/concept/></a></article><article class=post-entry><header class=entry-header><h2>[译] Bean 概述</h2></header><section class=entry-content><p>一个 Sring IoC 容器可以操作一个或者多个 bean。这些 bean 是通过你提供给容器的配置元数据生成的（例如，以 XML 中的 &lt;bean/> ）。
在容器内，这些 bean 的定义被表示成 BeanDefinition 对象的形式，包含了下面的元数据：
包定义的类名：通常是定义的 bean 的真正实现类 bean 行为配置元素，表明了 bean 在 container 中的行为（scope，生命周期回调等等）。 对其他需要的 bean 的引用。这些引用也被称作协作器和依赖。 在一个新创建的对象中的其他配置设置 - 例如，池的数量限制或者一个操作连接池 bean 中的连接数量 这些元数据转换为构成这些 bean 定义的一系列属性。下表表示了这些属性值：
属性 含义 Class 正在实例化的bean Name bean的名字 Scope Bean的Scope 构造函数参数 依赖注入 自动装配模式 装配的协作对象 懒加载模式 懒加载 Bean 初始化方法 初始化回调 析构方法 析构回调 除了包含怎么创建一个特定的 bean 的信息之外， ApplicationContext 的实现同样允许在容器外面已经创建好的对象注册到其中（用户创建）。这是通过 getBeanFactory 方法获取到 ApplicationContext 的 BeanFactory，得到 DefaultListableBeanFactory 实现来做到的。DefaultListableBeanFactory 支持通过调用 registerSingleton(..) 和 registerBeanDefinition(..) 方法来实现这样的注册。然而，典型的应用程序仅仅使用常规的 bean 定义元数据。
...</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2023-09-02</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://anriclee.github.io/tags/spring/>Spring</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select:text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z" style="user-select:text"/><polyline points="14 2 14 8 20 8" style="user-select:text"/><line x1="16" y1="13" x2="8" y2="13" style="user-select:text"/><line x1="16" y1="17" x2="8" y2="17" style="user-select:text"/><polyline points="10 9 9 9 8 9" style="user-select:text"/></svg>
<span>559 words</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>3 min</span></span></footer><a class=entry-link aria-label="post link to [译] Bean 概述" href=https://anriclee.github.io/posts/spring_framework/core/the_ioc_container/bean_overview/></a></article><article class=post-entry><header class=entry-header><h2>[译] Spring IOC 容器</h2></header><section class=entry-content><p>Spring IOC 和 bean 的简介 本章涵盖了 SpringFramework 中的控制反转原则（Ioc）的实现。IoC 也被称为依赖注入（DI）。它是这样的一种过程，在此期间对象仅通过构造函数参数、工厂方法的参数或者当对象实例被构造后或者通过工厂方法返回时在它上面设置的属性定义自己的依赖（即对象必须合作的其他对象）。
当容器创建这些 bean 后，再注入这些依赖。
这个过程本质上与bean 通过使用直接的类构造函数进行直接实例化或者通过类似 Service Locator模式来寻找依赖的位置是相反的（这也是 IoC 名字的由来）。
org.springframework.beans 和 org.springframework.context 包是 SpringFramework IoC 容器的基石。BeanFactory 接口提供了一种更先进的能够控制人已类型对象的配置机制。ApplicationContext 是 BeanFactory 的子接口。它增加了下面的特性：
与 Spring 的 AOP 特性更容易整合 消息资源处理（在国际化场景的使用） 事件发布 例如用于 Web 应用的 WebApplicationContext 应用层特定的上下文 总而言之，BeanFactory 提供了配置的框架和基本的功能。ApplicationContext 增加了更多的企业特定的功能。ApplicationContext 完全是 BeanFactory 的超集。在本章关于 Spring IoC 容器做专门描述时会用到。想要获取更多的关于使用 ApplicationContext 而非 BeanFactory 的信息，参见介绍 BeanFactory API 的部分。
在 Spring 中，作为你应用基石同时可以被 Spring IoC 容器所操控的对象就被称之为 bean。bean 就是被 Spring IoC 容器实例化、组装和设置的对象。否则，一个 bean 就是你应用程序中诸多对象中的一个。 Beans 以及他们依赖关系，反映在容器使用的配置元数据中。
...</p></section><footer class=entry-footer><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>2023-09-02</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://anriclee.github.io/tags/spring/>Spring</a></span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select:text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z" style="user-select:text"/><polyline points="14 2 14 8 20 8" style="user-select:text"/><line x1="16" y1="13" x2="8" y2="13" style="user-select:text"/><line x1="16" y1="17" x2="8" y2="17" style="user-select:text"/><polyline points="10 9 9 9 8 9" style="user-select:text"/></svg>
<span>72 words</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>1 min</span></span></footer><a class=entry-link aria-label="post link to [译] Spring IOC 容器" href=https://anriclee.github.io/posts/spring_framework/core/the_ioc_container/container_and_beans/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://anriclee.github.io/posts/page/2/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://anriclee.github.io/>ReadByWord</a></span><span style=display:inline-block;margin-left:1em>
<a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA</a>
</span><span style=display:inline-block;margin-left:1em>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n="1"=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script><script src=/js/instantclick.min.js data-no-instant></script><script data-no-instant>InstantClick.init()</script></body></html>