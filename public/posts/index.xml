<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on ReadTinyWords</title>
    <link>https://anriclee.github.io/posts/</link>
    <description>Recent content in Posts on ReadTinyWords</description>
    <generator>Hugo</generator>
    <language>en</language>
    <atom:link href="https://anriclee.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>The end of Silicon Valley</title>
      <link>https://anriclee.github.io/posts/essays/theendofsiliconvalley/</link>
      <pubDate>Sun, 20 Apr 2025 21:25:55 +0800</pubDate>
      <guid>https://anriclee.github.io/posts/essays/theendofsiliconvalley/</guid>
      <description>&lt;p&gt;Finally I have finihsed watching the entire HBO series &amp;ldquo;Silicon Valley&amp;rdquo; after having seen the first four seasons several years ago. Back then, I was more struck by the unique humor of coders - a distinct group in a unique phase of society. However, this time, the spirit of being a geek left a profound impression on me. In other words, I finally understood the essence of technology.&lt;/p&gt;&#xA;&lt;p&gt;The leading role, Richard, is not handsome, not is he a hero. On the contrary, he is selfish, awkwardly thin and sometimes a typical jerk. However, when I consider his position from another perspective, I cannot be certain that I would behave any better than him. Not to mention, he has a great programming talent. There were several moments when I realized that humanities exists in this coding spirit instead of those philosophical books in HISTORY.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Maybe English is more likely to make me think more</title>
      <link>https://anriclee.github.io/posts/essays/english_expression/</link>
      <pubDate>Thu, 10 Apr 2025 20:57:06 +0800</pubDate>
      <guid>https://anriclee.github.io/posts/essays/english_expression/</guid>
      <description>&lt;p&gt;Initially, due to issues with my Visual Studio Code IDE, I couldn&amp;rsquo;t type Chinese. I was forced to write my thoughts in English, which led to the birth of these English blog posts.&lt;/p&gt;&#xA;&lt;p&gt;As time went on, I discovered that using a language I&amp;rsquo;m less familiar with compelled me to express ideas more simply and organize my thoughts more carefully. Additionally, I noticed that the most readable technical books I&amp;rsquo;ve read were predominantly in English. Furthermore, LLMs seem to handle English queries more efficiently and effectively.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Some thoughts about tools ideas</title>
      <link>https://anriclee.github.io/posts/essays/some_thoughts/</link>
      <pubDate>Wed, 09 Apr 2025 22:05:24 +0800</pubDate>
      <guid>https://anriclee.github.io/posts/essays/some_thoughts/</guid>
      <description>&lt;p&gt;Not even a good shell tools found under windows for now. This leads me to think that if I can develop it in Rust or Golang.&lt;/p&gt;&#xA;&lt;p&gt;My demands are simple, a beautiful GUI , a tool for transfer files, uploading or downloading.&lt;/p&gt;&#xA;&lt;p&gt;Maybe I will try electron, but the size is so big, I am hesitating about it.&lt;/p&gt;&#xA;&lt;p&gt;And probably fyne.io or Wails are also alternatives I would choose.&lt;/p&gt;&#xA;&lt;p&gt;As I want to grasp Rust programming language, sometimes I want to develop one by Rust language either.&lt;/p&gt;</description>
    </item>
    <item>
      <title>A new Hugo theme switched on my blog</title>
      <link>https://anriclee.github.io/posts/essays/switchtheme/</link>
      <pubDate>Tue, 08 Apr 2025 22:43:34 +0800</pubDate>
      <guid>https://anriclee.github.io/posts/essays/switchtheme/</guid>
      <description>&lt;p&gt;This is probably my last time &lt;em&gt;switching to a theme made by others&lt;/em&gt;. That&amp;rsquo;s my commitment.&lt;/p&gt;&#xA;&lt;p&gt;Moving forward, I plan to create my own theme using my frontend knowledge and build it entirely from scratch.&lt;/p&gt;&#xA;&lt;p&gt;I have to admit that choosing a blog theme can be quite anxiety-inducing.&lt;/p&gt;&#xA;&lt;p&gt;From now on, I will focus on my first source code reading series about &lt;em&gt;Prometheus&lt;/em&gt;.&lt;/p&gt;&#xA;&lt;p&gt;I plan to share my understanding through a series of articles.&lt;/p&gt;</description>
    </item>
    <item>
      <title>The Silicon Valley</title>
      <link>https://anriclee.github.io/posts/essays/silicon_valley/</link>
      <pubDate>Mon, 07 Apr 2025 22:09:24 +0800</pubDate>
      <guid>https://anriclee.github.io/posts/essays/silicon_valley/</guid>
      <description>&lt;p&gt;It’s been years since I last wrote a blog—not even one in Chinese. I’d almost forgotten how to generate a new post with Hugo. So much has changed, and life’s pressures have piled up in ways words can hardly capture. Maybe that line from Friends rings true: &amp;ldquo;Life sucks, but you’re gonna love it.&amp;rdquo;&lt;/p&gt;&#xA;&lt;p&gt;The years have been a mix of highs and lows. There were moments when motivation vanished entirely, leaving me silent, unable to articulate even the simplest feelings.&lt;/p&gt;</description>
    </item>
    <item>
      <title>英雄与时势</title>
      <link>https://anriclee.github.io/posts/essays/sanguo/</link>
      <pubDate>Sun, 08 Oct 2023 21:17:00 +0800</pubDate>
      <guid>https://anriclee.github.io/posts/essays/sanguo/</guid>
      <description>&lt;p&gt;最近恒大的暴雷，许家印的败落，一时间甚嚣尘上、沸沸扬扬。之前的时间，许家印还是一个英雄，而现在已经成为了狗熊。看了一些介绍许家印的视频，让我对时势和英雄的关系有了一些思考。&lt;/p&gt;&#xA;&lt;p&gt;许家印借着国家发展的东风扶摇直上，凭借敢闯敢干，成为中国首富，又凭借敢闯和敢干，盘子闹得太大，一时无法调头，而致惨淡收场，真是成也萧何，败也萧何。&lt;/p&gt;&#xA;&lt;p&gt;时势造英雄还是英雄造时势，这个问题一直争论不休。但是在我心里，有了初步的答案。&lt;/p&gt;&#xA;&lt;p&gt;时势和英雄，脱离英雄谈时势与脱离时势谈英雄，都不太妥当。英雄不能超出其所处时代的局限，这就好比，诸葛亮不能想到计算机、曹操不能想到土地革命一样。英雄的思想和观念很大程度上受到当时的教育、观点的传播方式以及科学生产力的影响，他不可能&#xA;发明或者创造超越该时代生产力的东西。英雄诞生之后，在很大程度上可以改变一些历史的走向，反而又影响时势，比如没有希特勒这样的人物，二战的进程，可能会推迟很多，没有海森堡这样的科学家推波助澜，原子弹的产生，可能又要往后推迟好多年。&lt;/p&gt;&#xA;&lt;p&gt;一句话：&lt;strong&gt;时势决定了英雄的上限，英雄决定了自己的下限。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;三国演义开篇词就谈到了英雄。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;浪花淘尽英雄&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;英雄只是大江中的几朵大浪而已。&lt;/p&gt;&#xA;&lt;p&gt;在我看来，有些人，趁势而起而已，不能算作英雄，只能算作在时代的浪潮中的幸运儿而已。比如我们改革开放时期，借助双轨制的东风，趁势而起的一批人；有些人是随势而起，凭借一己之力，改变了一些东西的，这才可称之为英雄。&lt;/p&gt;&#xA;&lt;p&gt;突发奇想，可以对三国期间的人杰按此分类，看看哪些人到底是乘势而起的幸运儿，哪些人乘势而起的英雄。我想一定会非常有趣。&lt;/p&gt;&#xA;&lt;p&gt;PS：&lt;/p&gt;&#xA;&lt;p&gt;年纪越大，就越对三国演义感兴趣。目光所及，唯有曹老板与刘备二人，曹老板真的是有人格魅力的人，刘老板的矢志不渝，亦颇为动人。在职场中，无论选中的是哪位老板，亦无所憾矣。&lt;/p&gt;</description>
    </item>
    <item>
      <title>毛选与AI与风水学</title>
      <link>https://anriclee.github.io/posts/essays/mao/</link>
      <pubDate>Tue, 26 Sep 2023 22:38:32 +0800</pubDate>
      <guid>https://anriclee.github.io/posts/essays/mao/</guid>
      <description>&lt;p&gt;我们离AI越近，就离自己的判断越远。AI 到底会成为人类历史前进的助力还是阻力？这越来越成为在我脑中盘旋的问题。&lt;/p&gt;&#xA;&lt;p&gt;AI 的发展，得益于世界上的少数精英对于算法的精进。然而，剩下的大多数，就沦为算法黑盒之外的芸芸众生了。&lt;/p&gt;&#xA;&lt;p&gt;当下，开谈不说 AI，读尽诗书也枉然。资本鼓吹大行其道，什么代码会被 AI 代替，艺术会被 AI 代替，一时间，仿佛就差造物主会被 AI 代替了，然而，我们了解自己的痛点么？&lt;/p&gt;&#xA;&lt;p&gt;我们以为 AI 可以代替我们做任何事情，实际上，却只能干一小部分事情，剩下的很多事情，AI 并不能替我们做出选择。一句话，因为算法并不是万能的。我们生活中有很多决策，并非是一个公式一个概率所能决定的。比如，婆媳关系，比如，中年危机。&lt;/p&gt;&#xA;&lt;p&gt;我们总是倾向于用最省力的办法，解决最复杂的事情。&lt;/p&gt;&#xA;&lt;p&gt;先问一下 AI。&lt;/p&gt;&#xA;&lt;p&gt;AI 的回答不使我们满意，于是我们请教传统的 AI：风水与命理。&lt;/p&gt;&#xA;&lt;p&gt;我们就是不愿意，自己去分析一下当下的处境，调查一下当下所面临的环境，搞清楚当下要解决的事情。&lt;/p&gt;&#xA;&lt;p&gt;而这些分析问题的方法、模板以及结论，就在《毛选》中。&lt;/p&gt;&#xA;&lt;p&gt;只是，我们从《毛选》中获取到的只是“渔”而非“鱼”。&lt;/p&gt;&#xA;&lt;p&gt;在这个快节奏的时代，谁还需要“渔”？即使懂得了“渔”，又有多少时间去实践“渔”？&lt;/p&gt;&#xA;&lt;p&gt;思考，是这个时代，最缺乏的东西。&lt;/p&gt;&#xA;&lt;p&gt;系统思考，更是稀缺物品。&lt;/p&gt;</description>
    </item>
    <item>
      <title>乔布斯传</title>
      <link>https://anriclee.github.io/posts/bookreading/jobs/</link>
      <pubDate>Sun, 24 Sep 2023 10:55:41 +0800</pubDate>
      <guid>https://anriclee.github.io/posts/bookreading/jobs/</guid>
      <description></description>
    </item>
    <item>
      <title>关于技术知识点的战术和战略问题</title>
      <link>https://anriclee.github.io/posts/essays/tech/</link>
      <pubDate>Sun, 24 Sep 2023 10:07:48 +0800</pubDate>
      <guid>https://anriclee.github.io/posts/essays/tech/</guid>
      <description>&lt;p&gt;最近有计划做一个系列的技术分享，当然前提是自己需要了解很多东西，去查很多资料。&lt;/p&gt;&#xA;&lt;p&gt;平时也看了很多技术分享视频，坦白说，能带给我收获和启发的寥寥。所以，国内的工程师（对，我希望大家都能称为工程师，而不是码农或者程序员）查资料，能看国外的就不会看国内的。&lt;/p&gt;&#xA;&lt;p&gt;国内的技术，并不是一定落后于国外很多，但是为什么我们很难有高质量的技术文章出来呢？这可能和我们从小的教育模式有关。&lt;/p&gt;&#xA;&lt;p&gt;国内的技术人做的分享，干货最多的，我推左耳朵耗子。前段时间听说他走了的消息，我还一度很悲伤。我的很多技术观念的转变，对于技术人的看法，都是从他的文章受到的启发。他的文章总能带给你不一样的启发，总是能够做到&#xA;干货满满。可惜，这么一位我认为纯粹的技术人，就这么走了。健康果然永远是第一位的。不知怎么，我总感觉从这几年开始，一切精致的、理想主义的好的东西，都逐渐在远离我们。&lt;/p&gt;&#xA;&lt;p&gt;对于在探探的三年，我学到的技术方面比较硬核的东西不算多，但是，在这段经历中，我受到的一个最大的启发就是，如何去思考技术（这是一位96年的同事带给我的启发）。当今的技术新名词、概念、框架、编程语言等等，层出不穷，&#xA;大家都在感叹，要学的东西太多了，自己学不动了。&lt;/p&gt;&#xA;&lt;p&gt;出现这种情况的原因，就在于我们永远是被动的接受知识。&lt;/p&gt;&#xA;&lt;p&gt;出现一个新的东西，我们总在亦步亦趋地跟学，而很少去主动思考，为什么出现这个东西，这个东西的出现能够解决什么问题？比如最近 Java 21 版本发布，有一个史诗级的更新就是 Java 协程。我们如果不去想，Java 到底出现什么瓶颈&#xA;为什么要引入协程的概念，当时设计语言的时候为什么不考虑协程，或者为什么现在才引入，引入后对原来的语言架构有什么破坏性影响等等问题。这些问题没有考虑清楚，就一头扎到协程的实现细节中，我们必然会疲于奔命。&lt;/p&gt;&#xA;&lt;p&gt;个人以为学一个新技术需要从以下步骤入手：&lt;/p&gt;&#xA;&lt;p&gt;一、搞清楚解决的问题。&lt;/p&gt;&#xA;&lt;p&gt;先把这个技术点的前世今生搞清楚，如果这个技术点的引入，只是为了炫技，只是为了蹭热点，那我宁可不学，吾生也有涯，要学的东西实在太多，我才没有必要为此浪费时间呢！而这一层分析，是好多技术文章或者技术视频里面&#xA;缺乏的。&lt;/p&gt;&#xA;&lt;p&gt;二、如何解决&lt;/p&gt;&#xA;&lt;p&gt;搞清楚要解决的现实痛点之后，接着就是要想如果是我们遇到了这个问题，我们该怎么办，它又是怎么做得？这一点可能比第一点更重要。思考这一点的好处多多。&lt;/p&gt;&#xA;&lt;p&gt;首先，它能够帮你对这个技术点有个宏观的把握，之后研究这个技术点的时候，你永远有一个明确地导向，你不再会被里面天花乱坠的细节所误导和迷惑。&#xA;这就跟交朋友一样，你知道这个人所处的立场后，无论这个人怎么对你施加糖衣炮弹，你都不会为其所展现的表象所迷惑。你永远能够认清楚这个人的本质。用老毛的话来说，就是抓住事务的主要矛盾，透过现象看本质。&lt;/p&gt;&#xA;&lt;p&gt;其次，如果我们冥思苦想也想不出更好的方案，然后看人家的实现，觉得既优雅，又简单，这个时候，你就会被它的设计所吸引。你的技术水平便会在无形中有所提高。下次你遇到类似的问题，或者别的问题时，你就会将此想法从此处迁移到彼处。&#xA;这就好比写文章一样，给到一个命题，我们自己写一篇，然后再看人家是怎么写的。二者一对比，高下立判。他和你实现的肯定有不同的地方，那么这些不同的地方，不外乎三种情形：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;它不如你&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;这个时候一定不能傲慢，认为它这样做，就一定不如你。需要慎重考虑为什么这里出现一个表面看起来很明显的不太好的设计（这种情况，往往是因为一些历史原因或者有其特殊的需求背景）。&lt;/p&gt;&#xA;&lt;p&gt;如果反复考虑之后，确实没有想出来更好的理由，那么你就可以理解你的设计比他的要高明（它的设计，并不一定都是最优方案，所谓战略上藐视，战术上重视），可以小小地得意一下。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;你不如它&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;这个时候，你要暗自欣喜，因为你挖到矿了。这个技术点，没有白花时间研究。这就好比，你跟高手过招后，学到了几招新的武功，这是能够提升你的战力的。&lt;/p&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;殊途同归&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;你们的实现方案，各有利弊，各有其明显的缺点或者优点。&lt;/p&gt;&#xA;&lt;p&gt;情形 2 和情形 3，都能在很大程度上拓宽你的视野，让你的技术品味升级。&lt;/p&gt;&#xA;&lt;p&gt;最后，当前的技术点可能和你的工作没有太直接的关系（比如研究操作系统内核和写业务CRUD），但是里面的一些精髓的设计理念，其实完全可以迁移到业务中去（比如缓存、异步）。操作系统在有些时候，是追求极致的准确和性能的，这一点要求是比 99% 的业务高的。&lt;/p&gt;&#xA;&lt;p&gt;三、总结和梳理&lt;/p&gt;&#xA;&lt;p&gt;在前两步完成之后，基本上你对这个技术点，算是完全吃透了。这个时候别忘记及时梳理和总结，梳理过后的才会有条理的放在你的技能仓库中，不至遗忘或者记忆错乱。&lt;/p&gt;</description>
    </item>
    <item>
      <title>[译] 细谈依赖和配置</title>
      <link>https://anriclee.github.io/posts/spring_framework/core/the_ioc_container/dependencies/dependencies_configuration_in_detail/</link>
      <pubDate>Mon, 11 Sep 2023 21:12:31 +0800</pubDate>
      <guid>https://anriclee.github.io/posts/spring_framework/core/the_ioc_container/dependencies/dependencies_configuration_in_detail/</guid>
      <description>&lt;p&gt;依赖项的详细配置&lt;/p&gt;&#xA;&lt;p&gt;正如前面所提到的那样，你可以定义 bean 的属性和构造函数参数，去引用其他已经设置好的 bean 或者内联定义的值。&#xA;为了达到这个目的，Spring 的基于 XML 配置元数据支持在 &lt;!-- raw HTML omitted --&gt; 和 &lt;!-- raw HTML omitted --&gt; 元素内增加子元素。&lt;/p&gt;&#xA;&lt;h1 id=&#34;直接值基本类型字符串等等&#34;&gt;直接值（基本类型，字符串等等）&lt;/h1&gt;&#xA;&lt;p&gt;&lt;!-- raw HTML omitted --&gt; 元素的 value 值，把一个属性值或者构造函数参数定义为一个可读字符串。Spring 的转换服务被用来将这些值从字符串转换为属性或者参数的实际类型。下面的例子展示了可以被设置的多种值：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-XML&#34; data-lang=&#34;XML&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;bean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;myDataSource&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;class=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;org.apache.commons.dbcp.BasicDataSource&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;destroy-method=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;close&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!-- results in a setDriverClassName(String) call --&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;property&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;driverClassName&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;value=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;com.mysql.jdbc.Driver&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;property&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;url&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;value=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;jdbc:mysql://localhost:3306/mydb&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;property&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;username&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;value=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;root&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;property&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;password&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;value=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;misterkaoli&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;下面的例子使用 p-namespace 来让 XML 配置更加简明：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-XML&#34; data-lang=&#34;XML&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;beans&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;xmlns=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://www.springframework.org/schema/beans&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;xmlns:xsi=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;xmlns:p=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://www.springframework.org/schema/p&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://www.springframework.org/schema/beans&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&#x9;https://www.springframework.org/schema/beans/spring-beans.xsd&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;bean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;myDataSource&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;class=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;org.apache.commons.dbcp.BasicDataSource&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;destroy-method=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;close&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;p:driverClassName=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;com.mysql.jdbc.Driver&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;p:url=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;jdbc:mysql://localhost:3306/mydb&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;p:username=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;root&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;p:password=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;misterkaoli&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的 XML 更加的简明。然而，类型是在运行时而不是设计时发现的，除非你在创建 bean 定义的时候，用支持自动属性完成的 IDE（例如 Intellij IDEA 或者 Eclipse 的 Spring 工具）。这些辅助都是高度推荐的。&#xA;你同样可以配置 &lt;code&gt;java.util.Properties&lt;/code&gt; 的实例，如下：&lt;/p&gt;</description>
    </item>
    <item>
      <title>[译] 依赖注入</title>
      <link>https://anriclee.github.io/posts/spring_framework/core/the_ioc_container/dependencies/dependency_injection/</link>
      <pubDate>Mon, 11 Sep 2023 20:12:31 +0800</pubDate>
      <guid>https://anriclee.github.io/posts/spring_framework/core/the_ioc_container/dependencies/dependency_injection/</guid>
      <description>&lt;p&gt;在依赖注入（DI）里，对象通过构造函数参数、工厂方法参数或者在&#xA;被工厂方法创建返回的对象中设置的属性定义他们的依赖。然后，容器在创建这些 bean 时，注入依赖。这个过程与 bean 自身使用所需要类的直接构造函数实例化，或者通过 Service Locator 模式来找到所需要的依赖这个过程正好相反。&lt;/p&gt;&#xA;&lt;p&gt;使用 DI 原则的代码更加干净整洁，并且提供给对象的依赖时，解耦也更加高效。对象并不找他们的依赖也并不知道这些依赖的地址或者类。这样的结果就是，你的类变得更易测试，尤其是当依赖是接口或者抽象的父类时，在单元测试可以对这些依赖进行打桩或者mock他们的实现。&lt;/p&gt;&#xA;&lt;h1 id=&#34;基于构造函数的依赖注入&#34;&gt;基于构造函数的依赖注入&lt;/h1&gt;&#xA;&lt;p&gt;基于构造函数的依赖注入，是通过容器调用构造函数，并且传入若干参数来实现的，每一个参数都代表了一个依赖。调用静态工厂方法并传入特定的参数来构造一个 bean 也是一样的，在本讨论中，对待构造函数的参数和静态方法的参数也是相似的。下面的这里展示了一个之能通过构造函数来进行依赖注入的类：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Java&#34; data-lang=&#34;Java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SimpleMovieLister&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;// the SimpleMovieLister has a dependency on a MovieFinder&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; MovieFinder movieFinder;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;// a constructor so that the Spring container can inject a MovieFinder&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SimpleMovieLister&lt;/span&gt;(MovieFinder movieFinder) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;movieFinder&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; movieFinder;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;// business logic that actually uses the injected MovieFinder is omitted...&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意，对于这个类没有更多特殊的地方。它仅仅是一个POJO，并且对容器特定接口、父类或者注解没有任何依赖。【译者按：没有任何代码侵入性】&lt;/p&gt;&#xA;&lt;h2 id=&#34;构造函数参数解析&#34;&gt;构造函数参数解析&lt;/h2&gt;&#xA;&lt;p&gt;构造函数参数解析匹配通过参数类型来进行。如果在构造函数参数的 bean 定义中没有歧义，那么在 bean 定义中构造函数参数的顺序，就是当 bean 被实例化时，传给给构造函数参数的顺序。考虑下面的类：&lt;/p&gt;</description>
    </item>
    <item>
      <title>中秋绝句</title>
      <link>https://anriclee.github.io/posts/essays/poems/</link>
      <pubDate>Wed, 06 Sep 2023 23:14:19 +0800</pubDate>
      <guid>https://anriclee.github.io/posts/essays/poems/</guid>
      <description>&lt;p&gt;中秋绝句&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;癸卯秋夜，虽炎热潮湿，开窗无月，然心情大好，咏志抒怀，无碍也，是为序。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;自来霜雪映吴钩，半生浮云半生幽&lt;/p&gt;&#xA;&lt;p&gt;未有三旬寂寞守，何能一夜照清秋&lt;/p&gt;</description>
    </item>
    <item>
      <title>[译] Spring AOP 概念</title>
      <link>https://anriclee.github.io/posts/spring_framework/core/spring_aop/concept/</link>
      <pubDate>Tue, 05 Sep 2023 23:01:18 +0800</pubDate>
      <guid>https://anriclee.github.io/posts/spring_framework/core/spring_aop/concept/</guid>
      <description>&lt;p&gt;AOP 通过提供另外一种关于程序结构的思考方式补充了面向对象编程（OOP ）。在 OOP 中模块的关键单元是 class，而在 AOP 中，模块的关键是 Aspect（切面）。切面支持跨多个对象和类型的关注点模块化（比如事务的管理）。在 AOP 中这种关注点通常被叫做 “跨领域” 关注点。&lt;/p&gt;&#xA;&lt;p&gt;Spring 的一个核心组件就是 AOP 框架。虽然 Spring IoC 容器并不依赖于 AOP（意思是如果不想用 AOP 可以不用），但是 AOP 对 Spring IoC 做了一个补充，提供了一种功能非常强大的中间件解决方案。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Spring AOP 和 切面切点&lt;/p&gt;&#xA;&lt;p&gt;Spring 提供了简单而高效的方式来自定义切面，可以通过基于 schema 的方法也可以通过 @AspectJ 注解的风格。当使用 Spring AOP 来织入时，这两种风格都提供了充分类型的 advice 和 AspectJ 的切点语言。&lt;/p&gt;&#xA;&lt;p&gt;这张主要讨论 schema 和 @Aspect 的 AOP 支持。AOP 底层的支持在下面的一章节会讨论到。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;AOP 在 Spring 框架中的用途：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;提供声明式的企业级服务。最重要的就是声明式事务管理&lt;/li&gt;&#xA;&lt;li&gt;让用户实现自定义的切面作为他们用 AOP 实现 OOP 的补充。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Note：如果你对通用的声明式服务或者其他预先打包的声明式中间件服务感兴趣，你不用直接和 Spring AOP 直接打交道，可以跳过本章的大部分地方。&lt;/p&gt;&#xA;&lt;h1 id=&#34;aop-概念&#34;&gt;AOP 概念&lt;/h1&gt;&#xA;&lt;p&gt;让我们从一些核心的 AOP 概念和术语出发。这些术语并不只是 Spring 特有的。不幸地是，AOP 术语并不符合直觉。然而，如果 Spring 使用它自己的术语，或许会更加令人迷惑。&lt;/p&gt;</description>
    </item>
    <item>
      <title>[译] Bean 概述</title>
      <link>https://anriclee.github.io/posts/spring_framework/core/the_ioc_container/bean_overview/</link>
      <pubDate>Sat, 02 Sep 2023 23:12:31 +0800</pubDate>
      <guid>https://anriclee.github.io/posts/spring_framework/core/the_ioc_container/bean_overview/</guid>
      <description>&lt;p&gt;一个 Sring IoC 容器可以操作一个或者多个 bean。这些 bean 是通过你提供给容器的配置元数据生成的（例如，以 XML 中的 &lt;code&gt;&amp;lt;bean/&amp;gt;&lt;/code&gt; ）。&lt;/p&gt;&#xA;&lt;p&gt;在容器内，这些 bean 的定义被表示成 &lt;code&gt;BeanDefinition&lt;/code&gt; 对象的形式，包含了下面的元数据：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;包定义的类名：通常是定义的 bean 的真正实现类&lt;/li&gt;&#xA;&lt;li&gt;bean 行为配置元素，表明了 bean 在 container 中的行为（scope，生命周期回调等等）。&lt;/li&gt;&#xA;&lt;li&gt;对其他需要的 bean 的引用。这些引用也被称作协作器和依赖。&lt;/li&gt;&#xA;&lt;li&gt;在一个新创建的对象中的其他配置设置 - 例如，池的数量限制或者一个操作连接池 bean 中的连接数量&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这些元数据转换为构成这些 bean 定义的一系列属性。下表表示了这些属性值：&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;属性&lt;/th&gt;&#xA;          &lt;th&gt;含义&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Class&lt;/td&gt;&#xA;          &lt;td&gt;正在实例化的bean&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Name&lt;/td&gt;&#xA;          &lt;td&gt;bean的名字&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Scope&lt;/td&gt;&#xA;          &lt;td&gt;Bean的Scope&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;构造函数参数&lt;/td&gt;&#xA;          &lt;td&gt;依赖注入&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;自动装配模式&lt;/td&gt;&#xA;          &lt;td&gt;装配的协作对象&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;懒加载模式&lt;/td&gt;&#xA;          &lt;td&gt;懒加载 Bean&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;初始化方法&lt;/td&gt;&#xA;          &lt;td&gt;初始化回调&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;析构方法&lt;/td&gt;&#xA;          &lt;td&gt;析构回调&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;除了包含怎么创建一个特定的 bean 的信息之外， &lt;code&gt;ApplicationContext&lt;/code&gt; 的实现同样允许在容器外面已经创建好的对象注册到其中（用户创建）。这是通过 &lt;code&gt;getBeanFactory&lt;/code&gt; 方法获取到 &lt;code&gt;ApplicationContext&lt;/code&gt; 的 &lt;code&gt;BeanFactory&lt;/code&gt;，得到 &lt;code&gt;DefaultListableBeanFactory&lt;/code&gt; 实现来做到的。&lt;code&gt;DefaultListableBeanFactory&lt;/code&gt; 支持通过调用 &lt;code&gt;registerSingleton(..)&lt;/code&gt;  和 &lt;code&gt;registerBeanDefinition(..)&lt;/code&gt; 方法来实现这样的注册。然而，典型的应用程序仅仅使用常规的 bean 定义元数据。&lt;/p&gt;</description>
    </item>
    <item>
      <title>[译] Spring IOC 容器</title>
      <link>https://anriclee.github.io/posts/spring_framework/core/the_ioc_container/container_and_beans/</link>
      <pubDate>Sat, 02 Sep 2023 23:12:31 +0800</pubDate>
      <guid>https://anriclee.github.io/posts/spring_framework/core/the_ioc_container/container_and_beans/</guid>
      <description>&lt;h1 id=&#34;spring-ioc-和-bean-的简介&#34;&gt;Spring IOC 和 bean 的简介&lt;/h1&gt;&#xA;&lt;p&gt;本章涵盖了 SpringFramework 中的控制反转原则（Ioc）的实现。IoC 也被称为依赖注入（DI）。它是这样的一种过程，在此期间对象仅通过构造函数参数、工厂方法的参数或者当对象实例被构造后或者通过工厂方法返回时在它上面设置的属性定义自己的依赖（即对象必须合作的其他对象）。&lt;/p&gt;&#xA;&lt;p&gt;当容器创建这些 bean 后，再注入这些依赖。&lt;/p&gt;&#xA;&lt;p&gt;这个过程本质上与bean 通过使用直接的类构造函数进行直接实例化或者通过类似 Service Locator模式来寻找依赖的位置是相反的（这也是 IoC 名字的由来）。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;org.springframework.beans&lt;/code&gt; 和 &lt;code&gt;org.springframework.context&lt;/code&gt; 包是 SpringFramework IoC 容器的基石。&lt;code&gt;BeanFactory&lt;/code&gt; 接口提供了一种更先进的能够控制人已类型对象的配置机制。&lt;code&gt;ApplicationContext&lt;/code&gt; 是 &lt;code&gt;BeanFactory&lt;/code&gt; 的子接口。它增加了下面的特性：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;与 Spring 的 AOP 特性更容易整合&lt;/li&gt;&#xA;&lt;li&gt;消息资源处理（在国际化场景的使用）&lt;/li&gt;&#xA;&lt;li&gt;事件发布&lt;/li&gt;&#xA;&lt;li&gt;例如用于 Web 应用的 &lt;code&gt;WebApplicationContext&lt;/code&gt; 应用层特定的上下文&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;总而言之，&lt;code&gt;BeanFactory&lt;/code&gt; 提供了配置的框架和基本的功能。&lt;code&gt;ApplicationContext&lt;/code&gt; 增加了更多的企业特定的功能。&lt;code&gt;ApplicationContext&lt;/code&gt; 完全是 &lt;code&gt;BeanFactory&lt;/code&gt; 的超集。在本章关于 Spring IoC 容器做专门描述时会用到。想要获取更多的关于使用 &lt;code&gt;ApplicationContext&lt;/code&gt; 而非 &lt;code&gt;BeanFactory&lt;/code&gt; 的信息，参见介绍 &lt;a href=&#34;https://docs.spring.io/spring-framework/reference/core/beans/beanfactory.html&#34;&gt;BeanFactory&lt;/a&gt; API 的部分。&lt;/p&gt;&#xA;&lt;p&gt;在 Spring 中，作为你应用基石同时可以被 Spring IoC 容器所操控的对象就被称之为 bean。bean 就是被 Spring IoC 容器实例化、组装和设置的对象。否则，一个 bean 就是你应用程序中诸多对象中的一个。 Beans 以及他们依赖关系，反映在容器使用的配置元数据中。&lt;/p&gt;</description>
    </item>
    <item>
      <title>[译] 容器概述</title>
      <link>https://anriclee.github.io/posts/spring_framework/core/the_ioc_container/container_overview/</link>
      <pubDate>Sat, 02 Sep 2023 23:12:31 +0800</pubDate>
      <guid>https://anriclee.github.io/posts/spring_framework/core/the_ioc_container/container_overview/</guid>
      <description>&lt;h1 id=&#34;容器概述&#34;&gt;容器概述&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;org.springframework.context.ApplicationContext&lt;/code&gt; 接口代表了 Spring IoC 容器，它主要负责通过读取配置文件对 bean 进行实例化、配置和组装。&#xA;容器通过读取配置元数据来获知要实例化、配置和组装那些对象。配置的元数据一般为 XML、Java 注解和 Java 代码的形式，它让你能够表达组成你应用程序的对象以及对象之间的丰富的相互依赖关系。&lt;/p&gt;&#xA;&lt;p&gt;Spring 提供了 &lt;code&gt;ApplicationContext&lt;/code&gt; 接口的若干实现。在单体应用中，创建一个 &lt;code&gt;ClassPathXmlApplicationContext&lt;/code&gt; 或者 &lt;code&gt;FileSystemXmlApplicationContext&lt;/code&gt; 是很常见的。虽然 XML 是定义配置元数据的传统形式，但是你还可以通过在 XML 文件里面进行声明配置来告诉容器对于 Java 注解或者Java代码格式的支持。&lt;/p&gt;&#xA;&lt;p&gt;在大多数的应用场景中，并不需要显式的代码来实例化 Spring IoC 容器。例如，在 Web 应用的场景中，在 &lt;code&gt;web.xml&lt;/code&gt; 文件中仅用简单的 8 行代码左右的样板 Web XML 描述符即可满足需要（参考 &lt;a href=&#34;https://docs.spring.io/spring-framework/reference/core/beans/context-introduction.html#context-create&#34;&gt;Convenient ApplicationContext Instantiation for Web Applications&lt;/a&gt;）。如果你使 Eclipse 中的 Spring 工具（在 Eclipse 开发环境中），你可以通过几下鼠标点击或者按键的敲击就能轻松创建这样一个样板配置文件。&lt;/p&gt;&#xA;&lt;p&gt;下图展示了关于 Spring 工作机制的一个全局视角。在 &lt;code&gt;ApplicationContext&lt;/code&gt; 被创建和初始化后，你的应用类和配置元数据已经捆绑在一起了，这样一来，你就有一个充分配置并且可执行的系统或者应用程序。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;imgs/ioc.png&#34; alt=&#34;Spring&#34;&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;配置元数据&#34;&gt;配置元数据&lt;/h1&gt;&#xA;&lt;p&gt;如上图所示，Spring Ioc 容器接收到一种格式的配置元数据。这个配置元数据代表了，作为一个应用开发者你告诉 Spring 容器在应用程序中，如何实例化、配置和组装对象。&lt;/p&gt;&#xA;&lt;p&gt;传统的配置元数据是一种简单并且符合直觉的 XML 形式，在本章的大部分地方，也用此来表达关键的概念和 Spring IoC 容器的特性。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;基于 XML 的元数据不是配置元数据的唯一允许的形式。Spring IoC 容器自身与配置元数据实际上是什么格式完全解耦。目前许多开发者在应用程序中选择&lt;a href=&#34;https://docs.spring.io/spring-framework/reference/core/beans/java.html&#34;&gt;基于Java 的配置&lt;/a&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>[译] SpringFramework 文档</title>
      <link>https://anriclee.github.io/posts/spring_framework/directory/</link>
      <pubDate>Sat, 02 Sep 2023 11:46:07 +0800</pubDate>
      <guid>https://anriclee.github.io/posts/spring_framework/directory/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;a href=&#34;Overview&#34;&gt;概述&lt;/a&gt; 历史，设计哲学，反馈，开始&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;a href=&#34;&#34;&gt;核心&lt;/a&gt; IoC容器，事件，资源，i18n，验证，数据绑定，类型转换，SpEL，AOP，AOT&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;a href=&#34;&#34;&gt;测试&lt;/a&gt; 对象 Mock，测试上下文框架，Spring MVC 测试，Web 测试客户端&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;a href=&#34;&#34;&gt;数据接入&lt;/a&gt; 事务，DAO 支持，JDBC，R2DBC，O/R 映射，XML 编码&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;a href=&#34;&#34;&gt;Web Servlet&lt;/a&gt; SpringMVC,WebSocket,SockJS,STOMP 通信&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;a href=&#34;&#34;&gt;Web 响应式&lt;/a&gt; Spring WebFlux, WebClient, WebSocket, RSocket.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;[集成] REST 客户端, JMS, JCA, JMX, Email, 任务, 调度, 缓存, 可见性.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;a href=&#34;&#34;&gt;语言&lt;/a&gt; Kotlin, Groovy, Dynamic 语言.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;a href=&#34;&#34;&gt;附录&lt;/a&gt; Spring 属性&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>[译] SpringFramework 概述</title>
      <link>https://anriclee.github.io/posts/spring_framework/overview/</link>
      <pubDate>Sat, 02 Sep 2023 11:46:07 +0800</pubDate>
      <guid>https://anriclee.github.io/posts/spring_framework/overview/</guid>
      <description>&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;&#xA;&lt;p&gt;Spring 使得创建 Java 企业级应用更加容易。它提供了你在企业环境下拥抱 Java 语言所需要的一切，支持 JVM 平台上的 Groovy 和 Kotlin 作为备选语言，并且提供了根据应用程序的需求创建多种架构的灵活性。从 SpringFramework 6.0 开始，Spring 需要 Java 17 以上的版本。&lt;/p&gt;&#xA;&lt;p&gt;Spring 支持广泛的应用场景。在一个大型企业里，应用程序经常会存在很长时间，并且必须运行在一个开发者不能控制升级周期的 JDK 和应用服务器上。&#xA;另外一些可能会作为一个内嵌服务器的单独 jar 包，运行在一个云环境里，还有一些可能是一个不需要服务器的独立应用程序（例如批处理或者集成处理工作）。&lt;/p&gt;&#xA;&lt;p&gt;Spring 是开源的。它有一个庞大而活跃的社群，基于各种实际用例，提供持续反馈。这也帮助了 Spring 在相当长一段时间内成功发展。。&lt;/p&gt;&#xA;&lt;h1 id=&#34;当我们在谈-spring-时我们在谈什么&#34;&gt;当我们在谈 Spring 时我们在谈什么&lt;/h1&gt;&#xA;&lt;p&gt;“Spring” 这个术语在不同的语境下有着不同的含义。它可以用来表示 SpringFramework 这个项目自身，一切都是从这里开始的（-译者按：梦开始的地方）。随着时间的推移，又构建了一些以 SpringFramework 为基础的 Spring 项目。大部分情况下，当人们谈论 Spring，他们的意思是 Spring 整个系列（-译者按：俗称全家桶）。本参考文档只针对这个基础进行介绍：SpringFramework 本身。&lt;/p&gt;&#xA;&lt;p&gt;SpringFramework 被分成不同的模块。应用程序可以根据他们所需要的模块进行选择。这些模块中处于核心的是 core container，包括配置模型和依赖注入机制。除此之外，SpringFramework 还对于不同应用架构提供基础支持，包括消息传递、事务以及持久化和 web。它同时也包含了基于 Servlet 的 SpringMVC web 框架以及Spring WebFlux 响应式web框架。&lt;/p&gt;&#xA;&lt;p&gt;关于这些模块需要注意的是：&lt;/p&gt;&#xA;&lt;p&gt;Spring 的框架，允许部署到 JDK 9 的模块路径（&amp;ldquo;Jigsaw&amp;rdquo;）。对于在支持 “Jigsaw” 的应用程序中的使用，Spring Framework 5 的 jar 包里面，携带了 “Automatic-Module-Name” 的 manifest entries，它定义了稳定的语言级别模块名（例如：“spring.core”，“spring.context” 等等），它与 jar 的 artifact 名字独立（ 这些 jar 遵循同样的模式，例如 “spring-core” 和 “spring-context”。 “-” 代替 “.”&lt;/p&gt;</description>
    </item>
    <item>
      <title>聊点什么</title>
      <link>https://anriclee.github.io/posts/essays/saysomething/</link>
      <pubDate>Wed, 30 Aug 2023 23:26:45 +0800</pubDate>
      <guid>https://anriclee.github.io/posts/essays/saysomething/</guid>
      <description>&lt;p&gt;谈心的文章好久没有写了，初秋的夜晚，键盘的敲击声格外响亮，一时竟然不知道从哪儿说起。我从今年开始，格外的怀旧起来。不只是怀念那个青春的八十年代，质朴的九十年代，而且竟然怀念起仿佛刚刚过去的两千年。也许是现在回看，带着滤镜和光影的原因吧。但我着实相信，过去确实比现在更加美丽一些。试问，现在还有什么歌曲能像过去的八九十年代扣人心弦，还有谁能写出像罗大佑那样充满人文情怀的歌词？我不是一个保守的人，现在的歌曲我也会经常听，但摇滚光是呐喊、嘶吼没有反思，民谣只有情绪没有韵味，流行歌曲更是惨不忍听。现在一首歌有四句比较朗朗上口一些，就能风靡一时，然后人们快速遗忘，寻找下一个。人们没法不遗忘，因为实在没有什么好怀念的。&lt;/p&gt;&#xA;&lt;p&gt;人们在路上疯狂且快速的奔跑着，前面有人但凡有一点点挡道，便会怒从心头起。也许在快速奔跑中，人们才来不及为过去伤怀，风驰电掣，麻木一生。&lt;/p&gt;&#xA;&lt;p&gt;如果我也这样，多好！&lt;/p&gt;&#xA;&lt;p&gt;可是，我偏偏要将步伐放慢，歪着头想想，于是总感觉自己是个慢半拍的人。&lt;/p&gt;&#xA;&lt;p&gt;今年一整年，几乎没有在公众号上发表任何文章，我想找个没人的地方，倾吐一下自己的想法。&lt;/p&gt;&#xA;&lt;h1 id=&#34;失落与大门&#34;&gt;失落与大门&lt;/h1&gt;&#xA;&lt;p&gt;今年是让我特别失落的一年，特别失落。&lt;/p&gt;&#xA;&lt;p&gt;还有几年，就到传说中的中年危机了。坦白说，我直到今年才有些许明白，中年危机的真实含义。&lt;/p&gt;&#xA;&lt;p&gt;所谓中年危机，并不单单是一个经济的问题，而是方方面面。&lt;/p&gt;&#xA;&lt;p&gt;这个尴尬的年纪，朋友帮不上你，于是友情危机；妻子不理解你，于是婚姻危机；父母埋怨你，于是亲情危机。各方面的危机，想汹涌的几股暗流，汇集而来，向涉世未深的你迎面击来。&lt;/p&gt;&#xA;&lt;p&gt;这个年纪，看似血气方刚，实则是最脆弱的年纪，没有经验的积淀，没有人脉的积淀，只有你自己硬抗，像不喝药，凭借自己的身体素质对抗一场重感冒。&lt;/p&gt;&#xA;&lt;p&gt;扛过去，就会好很多。后面遇到再多糟心事，有了前面的抗体，总是会好过一些。&lt;/p&gt;&#xA;&lt;p&gt;呵，男人四十！&lt;/p&gt;&#xA;&lt;p&gt;今年的夏天格外热，但是在每次下班骑车回家的路上，听着歌，经常感觉浑身一阵冷战。也许是突然被某句歌词所触动，伤怀往事、怀疑信念。&lt;/p&gt;&#xA;&lt;p&gt;于是有一阵子，我囤了很多书。最明显的变化是，我开始看外国小说了，以前硬着头皮两次入门、两次放弃的《安娜卡列尼娜》，这次竟然能够看的津津有味，甚至有时候，会有冲动，买下托尔斯泰的《战争与和平》这部据说很冗长的巨著一看。&lt;/p&gt;&#xA;&lt;p&gt;年龄大了，学会妥协了。年少时，看那些翻译过来的腔调，就是不喜欢看不下去，我从来不理解为什么要冗长的心理描写，为什么人物的每一句台词，中间都要被“xxx说”拦腰斩为两截，如此种种。&lt;/p&gt;&#xA;&lt;p&gt;今年突然明白了，这就是文化差异，不同地区的表达习惯，是会有不同的，不只是语汇的区分。我们应该注重的是书里面的所蕴含的光辉思想以及作者倾注的满腔热情。我们在《史记-项羽本纪》里面看不到一句项羽的心理描写，仅凭几句念白，几句描写，一个英雄就这样被人千年。&lt;/p&gt;&#xA;&lt;p&gt;所以，中国会有山水画，笔墨留白，却依然已经满怀，而西方的工笔画、油画也依然是情绪饱满的。&lt;/p&gt;&#xA;&lt;p&gt;留白也有水货，浓墨重彩也有精品。&lt;/p&gt;&#xA;&lt;p&gt;这么想着，一道艺术的大门就这样为我敞开。&lt;/p&gt;&#xA;&lt;p&gt;思想越包容，视野越广阔。有些时候，就是需要换一个视角和思维的转变。&lt;/p&gt;&#xA;&lt;h1 id=&#34;ai-与艺术&#34;&gt;AI 与艺术&lt;/h1&gt;&#xA;&lt;p&gt;AI 是今年的热词，仿佛一夜之间，什么都可以用 AI 做了。&lt;/p&gt;&#xA;&lt;p&gt;就在这孤独的一年，我的阅读量和艺术视角，刻意地伸长，触及到了我之前出于懒惰不会触及的地方。就凭我简单的探索，我就知道 AI 根本没戏，虽然，我是一个技术人，但是我从来不认为 AI 能够写出那些不朽的作品，能够勾勒出那些美妙的线条。&lt;/p&gt;&#xA;&lt;p&gt;很简单，因为 AI 不是人，没有意识和灵魂。&lt;/p&gt;&#xA;&lt;p&gt;不是人，所以不会像人一样犯错，与此同时，也缺少了很多偶然。须知，很多艺术就是来源于偶然的灵光一现。&lt;/p&gt;&#xA;&lt;p&gt;当然，还有一个重要的因素，就是伟大的读者催生伟大的作品，我们很难想象，被 AI 和短视频喂饱的读者们会有什么眼光去苛求那些内容的生产者。&lt;/p&gt;&#xA;&lt;p&gt;想来也荒唐，到底是谁训练了谁？&lt;/p&gt;&#xA;&lt;p&gt;将来的市场，AI 肯定是能挤掉一部分人的作品的。那些平庸的、毫无新意和灵魂的作品，会被 AI 取而代之。这或许倒是一个良币驱逐劣币的过程。&lt;/p&gt;&#xA;&lt;p&gt;试看当今的歌坛，有多惨不忍睹就知道，科技能帮助人在艺术道路上走一段路，可是，剩下的路还是要靠人类自己走。&lt;/p&gt;&#xA;&lt;p&gt;这是人类的宿命。&lt;/p&gt;&#xA;&lt;p&gt;AI 也没有用。&lt;/p&gt;&#xA;&lt;p&gt;也许，将来 AI 可能会突然大爆发，像人一样有了意识，但也是需要和人一样有痛苦的经历的。这样，AI 既有了人的意识，又有了人的经历和痛苦，那就是人类无疑了。&lt;/p&gt;&#xA;&lt;p&gt;也许是 AI 被我们人类同化了吧？不知道是否可以当成人类的一场惨胜。&lt;/p&gt;&#xA;&lt;h1 id=&#34;人文与科技&#34;&gt;人文与科技&lt;/h1&gt;&#xA;&lt;p&gt;自己今年的时间，比往年多了一些，想做的事情太多，结果现在一件事也没有做成。自己不甘于只做一个消费者，也想做一个内容的生产者。&lt;/p&gt;&#xA;&lt;p&gt;但生成什么内容，却让自己又一次开始了犹豫和纠结。&lt;/p&gt;&#xA;&lt;p&gt;也许，这也是我的宿命，我注定会饿死在人文与科技的十字路口。&lt;/p&gt;&#xA;&lt;p&gt;人文类的内容，是我的兴趣所在，但是目前的境况很是不尽人意，言论管控空前，万马齐喑。再加上饭圈文化和粉丝量的有限和题材内容的饱和，很难找到一个切入口完成一些看似“伟大”的事情。&lt;/p&gt;&#xA;&lt;p&gt;科技类的内容，也是我想做的，看起来比人文的圈子要简单一些，但是，也比较枯燥一些，而且，自己驾驭起来，并不如人文类的容易一些，粉丝量的成长幅度，肯定比不上人文类的 up 主，毕竟大家都想在下班后，躺在床上，听听历史的八卦，谁会主动坐在桌前，听你分享一些你自己以为讲的很明白的原理和架构？&lt;/p&gt;&#xA;&lt;p&gt;但是，自己毕竟是吃技术这碗饭的，而且自己在今年换工作之后，看到身边有的人无知的像一头猪一样，不禁觉得可笑之余，转念一想，自己是否在另一些人的眼里，也无知得可笑呢？于是，我立志，要把自己的技术短板填补上，尽量不看起来像一头猪。&lt;/p&gt;&#xA;&lt;p&gt;综合起来，貌似技术up这条路，自己会走得更踏实一些，而且人文类的内容，要想做得出彩，关键在于自己阅历的积淀和对世情的理解。同样是看《潜伏》，有的人能分析地头头是道，非经一番历练之人，不可懂其中深味也。&lt;/p&gt;&#xA;&lt;h1 id=&#34;希望与失望&#34;&gt;希望与失望&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;当蜘蛛网无情地查封了我的炉台，&lt;/p&gt;&#xA;&lt;p&gt;当灰烬的余烟叹息着贫困的悲哀，&lt;/p&gt;&#xA;&lt;p&gt;我依然固执地铺平失望的灰烬，&lt;/p&gt;&#xA;&lt;p&gt;用美丽的雪花写下：相信未来。&lt;/p&gt;</description>
    </item>
    <item>
      <title>《金瓶梅》</title>
      <link>https://anriclee.github.io/posts/gold_bottle/1/</link>
      <pubDate>Sun, 07 May 2023 23:38:33 +0800</pubDate>
      <guid>https://anriclee.github.io/posts/gold_bottle/1/</guid>
      <description>&lt;p&gt;碎碎念。&lt;/p&gt;</description>
    </item>
    <item>
      <title>《红楼梦》碎碎念</title>
      <link>https://anriclee.github.io/posts/stone/summary/</link>
      <pubDate>Sun, 07 May 2023 23:15:53 +0800</pubDate>
      <guid>https://anriclee.github.io/posts/stone/summary/</guid>
      <description>&lt;p&gt;个人读《红楼梦》之所感所思，想到哪儿，写到哪儿，不拘章法，也无体系，不求闻达，但求深思。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Telegram bot 入门实践</title>
      <link>https://anriclee.github.io/posts/telegram_bot/</link>
      <pubDate>Sat, 11 Jun 2022 11:43:42 +0800</pubDate>
      <guid>https://anriclee.github.io/posts/telegram_bot/</guid>
      <description>&lt;h1 id=&#34;什么是-bot&#34;&gt;什么是 Bot&lt;/h1&gt;&#xA;&lt;p&gt;Bot 的概念在官网的介绍稍微有点繁琐和，详细可以了解&lt;a href=&#34;https://core.telegram.org/bots&#34;&gt;官网介绍&lt;/a&gt;，&lt;/p&gt;&#xA;&lt;p&gt;简单来说，bot 就是你在 telegram 中的一个特殊账号，你申请了 bot，这个 bot 就是你的代理人，你发号施令到 bot，bot 会响应你的指令，仅此而已。&lt;/p&gt;&#xA;&lt;p&gt;申请 bot 需要找 BotFather（名字起的很形象），具体过程官网说的比较详细，此处不赘言。但是需要强调的一点是，bot 仅仅是你的代理人而已，真正执行你指令的是你自己部署的脚本，如果你不部署自己的脚本，在 bot 中输入指令，是没有任何响应的。&lt;/p&gt;&#xA;&lt;p&gt;你、bot和你部署的脚本关系如下:&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/anriclee/diagramStorage/master/telegram.drawio.png&#34; alt=&#34;&amp;ldquo;你、bot和你部署的脚本&amp;rdquo;&#34;&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;脚本&#34;&gt;脚本&lt;/h1&gt;&#xA;&lt;p&gt;上面说过了，bot 只是你在 telegram 的一个代理，真正干活的是你的脚本。既然自己写脚本，就会存在两个问题：接受指令、做出响应。&lt;/p&gt;&#xA;&lt;h2 id=&#34;接受指令&#34;&gt;接受指令&lt;/h2&gt;&#xA;&lt;p&gt;对于如何让脚本接受指令，官方提供了两种思路：推模式 、拉模式。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;拉模式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这种模式，官方不太推荐。简单而言，就是自己部署一个脚本，不断执行 get 请求，获取自己 bot 的更新信息，就好比一个仆人一直在问你：&lt;/p&gt;&#xA;&lt;p&gt;有没有需要我做的？&lt;/p&gt;&#xA;&lt;p&gt;有没有需要我做的？&lt;/p&gt;&#xA;&lt;p&gt;有没有需要我做的？&lt;/p&gt;&#xA;&lt;p&gt;询问的方式也比较简单：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;curl -X GET https://api.telegram.org/bot[token]/getUpdates&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里的 token，就是上面申请 bot 完毕后，得到的 token， 出于脱敏，我使用 [token] 代替，下同。这种方法比较笨拙，轮询的频次太高和太低都不行，而且你在 bot 中发布一条指令后，可能并不能够马上得到执行，会有延迟。&lt;/p&gt;&#xA;&lt;p&gt;这种方式的好处是：可以让 bot 启在本地，不需要部署到服务器上，因为 telegram 不知道你的存在，他也不需要知道你的存在。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;推模式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这种方式是官方比较推荐的一种方式，这种类似事件驱动的原理。只有有任务了，才会通知脚本去做。但前提是：在向 bot 发号施令前，需要在 bot 中注册一个 callback url。&lt;/p&gt;&#xA;&lt;p&gt;bot 在接受你的指令后，会调用此 url，通知你的脚本，让他执行任务。&lt;/p&gt;&#xA;&lt;p&gt;注册方式也比较简单：&lt;/p&gt;</description>
    </item>
    <item>
      <title>基于 PostgreSQL 的群聊搜索实践</title>
      <link>https://anriclee.github.io/posts/pg/</link>
      <pubDate>Thu, 13 Jan 2022 00:00:00 +0000</pubDate>
      <guid>https://anriclee.github.io/posts/pg/</guid>
      <description>&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;&#xA;&lt;p&gt;2021年年初，探探上线了群聊功能，并且支持按照群名进行模糊搜索。&lt;/p&gt;&#xA;&lt;p&gt;对于复杂场景的搜索，业界一般使用非常流行的 ElasticSearch。由于我们的群数据较少，截止到目前还没有达到千万级的量级，且搜索场景比较简单，而 PostgreSQL 对全文搜索又支持得比较好，所以选择了 PostgreSQL 来实现群搜索需求。&#xA;在使用 PostgreSQL 做群搜索的过程中，也经历了由简单到复杂的迭代过程，中间也踩了不少坑。 下面的几个例子说明了方案的演进过程和我们的优化思路，希望能够对大家有所帮助。&lt;/p&gt;&#xA;&lt;h2 id=&#34;like-模糊查询&#34;&gt;LIKE 模糊查询&lt;/h2&gt;&#xA;&lt;p&gt;提到模糊搜索，最简单的办法就是对搜索列进行 like 匹配： 在输入词的前后加上 &lt;code&gt;%&lt;/code&gt; 即可,如下所示:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;SELECT * FROM groups WHERE name LIKE &amp;#39;%探探%&amp;#39;;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种方案可行是可行了，但是实现过于简单粗暴。对此方案进行测试：&lt;/p&gt;&#xA;&lt;p&gt;建一张简单的表进行测试，表结构如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;lixuehan=# \d groups;&#xD;&#xA;                                   Table &amp;#34;public.groups&amp;#34;&#xD;&#xA; Column |         Type          | Collation | Nullable |              Default&#xD;&#xA;--------+-----------------------+-----------+----------+------------------------------------&#xD;&#xA; id     | bigint                |           | not null | nextval(&amp;#39;groups_id_seq&amp;#39;::regclass)&#xD;&#xA; name   | character varying(50) |           |          |&#xD;&#xA;Indexes:&#xD;&#xA;    &amp;#34;groups_pkey&amp;#34; PRIMARY KEY, btree (id)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;表中只有两列：主键 &lt;code&gt;id&lt;/code&gt; 以及群名 &lt;code&gt;name&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;create or replace function gen_hanzi(int) returns text as $$&#xD;&#xA;declare&#xD;&#xA;    res text;&#xD;&#xA;begin&#xD;&#xA;    if $1 &amp;gt;=1 then&#xD;&#xA;        select string_agg(chr(19968+(random()*20901)::int), &amp;#39;&amp;#39;) into res from generate_series(1,$1);&#xD;&#xA;        return res;&#xD;&#xA;    end if;&#xD;&#xA;    return null;&#xD;&#xA;end;&#xD;&#xA;$$ language plpgsql strict;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;gen_hanzi&lt;/code&gt; 是一个随机生成汉字的函数，我们使用一个该函数构造 100w 条数据，插入到该表中。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Hugo 中的命令行模式</title>
      <link>https://anriclee.github.io/posts/hugo_cmd_pattern/</link>
      <pubDate>Fri, 26 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://anriclee.github.io/posts/hugo_cmd_pattern/</guid>
      <description>&lt;p&gt;最近在用 hugo 构建了个人博客之后，便有兴趣想研究下其源码。但是源码的体量之大，逻辑之复杂出乎我的意料。不过好在源码的结构比较清晰，有许多地方值得借鉴。&lt;/p&gt;&#xA;&lt;p&gt;比如它的程序入口，非常简洁：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Golang&#34; data-lang=&#34;Golang&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;resp&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;commands&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Execute&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;os&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Args&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;:])&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;resp&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;resp&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;IsUserError&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;resp&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Cmd&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;resp&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Cmd&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;resp&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Cmd&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;UsageString&lt;/span&gt;())&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;os&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Exit&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;它将所有根据命令行参数传入的指令统一封装到 &lt;code&gt;commands&lt;/code&gt; 包中。后面有新命令需求时，只需要新建一个 cmd 文件即可。&lt;/p&gt;&#xA;&lt;p&gt;它是怎么做到的呢？&lt;/p&gt;&#xA;&lt;p&gt;简而言之，就是在程序入口处将所有的命令类汇总，然后再根据输入参数&lt;code&gt;args&lt;/code&gt;，决定要执行哪个&lt;code&gt;cmd&lt;/code&gt;，看似增加了代码的复杂度，但是对于后续命令的扩展显得非常方便。&lt;/p&gt;&#xA;&lt;p&gt;hugo 中使用了 builder 模式将所有的命令汇总，我这里简单起见，只初始化了一个数组，主要是体会其开闭原则的思想即可。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Talk is cheap, show me the code&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;借鉴它的思路，我写了一个简化版，可以参看，&lt;a href=&#34;https://github.com/anriclee/GoPatterns/tree/main/cmdpattern&#34;&gt;代码链接&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
