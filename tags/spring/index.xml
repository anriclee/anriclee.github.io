<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Spring on ReadByWord</title>
    <link>https://anriclee.github.io/tags/spring/</link>
    <description>Recent content in Spring on ReadByWord</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 02 Sep 2023 23:12:31 +0800</lastBuildDate><atom:link href="https://anriclee.github.io/tags/spring/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[译] Bean 概述</title>
      <link>https://anriclee.github.io/posts/springframework/core/the_ioc_container/bean_overview/</link>
      <pubDate>Sat, 02 Sep 2023 23:12:31 +0800</pubDate>
      
      <guid>https://anriclee.github.io/posts/springframework/core/the_ioc_container/bean_overview/</guid>
      <description>一个 Sring IoC 容器可以操作一个或者多个 bean。这些 bean 是通过你提供给容器的配置元数据生成的（例如，以 XML 中的 &amp;lt;bean/&amp;gt; ）。
在容器内，这些 bean 的定义被表示成 BeanDefinition 对象的形式，包含了下面的元数据：
包定义的类名：通常是定义的 bean 的真正实现类 bean 行为配置元素，表明了 bean 在 container 中的行为（scope，生命周期回调等等）。 对其他需要的 bean 的引用。这些引用也被称作协作器和依赖。 在一个新创建的对象中的其他配置设置 - 例如，池的数量限制或者一个操作连接池 bean 中的连接数量 这些元数据转换为构成这些 bean 定义的一系列属性。下表表示了这些属性值：
属性 含义 Class 正在实例化的bean Name bean的名字 Scope Bean的Scope 构造函数参数 依赖注入 自动装配模式 装配的协作对象 懒加载模式 懒加载 Bean 初始化方法 初始化回调 析构方法 析构回调 除了包含怎么创建一个特定的 bean 的信息之外， ApplicationContext 的实现同样允许在容器外面已经创建好的对象注册到其中（用户创建）。这是通过 getBeanFactory 方法获取到 ApplicationContext 的 BeanFactory，得到 DefaultListableBeanFactory 实现来做到的。DefaultListableBeanFactory 支持通过调用 registerSingleton(..) 和 registerBeanDefinition(.</description>
      <content:encoded><![CDATA[<p>一个 Sring IoC 容器可以操作一个或者多个 bean。这些 bean 是通过你提供给容器的配置元数据生成的（例如，以 XML 中的 <code>&lt;bean/&gt;</code> ）。</p>
<p>在容器内，这些 bean 的定义被表示成 <code>BeanDefinition</code> 对象的形式，包含了下面的元数据：</p>
<ul>
<li>包定义的类名：通常是定义的 bean 的真正实现类</li>
<li>bean 行为配置元素，表明了 bean 在 container 中的行为（scope，生命周期回调等等）。</li>
<li>对其他需要的 bean 的引用。这些引用也被称作协作器和依赖。</li>
<li>在一个新创建的对象中的其他配置设置 - 例如，池的数量限制或者一个操作连接池 bean 中的连接数量</li>
</ul>
<p>这些元数据转换为构成这些 bean 定义的一系列属性。下表表示了这些属性值：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Class</td>
<td>正在实例化的bean</td>
</tr>
<tr>
<td>Name</td>
<td>bean的名字</td>
</tr>
<tr>
<td>Scope</td>
<td>Bean的Scope</td>
</tr>
<tr>
<td>构造函数参数</td>
<td>依赖注入</td>
</tr>
<tr>
<td>自动装配模式</td>
<td>装配的协作对象</td>
</tr>
<tr>
<td>懒加载模式</td>
<td>懒加载 Bean</td>
</tr>
<tr>
<td>初始化方法</td>
<td>初始化回调</td>
</tr>
<tr>
<td>析构方法</td>
<td>析构回调</td>
</tr>
</tbody>
</table>
<p>除了包含怎么创建一个特定的 bean 的信息之外， <code>ApplicationContext</code> 的实现同样允许在容器外面已经创建好的对象注册到其中（用户创建）。这是通过 <code>getBeanFactory</code> 方法获取到 <code>ApplicationContext</code> 的 <code>BeanFactory</code>，得到 <code>DefaultListableBeanFactory</code> 实现来做到的。<code>DefaultListableBeanFactory</code> 支持通过调用 <code>registerSingleton(..)</code>  和 <code>registerBeanDefinition(..)</code> 方法来实现这样的注册。然而，典型的应用程序仅仅使用常规的 bean 定义元数据。</p>
<p>Note：bean 的元数据和手工提供的单例对象，需要被尽可能早地注册，以便容器在自动装配期间和其他内省的步骤中，可以对他们做出合理的推断。尽管覆盖现有的元数据和单例对象在某种程度上可以支持，但是官方并不支持在运行时注册新的 bean，这很可能会导致并发获取的异常，bean 容器中不一致的状态，或者两者都有。</p>
<h1 id="bean-命名">Bean 命名</h1>
<p>每个 bean 都有至少一个标识。这些标识必须在持有 bean 的容器中保持唯一。一个 bean 通常仅有一个标识。然而，如果需要不止一个，额外的可以被认为是别名。</p>
<p>在基于 XML 的配置元数据中，你可以使用 id 属性，name 属性或者两者一起确定唯一的 bean。id 属性让你确定唯一的一个 id。按照习惯，这些名字都由字母或者数字组成，但是他们也可以包含特殊字符。如果你想对这些 bean 引入其他的别名，你也可以通过使用 <code>,</code> <code>;</code> <code>空格</code> 作为分隔符的 name 属性。尽管 id属性已经被定义为 xsd:string 类型，容器中还是bean 的 id 唯一性是由容器强制执行的，而不是通过 XML 解析器。</p>
<p>对一个 bean 提供 name 或者 id 属性并不是必须的。如果你不希望显式地提供 name 或者 id，容器会对这个 bean 生成一个唯一的名字。但是，如果你想通过名字引用这个 bean，通过 ref 元素或者 Service Locator 的模式来找，你必须提供 name 属性。在使用内部的 bean 或者自动装配时，可以不提供 name 属性。</p>
<blockquote>
<p>Bean 名字惯例</p>
<p>当给一个 bean 命名时，惯例是使用标准 Java 实例中对成员变量名。这也就是 bean 的名字必须以一个小写字母开始，并且是驼峰的形式。这样的例子如：<code>accountManager</code>，<code>accountService</code>，<code>userDao</code>，<code>loginController</code> 等等。</p>
<p>对 bean 命名的一致性，可以使你的配置更易读且易懂。而且，如果你使用 Spring 的 AOP 机制，当通过名字来对一系列 bean 提供一个 bean 是非常有用的。</p>
</blockquote>
<p>Note：当在 classpath 下进行 component 扫描时，Spring 会遵循前面描述的规则对没有命名的 component 生成名字：实质上，就是采用一个简单的类名，并且把首字母变为小写。然而，在不止包含一个字母并且首字母和第二个字母都大写的特殊情形下，原来的就会被继续保留。这些规则与 <code>java.beans.Introspector.decapitalize</code> 中定义的相同（Spring 把他们用在这里了）。</p>
<h1 id="对在-beandefinition-之外的-bean-起别名">对在 BeanDefinition 之外的 bean 起别名</h1>
<p>在 bean 定义自身中个，你可以通过使用 id 属性和在 name 属性中定义任意数量的名字对 bean 提供不止一个名字。这些名字相当于 bean 的别名，在某些情况下比较有用，例如，让应用程序中的每一个 component 都通过使用相对于这个 component 中的特定的 bean 名称来引用一个相同的依赖。</p>
<p>但是，在 bean 实际上被定义的地方里设置所有的别名，并不总是合适的。当这个 bean 在别的地方也定义的时候，有时候需要引入这个 bean 的别名。这在一个配置文件跨越多个子系统的大系统时且每个子系统都有自己的一套 bean 定义时，是非常常见的。在基于 XML 的配置元数据中，你可以使用 <code>&lt;alias/&gt;</code> 元素来完成这项任务。下面的例子表示了怎么使用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-XML" data-lang="XML"><span class="line"><span class="cl"><span class="nt">&lt;alias</span> <span class="na">name=</span><span class="s">&#34;fromName&#34;</span> <span class="na">alias=</span><span class="s">&#34;toName&#34;</span><span class="nt">/&gt;</span>
</span></span></code></pre></div><p>在这个例子中，一个叫 <code>fromName</code> 的 bean，在使用这个别名定义后，也可以通过 <code>toName</code> 来引用到。</p>
<p>例如，对子系统 A 中的配置元数据，可以通过 <code>subsystemA-dataSource</code> 引用到 DataSrouce。在子系统 B 中也可以通过使用 <code>subsystemB-dataSource</code> 引用到。当构成一个同时使用到这两个子系统的主应用程序时，主应用程序可以通过 <code>myApp-dataSource</code> 名字来引用到 DataSource。你可以在配置元数据中增加下面的别名定义，来使所有三个名字引用到相同的对象：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-XML" data-lang="XML"><span class="line"><span class="cl"><span class="nt">&lt;alias</span> <span class="na">name=</span><span class="s">&#34;myApp-dataSource&#34;</span> <span class="na">alias=</span><span class="s">&#34;subsystemA-dataSource&#34;</span><span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;alias</span> <span class="na">name=</span><span class="s">&#34;myApp-dataSource&#34;</span> <span class="na">alias=</span><span class="s">&#34;subsystemB-dataSource&#34;</span><span class="nt">/&gt;</span>
</span></span></code></pre></div><p>现在每一个 component 和主应用都可以通过一个唯一且不与其他 bean 定义冲突的名字引用到dataSource。，但他们都指向同一个 bean。</p>
<blockquote>
<p>Java 配置</p>
<p>如果你使用 Java 配置，@Bean 注解同样也可以用来提供别名。</p>
</blockquote>
<h1 id="bean-的实例化">Bean 的实例化</h1>
<p>一个 bean 定义本质上就是创建一个或者对个对象的菜谱。当容器被索要 bean 的时候，容器查看这个 bean 的菜谱，使用被 bean 定义封装好的配置元数据来创建一个真正的对象。</p>
<p>如果你使用 XML 配置元数据，你可以在 <bean/> 元素的 class 属性中，指定要实例化对象的类型或者（类名）。这个 class 属性通常是强制的（通常是 BeanDefinition 实例中的 Class 属性）。你可以使用下面两种方法之一来使用 Class 属性：</p>
<ul>
<li>
<p>通常，在容器本身直接通过反射调用构造函数创建 bean 的地方，直接指定要被构建的类，在某种程度上相当于在 Java 代码中使用new 操作符</p>
</li>
<li>
<p>通过指定包含创建这个对象静态工厂方法的类，容器调用这个类的静态工厂方法创建 bean，这是一个不太常见的用法。静态工厂方法返回的对象类型也许和此类相同或者完全不同</p>
</li>
</ul>
<blockquote>
<p>嵌套的类名</p>
<p>如果你想对一个嵌套类定义配置 bean 定义，你可以使用这个嵌套类的二进制名或者源文件名</p>
<p>例如，如果在 <code>com.example</code> 包里有一个类叫 <code>SomeThing</code>，并且这个 <code>SomeThing</code> 类有一个叫 <code>OtherThing</code> 的静态嵌套类，他们可以通过 <code>$</code> 或者 <code>.</code> 符号分割，所以 bean 定义中的 <code>class</code> 属性值会是：<code>com.example.SomeThing$OtherThing</code> 或者 <code>com.example.SomeThing.OtherThing</code>.</p>
</blockquote>
<h1 id="通过构造器实例化">通过构造器实例化</h1>
<p>当你通过构造器的方式来创建 bean，所有普通类都可以被使用并且与 Spring 兼容。也就是说，正在被开发的类没必要实现任何特殊的接口或者用一种特殊的方式编码。只需要指定 bean 的类就足够了。然而，根据你为了创建特定 bean 选择的 IoC类型，你也许会需要一个默认（空的）构造器。</p>
<p>Spring IoC 容器几乎可以操作任何你想操作的类。并不仅限于操作真正的 JavaBean。大部分 Spring 的用户更偏爱使用只包含一个无参构造器，合适的 setter 和 getter 建模的 JavaBean。你也可以在你的容器中使用更多的非 bean 风格的类。例如，如果你需要使用一个遗留下来的绝对没有遵循  JavaBean 规范的连接池，Spring 同样操作它。</p>
<p>在下面的基于 XML 配置元数据例子中，你可以指定你的 bean 类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-XML" data-lang="XML"><span class="line"><span class="cl"><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&#34;exampleBean&#34;</span> <span class="na">class=</span><span class="s">&#34;examples.ExampleBean&#34;</span><span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nt">&lt;bean</span> <span class="na">name=</span><span class="s">&#34;anotherExample&#34;</span> <span class="na">class=</span><span class="s">&#34;examples.ExampleBeanTwo&#34;</span><span class="nt">/&gt;</span>
</span></span></code></pre></div><h1 id="通过静态方法实例化">通过静态方法实例化</h1>
<p>当定义一个你想通过静态工厂方法创建的 bean 时，需要使用 <code>class</code> 属性指定包含这个静态工厂方法的类，使用 <code>factory-method</code> 属性，指定这个工厂方法本身。你能够调用这个方法（通过可选参数，这个待马上会讲到）返回一个对象，随后，这个对象看做是通过构造函数创建的。这样定义 bean 的一个使用场景就是调用遗留代码中的静态工厂。</p>
<p>下面的 bean 定义，指定了将要通过工厂方法创建的 bean。这个定义不会指定返回对象的类型，而是指定包含静态方法的类。在这个例子中，<code>createInstance()</code> 方法必须是一个静态方法。下面的例子展示了怎么去指定一个工厂方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-XML" data-lang="XML"><span class="line"><span class="cl"><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&#34;clientService&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="na">class=</span><span class="s">&#34;examples.ClientService&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="na">factory-method=</span><span class="s">&#34;createInstance&#34;</span><span class="nt">/&gt;</span>
</span></span></code></pre></div><p>下面的例子展示了一个上面 bean 定义用到的类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ClientService</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">private</span> <span class="kd">static</span> <span class="n">ClientService</span> <span class="n">clientService</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ClientService</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">	<span class="kd">private</span> <span class="nf">ClientService</span><span class="o">()</span> <span class="o">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">public</span> <span class="kd">static</span> <span class="n">ClientService</span> <span class="nf">createInstance</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">clientService</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>想了解关于如何给工厂方法传参并且在工厂返回的对象中设置对象实例的属性的细节，可以参考 <a href="https://docs.spring.io/spring-framework/reference/core/beans/dependencies/factory-properties-detailed.html">Dependencies and Configuration in Detail.</a>。</p>
<h1 id="通过实例的工厂方法">通过实例的工厂方法</h1>
<p>与通过静态工厂方法实例化相似，通过实例的工厂方法调用一个容器中一个现有 bean 的非静态方法来创建一个新的 bean。要想使用这个机制，需要将 <code>class</code> 属性置空并且在 <code>factory-bean</code> 属性指定当前容器（父容器或者祖父容器）中的 bean 的名称，此 bean 包含创建对象实例的方法。在 <code>factory-method</code> 属性中设置工厂方法本身的名字。下面的例子展示了如何配置这样一个 bean：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-XML" data-lang="XML"><span class="line"><span class="cl"><span class="c">&lt;!-- the factory bean, which contains a method called createInstance() --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&#34;serviceLocator&#34;</span> <span class="na">class=</span><span class="s">&#34;examples.DefaultServiceLocator&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">	<span class="c">&lt;!-- inject any dependencies required by this locator bean --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/bean&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c">&lt;!-- the bean to be created via the factory bean --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&#34;clientService&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="na">factory-bean=</span><span class="s">&#34;serviceLocator&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="na">factory-method=</span><span class="s">&#34;createClientServiceInstance&#34;</span><span class="nt">/&gt;</span>
</span></span></code></pre></div><p>下面的例子展示了与之相应的类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DefaultServiceLocator</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">private</span> <span class="kd">static</span> <span class="n">ClientService</span> <span class="n">clientService</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ClientServiceImpl</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">public</span> <span class="n">ClientService</span> <span class="nf">createClientServiceInstance</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">clientService</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>一个工厂类，同样也可以包含更多的工厂方法，如下面的例子所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-XML" data-lang="XML"><span class="line"><span class="cl"><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&#34;serviceLocator&#34;</span> <span class="na">class=</span><span class="s">&#34;examples.DefaultServiceLocator&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">	<span class="c">&lt;!-- inject any dependencies required by this locator bean --&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/bean&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&#34;clientService&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="na">factory-bean=</span><span class="s">&#34;serviceLocator&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="na">factory-method=</span><span class="s">&#34;createClientServiceInstance&#34;</span><span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&#34;accountService&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="na">factory-bean=</span><span class="s">&#34;serviceLocator&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="na">factory-method=</span><span class="s">&#34;createAccountServiceInstance&#34;</span><span class="nt">/&gt;</span>
</span></span></code></pre></div><p>下面的例子展示了与之相对应的类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DefaultServiceLocator</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">private</span> <span class="kd">static</span> <span class="n">ClientService</span> <span class="n">clientService</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ClientServiceImpl</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">private</span> <span class="kd">static</span> <span class="n">AccountService</span> <span class="n">accountService</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AccountServiceImpl</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">public</span> <span class="n">ClientService</span> <span class="nf">createClientServiceInstance</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">clientService</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">public</span> <span class="n">AccountService</span> <span class="nf">createAccountServiceInstance</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">accountService</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>这个方法展示了工厂 bean 本身是可以通过依赖注入机制被设置和配置的。</p>
<p>Note：在 Spring 的文档中，&ldquo;factory bean&rdquo; 指的是一个在 Spring 容器中配置好并且通过实例或者静态工厂方法创建好的 bean。与之相对比，<code>FactoryBean</code>（注意首字母），指的是一个 Spring 特定的 <code>FactoryBean</code> 的实现类。</p>
<h1 id="确定一个-bean-的运行时类名">确定一个 bean 的运行时类名</h1>
<p>确定一个特定的bean的运行时类型并非易事。一个在 bean 元数据定义中指定的类仅仅是一个可能与一个声明的工厂方法组合的初始类引用，或者是一个会
让此 bean 的运行时类型完全不同的 FactoryBean 类，或者在实例级别的工厂方法（通过指定的 factory-bean 来解决）什么也不做。此外，AOP 代理也会通过bean 接口代理来包装一个bean实例，此接口代理会有限地暴露目标bean的实际类型（仅仅是已经实现的接口）。</p>
<p>找出一个特定 bean 的实际运行时类型的推荐的方法是通过指定 bean 名字，调用 <code>BeanFactory.getType</code> 方法。这种方法将上面所有的情形考虑在内，并且返回对象的类型，此对象也是在相同名称下，调用 <code>BeanFactory.getBean</code> 方法会返回的。</p>
<p>[全文完]</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>[译] Spring IOC 容器</title>
      <link>https://anriclee.github.io/posts/springframework/core/the_ioc_container/container_and_beans/</link>
      <pubDate>Sat, 02 Sep 2023 23:12:31 +0800</pubDate>
      
      <guid>https://anriclee.github.io/posts/springframework/core/the_ioc_container/container_and_beans/</guid>
      <description>Spring IOC 和 bean 的简介 本章涵盖了 SpringFramework 中的控制反转原则（Ioc）的实现。IoC 也被称为依赖注入（DI）。它是这样的一种过程，在此期间对象仅通过构造函数参数、工厂方法的参数或者当对象实例被构造后或者通过工厂方法返回时在它上面设置的属性定义自己的依赖（即对象必须合作的其他对象）。
当容器创建这些 bean 后，再注入这些依赖。
这个过程本质上与bean 通过使用直接的类构造函数进行直接实例化或者通过类似 Service Locator模式来寻找依赖的位置是相反的（这也是 IoC 名字的由来）。
org.springframework.beans 和 org.springframework.context 包是 SpringFramework IoC 容器的基石。BeanFactory 接口提供了一种更先进的能够控制人已类型对象的配置机制。ApplicationContext 是 BeanFactory 的子接口。它增加了下面的特性：
与 Spring 的 AOP 特性更容易整合 消息资源处理（在国际化场景的使用） 事件发布 例如用于 Web 应用的 WebApplicationContext 应用层特定的上下文 总而言之，BeanFactory 提供了配置的框架和基本的功能。ApplicationContext 增加了更多的企业特定的功能。ApplicationContext 完全是 BeanFactory 的超集。在本章关于 Spring IoC 容器做专门描述时会用到。想要获取更多的关于使用 ApplicationContext 而非 BeanFactory 的信息，参见介绍 BeanFactory API 的部分。
在 Spring 中，作为你应用基石同时可以被 Spring IoC 容器所操控的对象就被称之为 bean。bean 就是被 Spring IoC 容器实例化、组装和设置的对象。否则，一个 bean 就是你应用程序中诸多对象中的一个。 Beans 以及他们依赖关系，反映在容器使用的配置元数据中。</description>
      <content:encoded><![CDATA[<h1 id="spring-ioc-和-bean-的简介">Spring IOC 和 bean 的简介</h1>
<p>本章涵盖了 SpringFramework 中的控制反转原则（Ioc）的实现。IoC 也被称为依赖注入（DI）。它是这样的一种过程，在此期间对象仅通过构造函数参数、工厂方法的参数或者当对象实例被构造后或者通过工厂方法返回时在它上面设置的属性定义自己的依赖（即对象必须合作的其他对象）。</p>
<p>当容器创建这些 bean 后，再注入这些依赖。</p>
<p>这个过程本质上与bean 通过使用直接的类构造函数进行直接实例化或者通过类似 Service Locator模式来寻找依赖的位置是相反的（这也是 IoC 名字的由来）。</p>
<p><code>org.springframework.beans</code> 和 <code>org.springframework.context</code> 包是 SpringFramework IoC 容器的基石。<code>BeanFactory</code> 接口提供了一种更先进的能够控制人已类型对象的配置机制。<code>ApplicationContext</code> 是 <code>BeanFactory</code> 的子接口。它增加了下面的特性：</p>
<ul>
<li>与 Spring 的 AOP 特性更容易整合</li>
<li>消息资源处理（在国际化场景的使用）</li>
<li>事件发布</li>
<li>例如用于 Web 应用的 <code>WebApplicationContext</code> 应用层特定的上下文</li>
</ul>
<p>总而言之，<code>BeanFactory</code> 提供了配置的框架和基本的功能。<code>ApplicationContext</code> 增加了更多的企业特定的功能。<code>ApplicationContext</code> 完全是 <code>BeanFactory</code> 的超集。在本章关于 Spring IoC 容器做专门描述时会用到。想要获取更多的关于使用 <code>ApplicationContext</code> 而非 <code>BeanFactory</code> 的信息，参见介绍 <a href="https://docs.spring.io/spring-framework/reference/core/beans/beanfactory.html">BeanFactory</a> API 的部分。</p>
<p>在 Spring 中，作为你应用基石同时可以被 Spring IoC 容器所操控的对象就被称之为 bean。bean 就是被 Spring IoC 容器实例化、组装和设置的对象。否则，一个 bean 就是你应用程序中诸多对象中的一个。 Beans 以及他们依赖关系，反映在容器使用的配置元数据中。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>[译] 依赖注入</title>
      <link>https://anriclee.github.io/posts/springframework/core/the_ioc_container/dependencies/dependency_injection/</link>
      <pubDate>Sat, 02 Sep 2023 23:12:31 +0800</pubDate>
      
      <guid>https://anriclee.github.io/posts/springframework/core/the_ioc_container/dependencies/dependency_injection/</guid>
      <description>在依赖注入（DI）里，对象通过构造函数参数、工厂方法参数或者在 被工厂方法创建返回的对象中设置的属性定义他们的依赖。然后，容器在创建这些 bean 时，注入依赖。这个过程与 bean 自身使用所需要类的直接构造函数实例化，或者通过 Service Locator 模式来找到所需要的依赖这个过程正好相反。
使用 DI 原则的代码更加干净整洁，并且提供给对象的依赖时，解耦也更加高效。对象并不找他们的依赖也并不知道这些依赖的地址或者类。这样的结果就是，你的类变得更易测试，尤其是当依赖是接口或者抽象的父类时，在单元测试可以对这些依赖进行打桩或者mock他们的实现。
基于构造函数的依赖注入 基于构造函数的依赖注入，是通过容器调用构造函数，并且传入若干参数来实现的，每一个参数都代表了一个依赖。调用静态工厂方法并传入特定的参数来构造一个 bean 也是一样的，在本讨论中，对待构造函数的参数和静态方法的参数也是相似的。下面的这里展示了一个之能通过构造函数来进行依赖注入的类：
public class SimpleMovieLister { // the SimpleMovieLister has a dependency on a MovieFinder private final MovieFinder movieFinder; // a constructor so that the Spring container can inject a MovieFinder public SimpleMovieLister(MovieFinder movieFinder) { this.movieFinder = movieFinder; } // business logic that actually uses the injected MovieFinder is omitted... } 注意，对于这个类没有更多特殊的地方。它仅仅是一个POJO，并且对容器特定接口、父类或者注解没有任何依赖。【译者按：没有任何代码侵入性】
构造函数参数解析 构造函数参数解析匹配通过参数类型来进行。如果在构造函数参数的 bean 定义中没有歧义，那么在 bean 定义中构造函数参数的顺序，就是当 bean 被实例化时，传给给构造函数参数的顺序。考虑下面的类：</description>
      <content:encoded><![CDATA[<p>在依赖注入（DI）里，对象通过构造函数参数、工厂方法参数或者在
被工厂方法创建返回的对象中设置的属性定义他们的依赖。然后，容器在创建这些 bean 时，注入依赖。这个过程与 bean 自身使用所需要类的直接构造函数实例化，或者通过 Service Locator 模式来找到所需要的依赖这个过程正好相反。</p>
<p>使用 DI 原则的代码更加干净整洁，并且提供给对象的依赖时，解耦也更加高效。对象并不找他们的依赖也并不知道这些依赖的地址或者类。这样的结果就是，你的类变得更易测试，尤其是当依赖是接口或者抽象的父类时，在单元测试可以对这些依赖进行打桩或者mock他们的实现。</p>
<h1 id="基于构造函数的依赖注入">基于构造函数的依赖注入</h1>
<p>基于构造函数的依赖注入，是通过容器调用构造函数，并且传入若干参数来实现的，每一个参数都代表了一个依赖。调用静态工厂方法并传入特定的参数来构造一个 bean 也是一样的，在本讨论中，对待构造函数的参数和静态方法的参数也是相似的。下面的这里展示了一个之能通过构造函数来进行依赖注入的类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimpleMovieLister</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// the SimpleMovieLister has a dependency on a MovieFinder
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">private</span> <span class="kd">final</span> <span class="n">MovieFinder</span> <span class="n">movieFinder</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// a constructor so that the Spring container can inject a MovieFinder
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">public</span> <span class="nf">SimpleMovieLister</span><span class="o">(</span><span class="n">MovieFinder</span> <span class="n">movieFinder</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">this</span><span class="o">.</span><span class="na">movieFinder</span> <span class="o">=</span> <span class="n">movieFinder</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// business logic that actually uses the injected MovieFinder is omitted...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span></code></pre></div><p>注意，对于这个类没有更多特殊的地方。它仅仅是一个POJO，并且对容器特定接口、父类或者注解没有任何依赖。【译者按：没有任何代码侵入性】</p>
<h2 id="构造函数参数解析">构造函数参数解析</h2>
<p>构造函数参数解析匹配通过参数类型来进行。如果在构造函数参数的 bean 定义中没有歧义，那么在 bean 定义中构造函数参数的顺序，就是当 bean 被实例化时，传给给构造函数参数的顺序。考虑下面的类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nn">x.y</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThingOne</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">public</span> <span class="nf">ThingOne</span><span class="o">(</span><span class="n">ThingTwo</span> <span class="n">thingTwo</span><span class="o">,</span> <span class="n">ThingThree</span> <span class="n">thingThree</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>假设 <code>ThingTwo</code> 和 <code>ThingThree</code> 不是继承关系，并且没有歧义。你不需要指定在 <constructor-arg/> 元素中的顺序或者类型，下面的配置一样会正常起作用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-XML" data-lang="XML"><span class="line"><span class="cl"><span class="nt">&lt;beans&gt;</span>
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&#34;beanOne&#34;</span> <span class="na">class=</span><span class="s">&#34;x.y.ThingOne&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">		<span class="nt">&lt;constructor-arg</span> <span class="na">ref=</span><span class="s">&#34;beanTwo&#34;</span><span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl">		<span class="nt">&lt;constructor-arg</span> <span class="na">ref=</span><span class="s">&#34;beanThree&#34;</span><span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;/bean&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&#34;beanTwo&#34;</span> <span class="na">class=</span><span class="s">&#34;x.y.ThingTwo&#34;</span><span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&#34;beanThree&#34;</span> <span class="na">class=</span><span class="s">&#34;x.y.ThingThree&#34;</span><span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/beans&gt;</span>
</span></span></code></pre></div><p>当引用另外一个 bean 的时候，类型已知，即可以适配到。当使用一个简单的类型时，例如 <code>&lt;value&gt;true&lt;/value&gt;</code> ，Spring 不能决定一个 value 的类型，因此不能在没有任何帮助时，适配到具体的类型。考虑下面的类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nn">examples</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExampleBean</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Number of years to calculate the Ultimate Answer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">years</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// The Answer to Life, the Universe, and Everything
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">ultimateAnswer</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">public</span> <span class="nf">ExampleBean</span><span class="o">(</span><span class="kt">int</span> <span class="n">years</span><span class="o">,</span> <span class="n">String</span> <span class="n">ultimateAnswer</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">this</span><span class="o">.</span><span class="na">years</span> <span class="o">=</span> <span class="n">years</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">this</span><span class="o">.</span><span class="na">ultimateAnswer</span> <span class="o">=</span> <span class="n">ultimateAnswer</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>在上面的场景中，如果你通过 <code>type</code> 属性显式地指定一个构造函数参数类型，容器就可以使用简单的类型匹配，如下面的例子所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-XML" data-lang="XML"><span class="line"><span class="cl"><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&#34;exampleBean&#34;</span> <span class="na">class=</span><span class="s">&#34;examples.ExampleBean&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;constructor-arg</span> <span class="na">type=</span><span class="s">&#34;int&#34;</span> <span class="na">value=</span><span class="s">&#34;7500000&#34;</span><span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;constructor-arg</span> <span class="na">type=</span><span class="s">&#34;java.lang.String&#34;</span> <span class="na">value=</span><span class="s">&#34;42&#34;</span><span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/bean&gt;</span>
</span></span></code></pre></div><p>你可以使用 index 属性指定构造函数参数的顺序，如下面的例子所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-XML" data-lang="XML"><span class="line"><span class="cl"><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&#34;exampleBean&#34;</span> <span class="na">class=</span><span class="s">&#34;examples.ExampleBean&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;constructor-arg</span> <span class="na">index=</span><span class="s">&#34;0&#34;</span> <span class="na">value=</span><span class="s">&#34;7500000&#34;</span><span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;constructor-arg</span> <span class="na">index=</span><span class="s">&#34;1&#34;</span> <span class="na">value=</span><span class="s">&#34;42&#34;</span><span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/bean&gt;</span>
</span></span></code></pre></div><p>Note: index 从 0 开始。</p>
<p>你也可以使用构造函数参数名来消除歧义，如下面的例子所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-XML" data-lang="XML"><span class="line"><span class="cl"><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&#34;exampleBean&#34;</span> <span class="na">class=</span><span class="s">&#34;examples.ExampleBean&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;constructor-arg</span> <span class="na">name=</span><span class="s">&#34;years&#34;</span> <span class="na">value=</span><span class="s">&#34;7500000&#34;</span><span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;constructor-arg</span> <span class="na">name=</span><span class="s">&#34;ultimateAnswer&#34;</span> <span class="na">value=</span><span class="s">&#34;42&#34;</span><span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/bean&gt;</span>
</span></span></code></pre></div><p>需要记住的是，为了开箱即用的效果，你的代码必须在编译时将 debug 标识打开，以便 Spring 可以通过名字从构造器查看参数名。如果你不能或者不想再编译时把 debug 标志打开，你可以使用 @ConstructorProperties JDK 注解对构造函数参数显式地指定名字。下面的例子展示了示例类的样子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nn">examples</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExampleBean</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Fields omitted
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nd">@ConstructorProperties</span><span class="o">({</span><span class="s">&#34;years&#34;</span><span class="o">,</span> <span class="s">&#34;ultimateAnswer&#34;</span><span class="o">})</span>
</span></span><span class="line"><span class="cl">	<span class="kd">public</span> <span class="nf">ExampleBean</span><span class="o">(</span><span class="kt">int</span> <span class="n">years</span><span class="o">,</span> <span class="n">String</span> <span class="n">ultimateAnswer</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">this</span><span class="o">.</span><span class="na">years</span> <span class="o">=</span> <span class="n">years</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">this</span><span class="o">.</span><span class="na">ultimateAnswer</span> <span class="o">=</span> <span class="n">ultimateAnswer</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h1 id="基于-setter-函数的依赖注入">基于 Setter 函数的依赖注入</h1>
<p>基于 Setter 的依赖注入，是通过容器在调用无参构造函数或者无参静态工厂方法来实例化 bean 之后，调用 bean 中的 setter 方法来完成的。</p>
<p>下面的例子展示了一个类可以仅通过单纯的 setter 注入完成依赖注入。这个类是传统的 Java。这是一个对具体的接口，基类或者注解没有依赖的 POJO。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimpleMovieLister</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// the SimpleMovieLister has a dependency on the MovieFinder
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">private</span> <span class="n">MovieFinder</span> <span class="n">movieFinder</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// a setter method so that the Spring container can inject a MovieFinder
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setMovieFinder</span><span class="o">(</span><span class="n">MovieFinder</span> <span class="n">movieFinder</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">this</span><span class="o">.</span><span class="na">movieFinder</span> <span class="o">=</span> <span class="n">movieFinder</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// business logic that actually uses the injected MovieFinder is omitted...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span>
</span></span></code></pre></div><p><code>ApplicationContext</code> 支持对其管理的 bean，进行基于构造函数和setter函数的依赖注入。它同样也支持通过构造函数已经注入后，基于 setter 的依赖注入。你用 BeanDefinition 的形式配置了依赖，结合 <code>PropertyEditor</code> 实例，将属性值从一种形式转换为另外一种形式，然而，大部分 Spring 的用户不是直接使用这些类（即，代码的方式），而是使用 XML bean 定义，注解组件（即，有 <code>@Component</code> 和 <code>@Controller</code> 等等装配的类）或者在基于 Java @Configuration 类的 @Bean 方法。这些源在内部被转换成 BeanDefinition 实例，并且被用来加载整个 Spring IoC 容器实例。</p>
<blockquote>
<p>基于构造函数或者基于 setter 的依赖注入？</p>
<p>因为你可以混合基于构造函数和基于Setter的依赖注入，对必要的依赖使用构造函数，对可选依赖使用 Setter 方法或者配置方法是一个很好的经验法则。注意，在 setter 方法上使用 @Autowired 注解可以用来使这个属性成为一个必要的依赖；然而，通过构造函数注入，并且在代码中验证参数的有效性是值得考虑的。</p>
<p>Spring 团队通常提倡构造函数的依赖注入，因为这会让你将应用程序的组件实现为不可变对象，并且能够确保必要的依赖是非空的。而且，通过构造函数注入返回的组件是一个完全初始化的状态。一个数量较多参数的构造函数，是一种坏味道，暗示着这个类很可能有诸多的职责，应该需要重构，以更好地解决适当的关注点分离的问题。</p>
<p>基于 Setter 的注入，应该仅被用于可以被赋予默认值的可选依赖。否则，非空检测，必须在使用依赖的任何地方进行。setter 注入的好处之一是 setter 方法使该类的对象可以在以后重新配置或重新注入。因此，通过 JMX MBean 进行管理是 setter 注入的一个引人注目的用例。</p>
<p>使用 DI 风格对一些类具有最重要的意义。有时候，当处理你没有源码的第三方类的时候，这是你的选择。例如，如果一个三方类没有暴露任何 setter 方法，构造函数的注入或许会是依赖注入的唯一形式。</p>
</blockquote>
<h1 id="依赖的解决过程">依赖的解决过程</h1>
<h1 id="依赖注入的例子">依赖注入的例子</h1>
<p>TO BE CONTINUED</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>[译] 容器概述</title>
      <link>https://anriclee.github.io/posts/springframework/core/the_ioc_container/container_overview/</link>
      <pubDate>Sat, 02 Sep 2023 23:12:31 +0800</pubDate>
      
      <guid>https://anriclee.github.io/posts/springframework/core/the_ioc_container/container_overview/</guid>
      <description>容器概述 org.springframework.context.ApplicationContext 接口代表了 Spring IoC 容器，它主要负责通过读取配置文件对 bean 进行实例化、配置和组装。 容器通过读取配置元数据来获知要实例化、配置和组装那些对象。配置的元数据一般为 XML、Java 注解和 Java 代码的形式，它让你能够表达组成你应用程序的对象以及对象之间的丰富的相互依赖关系。
Spring 提供了 ApplicationContext 接口的若干实现。在单体应用中，创建一个 ClassPathXmlApplicationContext 或者 FileSystemXmlApplicationContext 是很常见的。虽然 XML 是定义配置元数据的传统形式，但是你还可以通过在 XML 文件里面进行声明配置来告诉容器对于 Java 注解或者Java代码格式的支持。
在大多数的应用场景中，并不需要显式的代码来实例化 Spring IoC 容器。例如，在 Web 应用的场景中，在 web.xml 文件中仅用简单的 8 行代码左右的样板 Web XML 描述符即可满足需要（参考 Convenient ApplicationContext Instantiation for Web Applications）。如果你使 Eclipse 中的 Spring 工具（在 Eclipse 开发环境中），你可以通过几下鼠标点击或者按键的敲击就能轻松创建这样一个样板配置文件。
下图展示了关于 Spring 工作机制的一个全局视角。在 ApplicationContext 被创建和初始化后，你的应用类和配置元数据已经捆绑在一起了，这样一来，你就有一个充分配置并且可执行的系统或者应用程序。
配置元数据 如上图所示，Spring Ioc 容器接收到一种格式的配置元数据。这个配置元数据代表了，作为一个应用开发者你告诉 Spring 容器在应用程序中，如何实例化、配置和组装对象。
传统的配置元数据是一种简单并且符合直觉的 XML 形式，在本章的大部分地方，也用此来表达关键的概念和 Spring IoC 容器的特性。
基于 XML 的元数据不是配置元数据的唯一允许的形式。Spring IoC 容器自身与配置元数据实际上是什么格式完全解耦。目前许多开发者在应用程序中选择基于Java 的配置。</description>
      <content:encoded><![CDATA[<h1 id="容器概述">容器概述</h1>
<p><code>org.springframework.context.ApplicationContext</code> 接口代表了 Spring IoC 容器，它主要负责通过读取配置文件对 bean 进行实例化、配置和组装。
容器通过读取配置元数据来获知要实例化、配置和组装那些对象。配置的元数据一般为 XML、Java 注解和 Java 代码的形式，它让你能够表达组成你应用程序的对象以及对象之间的丰富的相互依赖关系。</p>
<p>Spring 提供了 <code>ApplicationContext</code> 接口的若干实现。在单体应用中，创建一个 <code>ClassPathXmlApplicationContext</code> 或者 <code>FileSystemXmlApplicationContext</code> 是很常见的。虽然 XML 是定义配置元数据的传统形式，但是你还可以通过在 XML 文件里面进行声明配置来告诉容器对于 Java 注解或者Java代码格式的支持。</p>
<p>在大多数的应用场景中，并不需要显式的代码来实例化 Spring IoC 容器。例如，在 Web 应用的场景中，在 <code>web.xml</code> 文件中仅用简单的 8 行代码左右的样板 Web XML 描述符即可满足需要（参考 <a href="https://docs.spring.io/spring-framework/reference/core/beans/context-introduction.html#context-create">Convenient ApplicationContext Instantiation for Web Applications</a>）。如果你使 Eclipse 中的 Spring 工具（在 Eclipse 开发环境中），你可以通过几下鼠标点击或者按键的敲击就能轻松创建这样一个样板配置文件。</p>
<p>下图展示了关于 Spring 工作机制的一个全局视角。在 <code>ApplicationContext</code> 被创建和初始化后，你的应用类和配置元数据已经捆绑在一起了，这样一来，你就有一个充分配置并且可执行的系统或者应用程序。</p>
<p><img loading="lazy" src="/posts/springframework/core/the_ioc_container/container_overview/imgs/ioc.png" type="" alt="Spring"  /></p>
<h1 id="配置元数据">配置元数据</h1>
<p>如上图所示，Spring Ioc 容器接收到一种格式的配置元数据。这个配置元数据代表了，作为一个应用开发者你告诉 Spring 容器在应用程序中，如何实例化、配置和组装对象。</p>
<p>传统的配置元数据是一种简单并且符合直觉的 XML 形式，在本章的大部分地方，也用此来表达关键的概念和 Spring IoC 容器的特性。</p>
<blockquote>
<p>基于 XML 的元数据不是配置元数据的唯一允许的形式。Spring IoC 容器自身与配置元数据实际上是什么格式完全解耦。目前许多开发者在应用程序中选择<a href="https://docs.spring.io/spring-framework/reference/core/beans/java.html">基于Java 的配置</a>。</p>
</blockquote>
<p>在 Spring 容器中使用其他格式的配置元数据，可参考：</p>
<ul>
<li><a href="https://docs.spring.io/spring-framework/reference/core/beans/annotation-config.html">基于注解的配置</a>：通过基于注解的配置元数据定义 beans</li>
<li><a href="https://docs.spring.io/spring-framework/reference/core/beans/java.html">基于Java的配置</a>：通过使用 Java 而不是 XML 文件来定义你应用类之外的 beans。使用这些特性可以参考 <a href="https://docs.spring.io/spring-framework/docs/6.0.11/javadoc-api/org/springframework/context/annotation/Configuration.html">@Configuration</a>, <a href="https://docs.spring.io/spring-framework/docs/6.0.11/javadoc-api/org/springframework/context/annotation/Bean.html">@Bean</a>, <a href="https://docs.spring.io/spring-framework/docs/6.0.11/javadoc-api/org/springframework/context/annotation/Import.html">@Import</a>, <a href="https://docs.spring.io/spring-framework/docs/6.0.11/javadoc-api/org/springframework/context/annotation/DependsOn.html">@DependsOn</a> 注解。</li>
</ul>
<p>Spring 的配置由至少一个，通常为1个以上容器可以操作的 bean 组成。基于 XML 的配置元数据，配置顶部根元素 <beans/> 里面的 <bean/> 元素。Java 配置通常在一个 @Configuration 类里面使用 @Bean 注解方法。</p>
<p>这些 bean 的定义与组成你应用的实际对象相对应。通常地，你需要定义服务层对象，持久化层对象例如仓库或者数据接入对象（DAOs），例如 Web Controller 的表现层对象，例如一个 JPA EntityManagerFactory 的基础层对象，JMS 队列等等。通常不在容器里面对一个领域层对象进行精细化配置，因为创建和加载领域对象，通常是存储层和业务层的逻辑。</p>
<p>下面的例子，展示了基于 XML 的配置元数据的基本结构：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-XML" data-lang="XML"><span class="line"><span class="cl"><span class="cp">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;beans</span> <span class="na">xmlns=</span><span class="s">&#34;http://www.springframework.org/schema/beans&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="na">xmlns:xsi=</span><span class="s">&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="na">xsi:schemaLocation=</span><span class="s">&#34;http://www.springframework.org/schema/beans
</span></span></span><span class="line"><span class="cl"><span class="s">		https://www.springframework.org/schema/beans/spring-beans.xsd&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&#34;...&#34;</span> <span class="na">class=</span><span class="s">&#34;...&#34;</span><span class="nt">&gt;</span> [1][2]
</span></span><span class="line"><span class="cl">		<span class="c">&lt;!-- collaborators and configuration for this bean go here --&gt;</span>
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;/bean&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&#34;...&#34;</span> <span class="na">class=</span><span class="s">&#34;...&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">		<span class="c">&lt;!-- collaborators and configuration for this bean go here --&gt;</span>
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;/bean&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c">&lt;!-- more bean definitions go here --&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/beans&gt;</span>
</span></span></code></pre></div><p>[1]：id 属性唯一标识一个独立的 bean 定义
[2]：class 属性定义了 bean的类型，并且使用类的全限定名</p>
<p>id 属性的值可以被用来引用互相协作的对象。引用协作的对象的 XML并不在此例中，参考<a href="https://docs.spring.io/spring-framework/reference/core/beans/dependencies.html">依赖</a>部分获取更多的信息。</p>
<h1 id="初始化一个容器">初始化一个容器</h1>
<p>提供给 <code>ApplicationContext</code> 构造器的位置路径是一些表示资源的字符串，这些字符串可以让容器从各种外部资源加载配置元数据，例如本地文件系统，Java 类路径等等。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="n">ApplicationContext</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ClassPathXmlApplicationContext</span><span class="o">(</span><span class="s">&#34;services.xml&#34;</span><span class="o">,</span> <span class="s">&#34;daos.xml&#34;</span><span class="o">);</span>
</span></span></code></pre></div><p>在你了解了 Spring 的 IoC 容器后，你也许想对 Spring 的“资源：抽象了解更多，这提供了一种方便的从 URI 语法标识中读取输入流的机制。特别是 Resource 路径用于构建应用的上下文。</p>
<p>下面的例子展示了服务层的对象(services.xml)的配置文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-XML" data-lang="XML"><span class="line"><span class="cl"><span class="cp">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;beans</span> <span class="na">xmlns=</span><span class="s">&#34;http://www.springframework.org/schema/beans&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="na">xmlns:xsi=</span><span class="s">&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="na">xsi:schemaLocation=</span><span class="s">&#34;http://www.springframework.org/schema/beans
</span></span></span><span class="line"><span class="cl"><span class="s">		https://www.springframework.org/schema/beans/spring-beans.xsd&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c">&lt;!-- services --&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&#34;petStore&#34;</span> <span class="na">class=</span><span class="s">&#34;org.springframework.samples.jpetstore.services.PetStoreServiceImpl&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">		<span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&#34;accountDao&#34;</span> <span class="na">ref=</span><span class="s">&#34;accountDao&#34;</span><span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl">		<span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&#34;itemDao&#34;</span> <span class="na">ref=</span><span class="s">&#34;itemDao&#34;</span><span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl">		<span class="c">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span>
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;/bean&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c">&lt;!-- more bean definitions for services go here --&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/beans&gt;</span>
</span></span></code></pre></div><p>下面的例子展示了数据接入层(daos.xml)文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-XML" data-lang="XML"><span class="line"><span class="cl"><span class="cp">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;beans</span> <span class="na">xmlns=</span><span class="s">&#34;http://www.springframework.org/schema/beans&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="na">xmlns:xsi=</span><span class="s">&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="na">xsi:schemaLocation=</span><span class="s">&#34;http://www.springframework.org/schema/beans
</span></span></span><span class="line"><span class="cl"><span class="s">		https://www.springframework.org/schema/beans/spring-beans.xsd&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&#34;accountDao&#34;</span>
</span></span><span class="line"><span class="cl">		<span class="na">class=</span><span class="s">&#34;org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">		<span class="c">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span>
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;/bean&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&#34;itemDao&#34;</span> <span class="na">class=</span><span class="s">&#34;org.springframework.samples.jpetstore.dao.jpa.JpaItemDao&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">		<span class="c">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span>
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;/bean&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c">&lt;!-- more bean definitions for data access objects go here --&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/beans&gt;</span>
</span></span></code></pre></div><p>在上面的例子中，服务层由 <code>PetStoreServiceImpl</code> 类和两种类型分别为 <code>JpaAccountDao</code> 和 <code>JpaItemDao</code>(基于JPA对象关系映射标准) 的数据接入对象。<code>property name</code> 元素引用 JavaBean 属性的名字，<code>ref</code> 元素引用另外一个 bean 定义的名字。<code>id</code> 和 <code>ref</code> 元素之间的联系，表达了两个互相协作对象之间的依赖关系。想了解更多配置对象依赖的细节，参考 <a href="https://docs.spring.io/spring-framework/reference/core/beans/dependencies.html">依赖</a>。</p>
<h1 id="组装基于-xml-的配置元数据">组装基于 XML 的配置元数据</h1>
<p>一个 bean 的定义跨越多个 XML 文件中有时候会非常有用。通常，每一个 XML 的配置文件代表你架构里面的一个逻辑层或者模块。</p>
<p>你可以使用应用的上下文构造器从这些 XML 的片段中加载 bean 定义。这个构造器可以接受多 Resource 加载位置，就如前面表示的那样。你也可以使用一个或者多个 <code>&lt;import/&gt;</code> 元素去加载另一个（或者一些）文件中的 bean 定义。下面的例子展示了如何去做到这一点：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-XML" data-lang="XML"><span class="line"><span class="cl"><span class="nt">&lt;beans&gt;</span>
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;import</span> <span class="na">resource=</span><span class="s">&#34;services.xml&#34;</span><span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;import</span> <span class="na">resource=</span><span class="s">&#34;resources/messageSource.xml&#34;</span><span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;import</span> <span class="na">resource=</span><span class="s">&#34;/resources/themeSource.xml&#34;</span><span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&#34;bean1&#34;</span> <span class="na">class=</span><span class="s">&#34;...&#34;</span><span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&#34;bean2&#34;</span> <span class="na">class=</span><span class="s">&#34;...&#34;</span><span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/beans&gt;</span>
</span></span></code></pre></div><p>在上面的例子中，外部的 bean 定义从三个文件中加载到：<code>services.xml</code>,<code>messageSource.xml</code>,<code>themeSource.xml</code> 。所有的位置路径都是做引入的 bean 定义文件的相对路径。所以，services.xml 必须和正在引入的文件在相同的目录下或者类路径下。虽然 <code>messageSource.xml</code> 和 <code>themeSource.xml</code> 必须在导入文件的下面的路径的 resource 路径里。如你所见，前导的 <code>/</code> 符号被忽略了。然而，既然这些路径都是相对的，所以，最好不适用 <code>/</code> 。被引入文件的内容，必须是一个依据 Spring Schema 的有效 XML bean 定义，最外层是 <code>&lt;beans/&gt;</code> 元素。</p>
<p>注意：
使用 <code>../</code> 路径引用父目录中的文件虽然是可以的，但是并不推荐。这样做，会使得当前的应用程序对外部的文件造成依赖。特别是，这个引用对类路径不推荐，例如：<code>classpath:../services.xml</code>，这样的情形下，运行时的进程会选择离 classpath 根路径最近的地方，然后去找它的父目录。类路径配置的修改，很可能会导致一个完全不同的错误的目录被选中。</p>
<p>你可以永远选择一个全限定的资源路径而不是相对路径，例如 <code>file:C:/config/services.xml</code> 或者 <code>classpath:/config/services.xml</code>。然而，需要知道的是，你正在使你的应用配置和特定的绝对路径耦合。通常会选择对这样的绝对路径做一个间接地引用，例如，通过运行时，根据 JVM 的系统属性解析的<code>${...}</code> 占位符。</p>
<p>名空间提供了引入原语的特性。在普通 bean 定义之外的特性可以在 Spring 提供的名空间————例如， <code>context</code> 和 <code>util</code> 中获取到。</p>
<h1 id="grooy-bean-定义的-dsl">Grooy Bean 定义的 DSL</h1>
<p>另外一个外部配置元数据的例子，同样可以使用 Spring 的 Groovy Bean 定义 DSL 来表达，如 Grails 框架所示。通常，在 <code>.groovy</code> 文件会采用下面的配置结构：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Groovy" data-lang="Groovy"><span class="line"><span class="cl"><span class="n">beans</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">dataSource</span><span class="o">(</span><span class="n">BasicDataSource</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">driverClassName</span> <span class="o">=</span> <span class="s2">&#34;org.hsqldb.jdbcDriver&#34;</span>
</span></span><span class="line"><span class="cl">		<span class="n">url</span> <span class="o">=</span> <span class="s2">&#34;jdbc:hsqldb:mem:grailsDB&#34;</span>
</span></span><span class="line"><span class="cl">		<span class="n">username</span> <span class="o">=</span> <span class="s2">&#34;sa&#34;</span>
</span></span><span class="line"><span class="cl">		<span class="n">password</span> <span class="o">=</span> <span class="s2">&#34;&#34;</span>
</span></span><span class="line"><span class="cl">		<span class="n">settings</span> <span class="o">=</span> <span class="o">[</span><span class="nl">mynew:</span><span class="s2">&#34;setting&#34;</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">sessionFactory</span><span class="o">(</span><span class="n">SessionFactory</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">dataSource</span> <span class="o">=</span> <span class="n">dataSource</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">myService</span><span class="o">(</span><span class="n">MyService</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">nestedBean</span> <span class="o">=</span> <span class="o">{</span> <span class="n">AnotherBean</span> <span class="n">bean</span> <span class="o">-&gt;</span>
</span></span><span class="line"><span class="cl">			<span class="n">dataSource</span> <span class="o">=</span> <span class="n">dataSource</span>
</span></span><span class="line"><span class="cl">		<span class="o">}</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>这样的配置风格基本和 Spring XML 配置名空间中的 bean 定义和事件相同。同样，通过 importBeans 指令引入 XML bean 定义也是可以的。</p>
<h1 id="容器的使用">容器的使用</h1>
<p><code>ApplicationContext</code> 是一个高级的工厂接口，它可以保存一个包含不同的 bean 和他们的依赖。通过使用方法 <code>T getBean(String name, Class&lt;T&gt; requiredType)</code>，你可以获取到你 bean 的实例。</p>
<p><code>ApplicationContext</code> 让你可以读取并获取 bean 定义，如下面的例子所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="c1">// create and configure beans
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ApplicationContext</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ClassPathXmlApplicationContext</span><span class="o">(</span><span class="s">&#34;services.xml&#34;</span><span class="o">,</span> <span class="s">&#34;daos.xml&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// retrieve configured instance
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">PetStoreService</span> <span class="n">service</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">&#34;petStore&#34;</span><span class="o">,</span> <span class="n">PetStoreService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// use configured instance
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">userList</span> <span class="o">=</span> <span class="n">service</span><span class="o">.</span><span class="na">getUsernameList</span><span class="o">();</span>
</span></span></code></pre></div><p>使用 Groovy 配置，启动过程也类似。它有一个不同的上下文可以感知 Groovy 的实现类（同时也可以理解 XML 的 bean 定义）。下面的例子展示了 Groovy 的配置：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="n">ApplicationContext</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GenericGroovyApplicationContext</span><span class="o">(</span><span class="s">&#34;services.groovy&#34;</span><span class="o">,</span> <span class="s">&#34;daos.groovy&#34;</span><span class="o">);</span>
</span></span></code></pre></div><p>最灵活的变化就是 <code>GenericApplicationContext</code> 和读取代理————例如，使用  <code>XmlBeanDefinitionReader</code> 读取 XML 文件中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="n">GenericApplicationContext</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GenericApplicationContext</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="k">new</span> <span class="n">XmlBeanDefinitionReader</span><span class="o">(</span><span class="n">context</span><span class="o">).</span><span class="na">loadBeanDefinitions</span><span class="o">(</span><span class="s">&#34;services.xml&#34;</span><span class="o">,</span> <span class="s">&#34;daos.xml&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">context</span><span class="o">.</span><span class="na">refresh</span><span class="o">();</span>
</span></span></code></pre></div><p>你也可以使用 <code>GroovyBeanDefinitionReader</code> 读取 Groovy 文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="n">GenericApplicationContext</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GenericApplicationContext</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="k">new</span> <span class="n">GroovyBeanDefinitionReader</span><span class="o">(</span><span class="n">context</span><span class="o">).</span><span class="na">loadBeanDefinitions</span><span class="o">(</span><span class="s">&#34;services.groovy&#34;</span><span class="o">,</span> <span class="s">&#34;daos.groovy&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">context</span><span class="o">.</span><span class="na">refresh</span><span class="o">();</span>
</span></span></code></pre></div><p>你可以在 <code>ApplicationContext</code> 中混合匹配这样的读取代理，来分别兑取不同的配置文件源里面的 bean 定义。</p>
<p>你也可以使用 <code>getBean</code> 来获取你的 bean 实例对象。<code>ApplicationContext</code> 接口有一些其他的方法用来获取 bean。但是，理想情况下，你的应用代码不会用到它。确实，你的应用代码如果没有对 Spring API 的任何依赖，就不应该调用 <code>getBean()</code> 方法。例如，Spring 和 Web 框架的整合提供了对各种 web 框架元组件的依赖注入，例如 Controller 和 JSF 的bean，这些都可以让你能够通过元数据（例如自动装配）来声明依赖。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>[译] SpringFramework 文档</title>
      <link>https://anriclee.github.io/posts/springframework/directory/</link>
      <pubDate>Sat, 02 Sep 2023 11:46:07 +0800</pubDate>
      
      <guid>https://anriclee.github.io/posts/springframework/directory/</guid>
      <description>概述 历史，设计哲学，反馈，开始
核心 IoC容器，事件，资源，i18n，验证，数据绑定，类型转换，SpEL，AOP，AOT
测试 对象 Mock，测试上下文框架，Spring MVC 测试，Web 测试客户端
数据接入 事务，DAO 支持，JDBC，R2DBC，O/R 映射，XML 编码
Web Servlet SpringMVC,WebSocket,SockJS,STOMP 通信
Web 响应式 Spring WebFlux, WebClient, WebSocket, RSocket.
[集成] REST 客户端, JMS, JCA, JMX, Email, 任务, 调度, 缓存, 可见性.
语言 Kotlin, Groovy, Dynamic 语言.
附录 Spring 属性</description>
      <content:encoded><![CDATA[<ul>
<li>
<p><a href="Overview">概述</a> 历史，设计哲学，反馈，开始</p>
</li>
<li>
<p><a href="">核心</a> IoC容器，事件，资源，i18n，验证，数据绑定，类型转换，SpEL，AOP，AOT</p>
</li>
<li>
<p><a href="">测试</a> 对象 Mock，测试上下文框架，Spring MVC 测试，Web 测试客户端</p>
</li>
<li>
<p><a href="">数据接入</a> 事务，DAO 支持，JDBC，R2DBC，O/R 映射，XML 编码</p>
</li>
<li>
<p><a href="">Web Servlet</a> SpringMVC,WebSocket,SockJS,STOMP 通信</p>
</li>
<li>
<p><a href="">Web 响应式</a> Spring WebFlux, WebClient, WebSocket, RSocket.</p>
</li>
<li>
<p>[集成] REST 客户端, JMS, JCA, JMX, Email, 任务, 调度, 缓存, 可见性.</p>
</li>
<li>
<p><a href="">语言</a> Kotlin, Groovy, Dynamic 语言.</p>
</li>
<li>
<p><a href="">附录</a> Spring 属性</p>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>[译] SpringFramework 概述</title>
      <link>https://anriclee.github.io/posts/springframework/overview/</link>
      <pubDate>Sat, 02 Sep 2023 11:46:07 +0800</pubDate>
      
      <guid>https://anriclee.github.io/posts/springframework/overview/</guid>
      <description>概述 Spring 使得创建 Java 企业级应用更加容易。它提供了你在企业环境下拥抱 Java 语言所需要的一切，支持 JVM 平台上的 Groovy 和 Kotlin 作为备选语言，并且提供了根据应用程序的需求创建多种架构的灵活性。从 SpringFramework 6.0 开始，Spring 需要 Java 17 以上的版本。
Spring 支持广泛的应用场景。在一个大型企业里，应用程序经常会存在很长时间，并且必须运行在一个开发者不能控制升级周期的 JDK 和应用服务器上。 另外一些可能会作为一个内嵌服务器的单独 jar 包，运行在一个云环境里，还有一些可能是一个不需要服务器的独立应用程序（例如批处理或者集成处理工作）。
Spring 是开源的。它有一个庞大而活跃的社群，基于各种实际用例，提供持续反馈。这也帮助了 Spring 在相当长一段时间内成功发展。。
当我们在谈 Spring 时我们在谈什么 “Spring” 这个术语在不同的语境下有着不同的含义。它可以用来表示 SpringFramework 这个项目自身，一切都是从这里开始的（-译者按：梦开始的地方）。随着时间的推移，又构建了一些以 SpringFramework 为基础的 Spring 项目。大部分情况下，当人们谈论 Spring，他们的意思是 Spring 整个系列（-译者按：俗称全家桶）。本参考文档只针对这个基础进行介绍：SpringFramework 本身。
SpringFramework 被分成不同的模块。应用程序可以根据他们所需要的模块进行选择。这些模块中处于核心的是 core container，包括配置模型和依赖注入机制。除此之外，SpringFramework 还对于不同应用架构提供基础支持，包括消息传递、事务以及持久化和 web。它同时也包含了基于 Servlet 的 SpringMVC web 框架以及Spring WebFlux 响应式web框架。
关于这些模块需要注意的是：
Spring 的框架，允许部署到 JDK 9 的模块路径（&amp;ldquo;Jigsaw&amp;rdquo;）。对于在支持 “Jigsaw” 的应用程序中的使用，Spring Framework 5 的 jar 包里面，携带了 “Automatic-Module-Name” 的 manifest entries，它定义了稳定的语言级别模块名（例如：“spring.</description>
      <content:encoded><![CDATA[<h1 id="概述">概述</h1>
<p>Spring 使得创建 Java 企业级应用更加容易。它提供了你在企业环境下拥抱 Java 语言所需要的一切，支持 JVM 平台上的 Groovy 和 Kotlin 作为备选语言，并且提供了根据应用程序的需求创建多种架构的灵活性。从 SpringFramework 6.0 开始，Spring 需要 Java 17 以上的版本。</p>
<p>Spring 支持广泛的应用场景。在一个大型企业里，应用程序经常会存在很长时间，并且必须运行在一个开发者不能控制升级周期的 JDK 和应用服务器上。
另外一些可能会作为一个内嵌服务器的单独 jar 包，运行在一个云环境里，还有一些可能是一个不需要服务器的独立应用程序（例如批处理或者集成处理工作）。</p>
<p>Spring 是开源的。它有一个庞大而活跃的社群，基于各种实际用例，提供持续反馈。这也帮助了 Spring 在相当长一段时间内成功发展。。</p>
<h1 id="当我们在谈-spring-时我们在谈什么">当我们在谈 Spring 时我们在谈什么</h1>
<p>“Spring” 这个术语在不同的语境下有着不同的含义。它可以用来表示 SpringFramework 这个项目自身，一切都是从这里开始的（-译者按：梦开始的地方）。随着时间的推移，又构建了一些以 SpringFramework 为基础的 Spring 项目。大部分情况下，当人们谈论 Spring，他们的意思是 Spring 整个系列（-译者按：俗称全家桶）。本参考文档只针对这个基础进行介绍：SpringFramework 本身。</p>
<p>SpringFramework 被分成不同的模块。应用程序可以根据他们所需要的模块进行选择。这些模块中处于核心的是 core container，包括配置模型和依赖注入机制。除此之外，SpringFramework 还对于不同应用架构提供基础支持，包括消息传递、事务以及持久化和 web。它同时也包含了基于 Servlet 的 SpringMVC web 框架以及Spring WebFlux 响应式web框架。</p>
<p>关于这些模块需要注意的是：</p>
<p>Spring 的框架，允许部署到 JDK 9 的模块路径（&ldquo;Jigsaw&rdquo;）。对于在支持 “Jigsaw” 的应用程序中的使用，Spring Framework 5 的 jar 包里面，携带了 “Automatic-Module-Name” 的 manifest entries，它定义了稳定的语言级别模块名（例如：“spring.core”，“spring.context” 等等），它与 jar 的 artifact 名字独立（ 这些 jar 遵循同样的模式，例如 “spring-core” 和 “spring-context”。 “-” 代替 “.”</p>
<blockquote>
<p>译者按：本人对于 Jigsaw 不太熟悉，等后面熟悉了，再过来修正这一段的翻译。目前，是不知道这段说了什么的。</p>
</blockquote>
<p>当然，Spring 框架中的 jar 包，在 JDK 9 和 JDK 9+ 的 classpath 中，可以继续正常工作。</p>
<h1 id="spring-和-spring-framework-的历史">Spring 和 Spring Framework 的历史</h1>
<p>在 2003 年，为了应对 J2EE 早期规范的复杂性，Spring 应运而生。
虽然一些人认为 Java EE 和他的现代继承者 Jakarta EE 与 Spring 势不两立，但是他们实际上是互为补充的。
Spring 的编程模型不会拥抱 Jakarta EE 平台的规范，相反，它从传统的 EE 的笼罩下面，精心挑选了一些规范，并与之整合：</p>
<ul>
<li>
<p>Servlet API (JSR 340)</p>
</li>
<li>
<p>WebSocket API (JSR 356)</p>
</li>
<li>
<p>Concurrency Utilities (JSR 236)</p>
</li>
<li>
<p>JSON Binding API (JSR 367)</p>
</li>
<li>
<p>Bean Validation (JSR 303)</p>
</li>
<li>
<p>JPA (JSR 338)</p>
</li>
<li>
<p>JMS (JSR 914)</p>
</li>
<li>
<p>如果有必要的话，还有 JTA/JCA 用于事务协商的设置</p>
</li>
</ul>
<p>SpringFramework 还支持应用开发者使用依赖注入规范（JSR 330）和通用注解规范（JSR 250），代替 SpringFramework 提供的 Spring 规范机制。最初，他们都是基于 javax 包的。</p>
<blockquote>
<p>译者按：自由即长久。</p>
</blockquote>
<p>SpringFramework 6.0 里，Spring 已经升级到 Jakarta EE 9（例如：Servlet 5.0+，JPA 3.0+），基于 Jakarta 名称空间，而非传统的 javax 包。
从 EE 9 开始到现在已经支持的 EE 10，Spring 准备对 Jakarta EE 接口的进一步发展提供开箱即用的支持。</p>
<p>SpringFramework 6.0 已经完全兼容 Tomcat 10.1，Jetty 11 和 Undertow 2.3 作为 web 服务器，这其中也抱愧 Hibernate ORM 6.1.</p>
<p>随着时间的推移，Java/Jakarta EE 在应用开发中的角色在不断演进。在 J2EE 和 Spring 的早期，应用被创建后，部署到一个应用服务器上。</p>
<p>今天，在 Spring Boot 的帮助下，应用可以以一种 devops 和云友好的方式创建，内嵌 Servlet 容器，并且易于修改。从 SpringFramework 5 开始，WebFlux 应用甚至不直接使用 Servlet API 就可以在非 Servlet 的服务器上运行起来（例如 Netty）</p>
<p>Spring 持续创新和演进。除了 SpringFramework 之外，还有很多项目，例如 Spring Boot，Spring Security，Spring Data，Spring Cloud，Spring Batch。
值得记住的是：每一个项目都有它自己的源码仓库，问题追踪和发版节奏。可以在 <a href="https://spring.io/projects">spring.io/projects</a> 看到 Spring 项目的完整清单。</p>
<h1 id="设计哲学">设计哲学</h1>
<p>当你了解一个框架时，重要的不是知道它做了什么而是它遵循什么样的准则。SpringFramework 的指导准则如下：</p>
<ul>
<li>在每一个级别上提供选择。Spring 可以让你尽可能晚地推迟做出设计决策。比如，你可以在不更改代码的情况下，改变你的持久化方案。对于其他的基础设施问题，整合其他第三方的 API，这一点同样适用。</li>
<li>兼容并包。Spring 拥抱灵活性，并不介意事情是怎么被完成的。它提供了在不同观念下的诸多需要。</li>
<li>保持较强的向后兼容性。Spring 的演进经过精心管理，在版本之间，几乎没有特别大的变化。Spring 精心挑选 JDK 版本号范围以及第三方库，以方便维护依赖于 Spring 的应用以及库。</li>
<li>精心设计 API。Spring 团队投入了较多的时间和精力设计 API，目的是让 API 更加符合直觉，可以使用很多年，跨越多个版本。</li>
<li>对代码质量设置较高的标准。SpringFramework 重点强调有意义的、及时、精确的 javadoc。它是为数不多的声称拥有干净的代码架构且在不同的包之间没有循环引用的项目之一。</li>
</ul>
<h1 id="开始">开始</h1>
<p>如果你刚开始接触 Spring，你也许会从创建一个基于 SpringBoot 应用开始使用 SpringFramework。SpringBoot 提供了一个快速（固定）的方式来创建可部署生产环境的基于 Spring 的应用。它基于 SpringFramework，喜欢约定优于配置的风格，设计它就是为了让你能够尽可能快地启动和运行。</p>
<p>你可以使用<a href="https://start.spring.io/">start.spring.io</a>来生成一个基本的项目，或者遵循<a href="https://spring.io/guides">&ldquo;Getting Started&rdquo; 指南</a> 例如 <a href="https://spring.io/guides/gs/rest-service/">Getting Started Building a RESTful Web Service</a>。</p>
<p>这些指南都是任务导向且易于理解的，他们中的大部分是基于 SpringBoot。它同时也涵盖了 Spring 产品中的其他项目，这些你可能会在解决某个具体的问题时会使用到。</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
