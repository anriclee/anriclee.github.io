<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Spring on ReadByWord</title>
    <link>https://anriclee.github.io/tags/spring/</link>
    <description>Recent content in Spring on ReadByWord</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 02 Sep 2023 23:12:31 +0800</lastBuildDate><atom:link href="https://anriclee.github.io/tags/spring/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[译] Spring IOC 容器</title>
      <link>https://anriclee.github.io/posts/springframework/core/the_ioc_container/container_and_beans/</link>
      <pubDate>Sat, 02 Sep 2023 23:12:31 +0800</pubDate>
      
      <guid>https://anriclee.github.io/posts/springframework/core/the_ioc_container/container_and_beans/</guid>
      <description>Spring IOC 和 bean 的简介 本章涵盖了 SpringFramework 中的控制反转原则（Ioc）的实现。IoC 也被称为依赖注入（DI）。它是这样的一种过程，在此期间对象仅通过构造函数参数、工厂方法的参数或者当对象实例被构造后或者通过工厂方法返回时在它上面设置的属性定义自己的依赖（即对象必须合作的其他对象）。
当容器创建这些 bean 后，再注入这些依赖。
这个过程本质上与bean 通过使用直接的类构造函数进行直接实例化或者通过类似 Service Locator模式来寻找依赖的位置是相反的（这也是 IoC 名字的由来）。
org.springframework.beans 和 org.springframework.context 包是 SpringFramework IoC 容器的基石。BeanFactory 接口提供了一种更先进的能够控制人已类型对象的配置机制。ApplicationContext 是 BeanFactory 的子接口。它增加了下面的特性：
与 Spring 的 AOP 特性更容易整合 消息资源处理（在国际化场景的使用） 事件发布 例如用于 Web 应用的 WebApplicationContext 应用层特定的上下文 总而言之，BeanFactory 提供了配置的框架和基本的功能。ApplicationContext 增加了更多的企业特定的功能。ApplicationContext 完全是 BeanFactory 的超集。在本章关于 Spring IoC 容器做专门描述时会用到。想要获取更多的关于使用 ApplicationContext 而非 BeanFactory 的信息，参见介绍 BeanFactory API 的部分。
在 Spring 中，作为你应用基石同时可以被 Spring IoC 容器所操控的对象就被称之为 bean。bean 就是被 Spring IoC 容器实例化、组装和设置的对象。否则，一个 bean 就是你应用程序中诸多对象中的一个。 Beans 以及他们依赖关系，反映在容器使用的配置元数据中。</description>
      <content:encoded><![CDATA[<h1 id="spring-ioc-和-bean-的简介">Spring IOC 和 bean 的简介</h1>
<p>本章涵盖了 SpringFramework 中的控制反转原则（Ioc）的实现。IoC 也被称为依赖注入（DI）。它是这样的一种过程，在此期间对象仅通过构造函数参数、工厂方法的参数或者当对象实例被构造后或者通过工厂方法返回时在它上面设置的属性定义自己的依赖（即对象必须合作的其他对象）。</p>
<p>当容器创建这些 bean 后，再注入这些依赖。</p>
<p>这个过程本质上与bean 通过使用直接的类构造函数进行直接实例化或者通过类似 Service Locator模式来寻找依赖的位置是相反的（这也是 IoC 名字的由来）。</p>
<p><code>org.springframework.beans</code> 和 <code>org.springframework.context</code> 包是 SpringFramework IoC 容器的基石。<code>BeanFactory</code> 接口提供了一种更先进的能够控制人已类型对象的配置机制。<code>ApplicationContext</code> 是 <code>BeanFactory</code> 的子接口。它增加了下面的特性：</p>
<ul>
<li>与 Spring 的 AOP 特性更容易整合</li>
<li>消息资源处理（在国际化场景的使用）</li>
<li>事件发布</li>
<li>例如用于 Web 应用的 <code>WebApplicationContext</code> 应用层特定的上下文</li>
</ul>
<p>总而言之，<code>BeanFactory</code> 提供了配置的框架和基本的功能。<code>ApplicationContext</code> 增加了更多的企业特定的功能。<code>ApplicationContext</code> 完全是 <code>BeanFactory</code> 的超集。在本章关于 Spring IoC 容器做专门描述时会用到。想要获取更多的关于使用 <code>ApplicationContext</code> 而非 <code>BeanFactory</code> 的信息，参见介绍 <a href="https://docs.spring.io/spring-framework/reference/core/beans/beanfactory.html">BeanFactory</a> API 的部分。</p>
<p>在 Spring 中，作为你应用基石同时可以被 Spring IoC 容器所操控的对象就被称之为 bean。bean 就是被 Spring IoC 容器实例化、组装和设置的对象。否则，一个 bean 就是你应用程序中诸多对象中的一个。 Beans 以及他们依赖关系，反映在容器使用的配置元数据中。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>[译] 容器概述</title>
      <link>https://anriclee.github.io/posts/springframework/core/the_ioc_container/container_overview/</link>
      <pubDate>Sat, 02 Sep 2023 23:12:31 +0800</pubDate>
      
      <guid>https://anriclee.github.io/posts/springframework/core/the_ioc_container/container_overview/</guid>
      <description>容器概述 org.springframework.context.ApplicationContext 接口代表了 Spring IoC 容器，它主要负责通过读取配置文件对 bean 进行实例化、配置和组装。 容器通过读取配置元数据来获知要实例化、配置和组装那些对象。配置的元数据一般为 XML、Java 注解和 Java 代码的形式，它让你能够表达组成你应用程序的对象以及对象之间的丰富的相互依赖关系。
Spring 提供了 ApplicationContext 接口的若干实现。在单体应用中，创建一个 ClassPathXmlApplicationContext 或者 FileSystemXmlApplicationContext 是很常见的。虽然 XML 是定义配置元数据的传统形式，但是你还可以通过在 XML 文件里面进行声明配置来告诉容器对于 Java 注解或者Java代码格式的支持。
在大多数的应用场景中，并不需要显式的代码来实例化 Spring IoC 容器。例如，在 Web 应用的场景中，在 web.xml 文件中仅用简单的 8 行代码左右的样板 Web XML 描述符即可满足需要（参考 Convenient ApplicationContext Instantiation for Web Applications）。如果你使 Eclipse 中的 Spring 工具（在 Eclipse 开发环境中），你可以通过几下鼠标点击或者按键的敲击就能轻松创建这样一个样板配置文件。
下图展示了关于 Spring 工作机制的一个全局视角。在 ApplicationContext 被创建和初始化后，你的应用类和配置元数据已经捆绑在一起了，这样一来，你就有一个充分配置并且可执行的系统或者应用程序。
配置元数据 如上图所示，Spring Ioc 容器接收到一种格式的配置元数据。这个配置元数据代表了，作为一个应用开发者你告诉 Spring 容器在应用程序中，如何实例化、配置和组装对象。
传统的配置元数据是一种简单并且符合直觉的 XML 形式，在本章的大部分地方，也用此来表达关键的概念和 Spring IoC 容器的特性。
基于 XML 的元数据不是配置元数据的唯一允许的形式。Spring IoC 容器自身与配置元数据实际上是什么格式完全解耦。目前许多开发者在应用程序中选择基于Java 的配置。</description>
      <content:encoded><![CDATA[<h1 id="容器概述">容器概述</h1>
<p><code>org.springframework.context.ApplicationContext</code> 接口代表了 Spring IoC 容器，它主要负责通过读取配置文件对 bean 进行实例化、配置和组装。
容器通过读取配置元数据来获知要实例化、配置和组装那些对象。配置的元数据一般为 XML、Java 注解和 Java 代码的形式，它让你能够表达组成你应用程序的对象以及对象之间的丰富的相互依赖关系。</p>
<p>Spring 提供了 <code>ApplicationContext</code> 接口的若干实现。在单体应用中，创建一个 <code>ClassPathXmlApplicationContext</code> 或者 <code>FileSystemXmlApplicationContext</code> 是很常见的。虽然 XML 是定义配置元数据的传统形式，但是你还可以通过在 XML 文件里面进行声明配置来告诉容器对于 Java 注解或者Java代码格式的支持。</p>
<p>在大多数的应用场景中，并不需要显式的代码来实例化 Spring IoC 容器。例如，在 Web 应用的场景中，在 <code>web.xml</code> 文件中仅用简单的 8 行代码左右的样板 Web XML 描述符即可满足需要（参考 <a href="https://docs.spring.io/spring-framework/reference/core/beans/context-introduction.html#context-create">Convenient ApplicationContext Instantiation for Web Applications</a>）。如果你使 Eclipse 中的 Spring 工具（在 Eclipse 开发环境中），你可以通过几下鼠标点击或者按键的敲击就能轻松创建这样一个样板配置文件。</p>
<p>下图展示了关于 Spring 工作机制的一个全局视角。在 <code>ApplicationContext</code> 被创建和初始化后，你的应用类和配置元数据已经捆绑在一起了，这样一来，你就有一个充分配置并且可执行的系统或者应用程序。</p>
<p><img loading="lazy" src="/posts/springframework/core/the_ioc_container/container_overview/imgs/ioc.png" type="" alt="Spring"  /></p>
<h1 id="配置元数据">配置元数据</h1>
<p>如上图所示，Spring Ioc 容器接收到一种格式的配置元数据。这个配置元数据代表了，作为一个应用开发者你告诉 Spring 容器在应用程序中，如何实例化、配置和组装对象。</p>
<p>传统的配置元数据是一种简单并且符合直觉的 XML 形式，在本章的大部分地方，也用此来表达关键的概念和 Spring IoC 容器的特性。</p>
<blockquote>
<p>基于 XML 的元数据不是配置元数据的唯一允许的形式。Spring IoC 容器自身与配置元数据实际上是什么格式完全解耦。目前许多开发者在应用程序中选择<a href="https://docs.spring.io/spring-framework/reference/core/beans/java.html">基于Java 的配置</a>。</p>
</blockquote>
<p>在 Spring 容器中使用其他格式的配置元数据，可参考：</p>
<ul>
<li><a href="https://docs.spring.io/spring-framework/reference/core/beans/annotation-config.html">基于注解的配置</a>：通过基于注解的配置元数据定义 beans</li>
<li><a href="https://docs.spring.io/spring-framework/reference/core/beans/java.html">基于Java的配置</a>：通过使用 Java 而不是 XML 文件来定义你应用类之外的 beans。使用这些特性可以参考 <a href="https://docs.spring.io/spring-framework/docs/6.0.11/javadoc-api/org/springframework/context/annotation/Configuration.html">@Configuration</a>, <a href="https://docs.spring.io/spring-framework/docs/6.0.11/javadoc-api/org/springframework/context/annotation/Bean.html">@Bean</a>, <a href="https://docs.spring.io/spring-framework/docs/6.0.11/javadoc-api/org/springframework/context/annotation/Import.html">@Import</a>, <a href="https://docs.spring.io/spring-framework/docs/6.0.11/javadoc-api/org/springframework/context/annotation/DependsOn.html">@DependsOn</a> 注解。</li>
</ul>
<p>Spring 的配置由至少一个，通常为1个以上容器可以操作的 bean 组成。基于 XML 的配置元数据，配置顶部根元素 <beans/> 里面的 <bean/> 元素。Java 配置通常在一个 @Configuration 类里面使用 @Bean 注解方法。</p>
<p>这些 bean 的定义与组成你应用的实际对象相对应。通常地，你需要定义服务层对象，持久化层对象例如仓库或者数据接入对象（DAOs），例如 Web Controller 的表现层对象，例如一个 JPA EntityManagerFactory 的基础层对象，JMS 队列等等。通常不在容器里面对一个领域层对象进行精细化配置，因为创建和加载领域对象，通常是存储层和业务层的逻辑。</p>
<p>下面的例子，展示了基于 XML 的配置元数据的基本结构：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-XML" data-lang="XML"><span class="line"><span class="cl"><span class="cp">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;beans</span> <span class="na">xmlns=</span><span class="s">&#34;http://www.springframework.org/schema/beans&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="na">xmlns:xsi=</span><span class="s">&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="na">xsi:schemaLocation=</span><span class="s">&#34;http://www.springframework.org/schema/beans
</span></span></span><span class="line"><span class="cl"><span class="s">		https://www.springframework.org/schema/beans/spring-beans.xsd&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&#34;...&#34;</span> <span class="na">class=</span><span class="s">&#34;...&#34;</span><span class="nt">&gt;</span> [1][2]
</span></span><span class="line"><span class="cl">		<span class="c">&lt;!-- collaborators and configuration for this bean go here --&gt;</span>
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;/bean&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&#34;...&#34;</span> <span class="na">class=</span><span class="s">&#34;...&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">		<span class="c">&lt;!-- collaborators and configuration for this bean go here --&gt;</span>
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;/bean&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c">&lt;!-- more bean definitions go here --&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/beans&gt;</span>
</span></span></code></pre></div><p>[1]：id 属性唯一标识一个独立的 bean 定义
[2]：class 属性定义了 bean的类型，并且使用类的全限定名</p>
<p>id 属性的值可以被用来引用互相协作的对象。引用协作的对象的 XML并不在此例中，参考<a href="https://docs.spring.io/spring-framework/reference/core/beans/dependencies.html">依赖</a>部分获取更多的信息。</p>
<h1 id="初始化一个容器">初始化一个容器</h1>
<p>提供给 <code>ApplicationContext</code> 构造器的位置路径是一些表示资源的字符串，这些字符串可以让容器从各种外部资源加载配置元数据，例如本地文件系统，Java 类路径等等。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="n">ApplicationContext</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ClassPathXmlApplicationContext</span><span class="o">(</span><span class="s">&#34;services.xml&#34;</span><span class="o">,</span> <span class="s">&#34;daos.xml&#34;</span><span class="o">);</span>
</span></span></code></pre></div><p>在你了解了 Spring 的 IoC 容器后，你也许想对 Spring 的“资源：抽象了解更多，这提供了一种方便的从 URI 语法标识中读取输入流的机制。特别是 Resource 路径用于构建应用的上下文。</p>
<p>下面的例子展示了服务层的对象(services.xml)的配置文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-XML" data-lang="XML"><span class="line"><span class="cl"><span class="cp">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;beans</span> <span class="na">xmlns=</span><span class="s">&#34;http://www.springframework.org/schema/beans&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="na">xmlns:xsi=</span><span class="s">&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="na">xsi:schemaLocation=</span><span class="s">&#34;http://www.springframework.org/schema/beans
</span></span></span><span class="line"><span class="cl"><span class="s">		https://www.springframework.org/schema/beans/spring-beans.xsd&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c">&lt;!-- services --&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&#34;petStore&#34;</span> <span class="na">class=</span><span class="s">&#34;org.springframework.samples.jpetstore.services.PetStoreServiceImpl&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">		<span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&#34;accountDao&#34;</span> <span class="na">ref=</span><span class="s">&#34;accountDao&#34;</span><span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl">		<span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&#34;itemDao&#34;</span> <span class="na">ref=</span><span class="s">&#34;itemDao&#34;</span><span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl">		<span class="c">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span>
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;/bean&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c">&lt;!-- more bean definitions for services go here --&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/beans&gt;</span>
</span></span></code></pre></div><p>下面的例子展示了数据接入层(daos.xml)文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-XML" data-lang="XML"><span class="line"><span class="cl"><span class="cp">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;beans</span> <span class="na">xmlns=</span><span class="s">&#34;http://www.springframework.org/schema/beans&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="na">xmlns:xsi=</span><span class="s">&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="na">xsi:schemaLocation=</span><span class="s">&#34;http://www.springframework.org/schema/beans
</span></span></span><span class="line"><span class="cl"><span class="s">		https://www.springframework.org/schema/beans/spring-beans.xsd&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&#34;accountDao&#34;</span>
</span></span><span class="line"><span class="cl">		<span class="na">class=</span><span class="s">&#34;org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">		<span class="c">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span>
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;/bean&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&#34;itemDao&#34;</span> <span class="na">class=</span><span class="s">&#34;org.springframework.samples.jpetstore.dao.jpa.JpaItemDao&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">		<span class="c">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span>
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;/bean&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c">&lt;!-- more bean definitions for data access objects go here --&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/beans&gt;</span>
</span></span></code></pre></div><p>在上面的例子中，服务层由 <code>PetStoreServiceImpl</code> 类和两种类型分别为 <code>JpaAccountDao</code> 和 <code>JpaItemDao</code>(基于JPA对象关系映射标准) 的数据接入对象。<code>property name</code> 元素引用 JavaBean 属性的名字，<code>ref</code> 元素引用另外一个 bean 定义的名字。<code>id</code> 和 <code>ref</code> 元素之间的联系，表达了两个互相协作对象之间的依赖关系。想了解更多配置对象依赖的细节，参考 <a href="https://docs.spring.io/spring-framework/reference/core/beans/dependencies.html">依赖</a>。</p>
<h1 id="组装基于-xml-的配置元数据">组装基于 XML 的配置元数据</h1>
<p>一个 bean 的定义跨越多个 XML 文件中有时候会非常有用。通常，每一个 XML 的配置文件代表你架构里面的一个逻辑层或者模块。</p>
<p>你可以使用应用的上下文构造器从这些 XML 的片段中加载 bean 定义。这个构造器可以接受多 Resource 加载位置，就如前面表示的那样。你也可以使用一个或者多个 <code>&lt;import/&gt;</code> 元素去加载另一个（或者一些）文件中的 bean 定义。下面的例子展示了如何去做到这一点：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-XML" data-lang="XML"><span class="line"><span class="cl"><span class="nt">&lt;beans&gt;</span>
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;import</span> <span class="na">resource=</span><span class="s">&#34;services.xml&#34;</span><span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;import</span> <span class="na">resource=</span><span class="s">&#34;resources/messageSource.xml&#34;</span><span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;import</span> <span class="na">resource=</span><span class="s">&#34;/resources/themeSource.xml&#34;</span><span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&#34;bean1&#34;</span> <span class="na">class=</span><span class="s">&#34;...&#34;</span><span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl">	<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&#34;bean2&#34;</span> <span class="na">class=</span><span class="s">&#34;...&#34;</span><span class="nt">/&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/beans&gt;</span>
</span></span></code></pre></div><p>在上面的例子中，外部的 bean 定义从三个文件中加载到：<code>services.xml</code>,<code>messageSource.xml</code>,<code>themeSource.xml</code> 。所有的位置路径都是做引入的 bean 定义文件的相对路径。所以，services.xml 必须和正在引入的文件在相同的目录下或者类路径下。虽然 <code>messageSource.xml</code> 和 <code>themeSource.xml</code> 必须在导入文件的下面的路径的 resource 路径里。如你所见，前导的 <code>/</code> 符号被忽略了。然而，既然这些路径都是相对的，所以，最好不适用 <code>/</code> 。被引入文件的内容，必须是一个依据 Spring Schema 的有效 XML bean 定义，最外层是 <code>&lt;beans/&gt;</code> 元素。</p>
<p>注意：
使用 <code>../</code> 路径引用父目录中的文件虽然是可以的，但是并不推荐。这样做，会使得当前的应用程序对外部的文件造成依赖。特别是，这个引用对类路径不推荐，例如：<code>classpath:../services.xml</code>，这样的情形下，运行时的进程会选择离 classpath 根路径最近的地方，然后去找它的父目录。类路径配置的修改，很可能会导致一个完全不同的错误的目录被选中。</p>
<p>你可以永远选择一个全限定的资源路径而不是相对路径，例如 <code>file:C:/config/services.xml</code> 或者 <code>classpath:/config/services.xml</code>。然而，需要知道的是，你正在使你的应用配置和特定的绝对路径耦合。通常会选择对这样的绝对路径做一个间接地引用，例如，通过运行时，根据 JVM 的系统属性解析的<code>${...}</code> 占位符。</p>
<p>名空间提供了引入原语的特性。在普通 bean 定义之外的特性可以在 Spring 提供的名空间————例如， <code>context</code> 和 <code>util</code> 中获取到。</p>
<h1 id="grooy-bean-定义的-dsl">Grooy Bean 定义的 DSL</h1>
<p>另外一个外部配置元数据的例子，同样可以使用 Spring 的 Groovy Bean 定义 DSL 来表达，如 Grails 框架所示。通常，在 <code>.groovy</code> 文件会采用下面的配置结构：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Groovy" data-lang="Groovy"><span class="line"><span class="cl"><span class="n">beans</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">dataSource</span><span class="o">(</span><span class="n">BasicDataSource</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">driverClassName</span> <span class="o">=</span> <span class="s2">&#34;org.hsqldb.jdbcDriver&#34;</span>
</span></span><span class="line"><span class="cl">		<span class="n">url</span> <span class="o">=</span> <span class="s2">&#34;jdbc:hsqldb:mem:grailsDB&#34;</span>
</span></span><span class="line"><span class="cl">		<span class="n">username</span> <span class="o">=</span> <span class="s2">&#34;sa&#34;</span>
</span></span><span class="line"><span class="cl">		<span class="n">password</span> <span class="o">=</span> <span class="s2">&#34;&#34;</span>
</span></span><span class="line"><span class="cl">		<span class="n">settings</span> <span class="o">=</span> <span class="o">[</span><span class="nl">mynew:</span><span class="s2">&#34;setting&#34;</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">sessionFactory</span><span class="o">(</span><span class="n">SessionFactory</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">dataSource</span> <span class="o">=</span> <span class="n">dataSource</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">myService</span><span class="o">(</span><span class="n">MyService</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">nestedBean</span> <span class="o">=</span> <span class="o">{</span> <span class="n">AnotherBean</span> <span class="n">bean</span> <span class="o">-&gt;</span>
</span></span><span class="line"><span class="cl">			<span class="n">dataSource</span> <span class="o">=</span> <span class="n">dataSource</span>
</span></span><span class="line"><span class="cl">		<span class="o">}</span>
</span></span><span class="line"><span class="cl">	<span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>这样的配置风格基本和 Spring XML 配置名空间中的 bean 定义和事件相同。同样，通过 importBeans 指令引入 XML bean 定义也是可以的。</p>
<h1 id="容器的使用">容器的使用</h1>
<p><code>ApplicationContext</code> 是一个高级的工厂接口，它可以保存一个包含不同的 bean 和他们的依赖。通过使用方法 <code>T getBean(String name, Class&lt;T&gt; requiredType)</code>，你可以获取到你 bean 的实例。</p>
<p><code>ApplicationContext</code> 让你可以读取并获取 bean 定义，如下面的例子所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="c1">// create and configure beans
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ApplicationContext</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ClassPathXmlApplicationContext</span><span class="o">(</span><span class="s">&#34;services.xml&#34;</span><span class="o">,</span> <span class="s">&#34;daos.xml&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// retrieve configured instance
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">PetStoreService</span> <span class="n">service</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">&#34;petStore&#34;</span><span class="o">,</span> <span class="n">PetStoreService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// use configured instance
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">userList</span> <span class="o">=</span> <span class="n">service</span><span class="o">.</span><span class="na">getUsernameList</span><span class="o">();</span>
</span></span></code></pre></div><p>使用 Groovy 配置，启动过程也类似。它有一个不同的上下文可以感知 Groovy 的实现类（同时也可以理解 XML 的 bean 定义）。下面的例子展示了 Groovy 的配置：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="n">ApplicationContext</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GenericGroovyApplicationContext</span><span class="o">(</span><span class="s">&#34;services.groovy&#34;</span><span class="o">,</span> <span class="s">&#34;daos.groovy&#34;</span><span class="o">);</span>
</span></span></code></pre></div><p>最灵活的变化就是 <code>GenericApplicationContext</code> 和读取代理————例如，使用  <code>XmlBeanDefinitionReader</code> 读取 XML 文件中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="n">GenericApplicationContext</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GenericApplicationContext</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="k">new</span> <span class="n">XmlBeanDefinitionReader</span><span class="o">(</span><span class="n">context</span><span class="o">).</span><span class="na">loadBeanDefinitions</span><span class="o">(</span><span class="s">&#34;services.xml&#34;</span><span class="o">,</span> <span class="s">&#34;daos.xml&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">context</span><span class="o">.</span><span class="na">refresh</span><span class="o">();</span>
</span></span></code></pre></div><p>你也可以使用 <code>GroovyBeanDefinitionReader</code> 读取 Groovy 文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="n">GenericApplicationContext</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GenericApplicationContext</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="k">new</span> <span class="n">GroovyBeanDefinitionReader</span><span class="o">(</span><span class="n">context</span><span class="o">).</span><span class="na">loadBeanDefinitions</span><span class="o">(</span><span class="s">&#34;services.groovy&#34;</span><span class="o">,</span> <span class="s">&#34;daos.groovy&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="n">context</span><span class="o">.</span><span class="na">refresh</span><span class="o">();</span>
</span></span></code></pre></div><p>你可以在 <code>ApplicationContext</code> 中混合匹配这样的读取代理，来分别兑取不同的配置文件源里面的 bean 定义。</p>
<p>你也可以使用 <code>getBean</code> 来获取你的 bean 实例对象。<code>ApplicationContext</code> 接口有一些其他的方法用来获取 bean。但是，理想情况下，你的应用代码不会用到它。确实，你的应用代码如果没有对 Spring API 的任何依赖，就不应该调用 <code>getBean()</code> 方法。例如，Spring 和 Web 框架的整合提供了对各种 web 框架元组件的依赖注入，例如 Controller 和 JSF 的bean，这些都可以让你能够通过元数据（例如自动装配）来声明依赖。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>[译] SpringFramework 文档</title>
      <link>https://anriclee.github.io/posts/springframework/directory/</link>
      <pubDate>Sat, 02 Sep 2023 11:46:07 +0800</pubDate>
      
      <guid>https://anriclee.github.io/posts/springframework/directory/</guid>
      <description>概述 历史，设计哲学，反馈，开始
核心 IoC容器，事件，资源，i18n，验证，数据绑定，类型转换，SpEL，AOP，AOT
测试 对象 Mock，测试上下文框架，Spring MVC 测试，Web 测试客户端
数据接入 事务，DAO 支持，JDBC，R2DBC，O/R 映射，XML 编码
Web Servlet SpringMVC,WebSocket,SockJS,STOMP 通信
Web 响应式 Spring WebFlux, WebClient, WebSocket, RSocket.
[集成] REST 客户端, JMS, JCA, JMX, Email, 任务, 调度, 缓存, 可见性.
语言 Kotlin, Groovy, Dynamic 语言.
附录 Spring 属性</description>
      <content:encoded><![CDATA[<ul>
<li>
<p><a href="Overview">概述</a> 历史，设计哲学，反馈，开始</p>
</li>
<li>
<p><a href="">核心</a> IoC容器，事件，资源，i18n，验证，数据绑定，类型转换，SpEL，AOP，AOT</p>
</li>
<li>
<p><a href="">测试</a> 对象 Mock，测试上下文框架，Spring MVC 测试，Web 测试客户端</p>
</li>
<li>
<p><a href="">数据接入</a> 事务，DAO 支持，JDBC，R2DBC，O/R 映射，XML 编码</p>
</li>
<li>
<p><a href="">Web Servlet</a> SpringMVC,WebSocket,SockJS,STOMP 通信</p>
</li>
<li>
<p><a href="">Web 响应式</a> Spring WebFlux, WebClient, WebSocket, RSocket.</p>
</li>
<li>
<p>[集成] REST 客户端, JMS, JCA, JMX, Email, 任务, 调度, 缓存, 可见性.</p>
</li>
<li>
<p><a href="">语言</a> Kotlin, Groovy, Dynamic 语言.</p>
</li>
<li>
<p><a href="">附录</a> Spring 属性</p>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>[译] SpringFramework 概述</title>
      <link>https://anriclee.github.io/posts/springframework/overview/</link>
      <pubDate>Sat, 02 Sep 2023 11:46:07 +0800</pubDate>
      
      <guid>https://anriclee.github.io/posts/springframework/overview/</guid>
      <description>概述 Spring 使得创建 Java 企业级应用更加容易。它提供了你在企业环境下拥抱 Java 语言所需要的一切，支持 JVM 平台上的 Groovy 和 Kotlin 作为备选语言，并且提供了根据应用程序的需求创建多种架构的灵活性。从 SpringFramework 6.0 开始，Spring 需要 Java 17 以上的版本。
Spring 支持广泛的应用场景。在一个大型企业里，应用程序经常会存在很长时间，并且必须运行在一个开发者不能控制升级周期的 JDK 和应用服务器上。 另外一些可能会作为一个内嵌服务器的单独 jar 包，运行在一个云环境里，还有一些可能是一个不需要服务器的独立应用程序（例如批处理或者集成处理工作）。
Spring 是开源的。它有一个庞大而活跃的社群，基于各种实际用例，提供持续反馈。这也帮助了 Spring 在相当长一段时间内成功发展。。
当我们在谈 Spring 时我们在谈什么 “Spring” 这个术语在不同的语境下有着不同的含义。它可以用来表示 SpringFramework 这个项目自身，一切都是从这里开始的（-译者按：梦开始的地方）。随着时间的推移，又构建了一些以 SpringFramework 为基础的 Spring 项目。大部分情况下，当人们谈论 Spring，他们的意思是 Spring 整个系列（-译者按：俗称全家桶）。本参考文档只针对这个基础进行介绍：SpringFramework 本身。
SpringFramework 被分成不同的模块。应用程序可以根据他们所需要的模块进行选择。这些模块中处于核心的是 core container，包括配置模型和依赖注入机制。除此之外，SpringFramework 还对于不同应用架构提供基础支持，包括消息传递、事务以及持久化和 web。它同时也包含了基于 Servlet 的 SpringMVC web 框架以及Spring WebFlux 响应式web框架。
关于这些模块需要注意的是：
Spring 的框架，允许部署到 JDK 9 的模块路径（&amp;ldquo;Jigsaw&amp;rdquo;）。对于在支持 “Jigsaw” 的应用程序中的使用，Spring Framework 5 的 jar 包里面，携带了 “Automatic-Module-Name” 的 manifest entries，它定义了稳定的语言级别模块名（例如：“spring.</description>
      <content:encoded><![CDATA[<h1 id="概述">概述</h1>
<p>Spring 使得创建 Java 企业级应用更加容易。它提供了你在企业环境下拥抱 Java 语言所需要的一切，支持 JVM 平台上的 Groovy 和 Kotlin 作为备选语言，并且提供了根据应用程序的需求创建多种架构的灵活性。从 SpringFramework 6.0 开始，Spring 需要 Java 17 以上的版本。</p>
<p>Spring 支持广泛的应用场景。在一个大型企业里，应用程序经常会存在很长时间，并且必须运行在一个开发者不能控制升级周期的 JDK 和应用服务器上。
另外一些可能会作为一个内嵌服务器的单独 jar 包，运行在一个云环境里，还有一些可能是一个不需要服务器的独立应用程序（例如批处理或者集成处理工作）。</p>
<p>Spring 是开源的。它有一个庞大而活跃的社群，基于各种实际用例，提供持续反馈。这也帮助了 Spring 在相当长一段时间内成功发展。。</p>
<h1 id="当我们在谈-spring-时我们在谈什么">当我们在谈 Spring 时我们在谈什么</h1>
<p>“Spring” 这个术语在不同的语境下有着不同的含义。它可以用来表示 SpringFramework 这个项目自身，一切都是从这里开始的（-译者按：梦开始的地方）。随着时间的推移，又构建了一些以 SpringFramework 为基础的 Spring 项目。大部分情况下，当人们谈论 Spring，他们的意思是 Spring 整个系列（-译者按：俗称全家桶）。本参考文档只针对这个基础进行介绍：SpringFramework 本身。</p>
<p>SpringFramework 被分成不同的模块。应用程序可以根据他们所需要的模块进行选择。这些模块中处于核心的是 core container，包括配置模型和依赖注入机制。除此之外，SpringFramework 还对于不同应用架构提供基础支持，包括消息传递、事务以及持久化和 web。它同时也包含了基于 Servlet 的 SpringMVC web 框架以及Spring WebFlux 响应式web框架。</p>
<p>关于这些模块需要注意的是：</p>
<p>Spring 的框架，允许部署到 JDK 9 的模块路径（&ldquo;Jigsaw&rdquo;）。对于在支持 “Jigsaw” 的应用程序中的使用，Spring Framework 5 的 jar 包里面，携带了 “Automatic-Module-Name” 的 manifest entries，它定义了稳定的语言级别模块名（例如：“spring.core”，“spring.context” 等等），它与 jar 的 artifact 名字独立（ 这些 jar 遵循同样的模式，例如 “spring-core” 和 “spring-context”。 “-” 代替 “.”</p>
<blockquote>
<p>译者按：本人对于 Jigsaw 不太熟悉，等后面熟悉了，再过来修正这一段的翻译。目前，是不知道这段说了什么的。</p>
</blockquote>
<p>当然，Spring 框架中的 jar 包，在 JDK 9 和 JDK 9+ 的 classpath 中，可以继续正常工作。</p>
<h1 id="spring-和-spring-framework-的历史">Spring 和 Spring Framework 的历史</h1>
<p>在 2003 年，为了应对 J2EE 早期规范的复杂性，Spring 应运而生。
虽然一些人认为 Java EE 和他的现代继承者 Jakarta EE 与 Spring 势不两立，但是他们实际上是互为补充的。
Spring 的编程模型不会拥抱 Jakarta EE 平台的规范，相反，它从传统的 EE 的笼罩下面，精心挑选了一些规范，并与之整合：</p>
<ul>
<li>
<p>Servlet API (JSR 340)</p>
</li>
<li>
<p>WebSocket API (JSR 356)</p>
</li>
<li>
<p>Concurrency Utilities (JSR 236)</p>
</li>
<li>
<p>JSON Binding API (JSR 367)</p>
</li>
<li>
<p>Bean Validation (JSR 303)</p>
</li>
<li>
<p>JPA (JSR 338)</p>
</li>
<li>
<p>JMS (JSR 914)</p>
</li>
<li>
<p>如果有必要的话，还有 JTA/JCA 用于事务协商的设置</p>
</li>
</ul>
<p>SpringFramework 还支持应用开发者使用依赖注入规范（JSR 330）和通用注解规范（JSR 250），代替 SpringFramework 提供的 Spring 规范机制。最初，他们都是基于 javax 包的。</p>
<blockquote>
<p>译者按：自由即长久。</p>
</blockquote>
<p>SpringFramework 6.0 里，Spring 已经升级到 Jakarta EE 9（例如：Servlet 5.0+，JPA 3.0+），基于 Jakarta 名称空间，而非传统的 javax 包。
从 EE 9 开始到现在已经支持的 EE 10，Spring 准备对 Jakarta EE 接口的进一步发展提供开箱即用的支持。</p>
<p>SpringFramework 6.0 已经完全兼容 Tomcat 10.1，Jetty 11 和 Undertow 2.3 作为 web 服务器，这其中也抱愧 Hibernate ORM 6.1.</p>
<p>随着时间的推移，Java/Jakarta EE 在应用开发中的角色在不断演进。在 J2EE 和 Spring 的早期，应用被创建后，部署到一个应用服务器上。</p>
<p>今天，在 Spring Boot 的帮助下，应用可以以一种 devops 和云友好的方式创建，内嵌 Servlet 容器，并且易于修改。从 SpringFramework 5 开始，WebFlux 应用甚至不直接使用 Servlet API 就可以在非 Servlet 的服务器上运行起来（例如 Netty）</p>
<p>Spring 持续创新和演进。除了 SpringFramework 之外，还有很多项目，例如 Spring Boot，Spring Security，Spring Data，Spring Cloud，Spring Batch。
值得记住的是：每一个项目都有它自己的源码仓库，问题追踪和发版节奏。可以在 <a href="https://spring.io/projects">spring.io/projects</a> 看到 Spring 项目的完整清单。</p>
<h1 id="设计哲学">设计哲学</h1>
<p>当你了解一个框架时，重要的不是知道它做了什么而是它遵循什么样的准则。SpringFramework 的指导准则如下：</p>
<ul>
<li>在每一个级别上提供选择。Spring 可以让你尽可能晚地推迟做出设计决策。比如，你可以在不更改代码的情况下，改变你的持久化方案。对于其他的基础设施问题，整合其他第三方的 API，这一点同样适用。</li>
<li>兼容并包。Spring 拥抱灵活性，并不介意事情是怎么被完成的。它提供了在不同观念下的诸多需要。</li>
<li>保持较强的向后兼容性。Spring 的演进经过精心管理，在版本之间，几乎没有特别大的变化。Spring 精心挑选 JDK 版本号范围以及第三方库，以方便维护依赖于 Spring 的应用以及库。</li>
<li>精心设计 API。Spring 团队投入了较多的时间和精力设计 API，目的是让 API 更加符合直觉，可以使用很多年，跨越多个版本。</li>
<li>对代码质量设置较高的标准。SpringFramework 重点强调有意义的、及时、精确的 javadoc。它是为数不多的声称拥有干净的代码架构且在不同的包之间没有循环引用的项目之一。</li>
</ul>
<h1 id="开始">开始</h1>
<p>如果你刚开始接触 Spring，你也许会从创建一个基于 SpringBoot 应用开始使用 SpringFramework。SpringBoot 提供了一个快速（固定）的方式来创建可部署生产环境的基于 Spring 的应用。它基于 SpringFramework，喜欢约定优于配置的风格，设计它就是为了让你能够尽可能快地启动和运行。</p>
<p>你可以使用<a href="https://start.spring.io/">start.spring.io</a>来生成一个基本的项目，或者遵循<a href="https://spring.io/guides">&ldquo;Getting Started&rdquo; 指南</a> 例如 <a href="https://spring.io/guides/gs/rest-service/">Getting Started Building a RESTful Web Service</a>。</p>
<p>这些指南都是任务导向且易于理解的，他们中的大部分是基于 SpringBoot。它同时也涵盖了 Spring 产品中的其他项目，这些你可能会在解决某个具体的问题时会使用到。</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
