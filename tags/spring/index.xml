<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Spring on ReadByWord</title>
    <link>https://anriclee.github.io/tags/spring/</link>
    <description>Recent content in Spring on ReadByWord</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 02 Sep 2023 23:12:31 +0800</lastBuildDate><atom:link href="https://anriclee.github.io/tags/spring/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[译]Spring IOC 容器</title>
      <link>https://anriclee.github.io/posts/translation_docs/spring_framework_ioc_container/</link>
      <pubDate>Sat, 02 Sep 2023 23:12:31 +0800</pubDate>
      
      <guid>https://anriclee.github.io/posts/translation_docs/spring_framework_ioc_container/</guid>
      <description>Spring IOC 和 bean 的简介 本章涵盖了 SpringFramework 中的控制反转原则（Ioc）的实现。IoC 也被称为依赖注入（DI）。它是这样的一种过程，在此期间对象仅通过构造函数参数、工厂方法的参数或者当对象实例被构造后或者通过工厂方法返回时在它上面设置的属性定义自己的依赖（即对象必须合作的其他对象）。
当容器创建这些 bean 后，再注入这些依赖。
这个过程本质上与bean 通过使用直接的类构造函数进行直接实例化或者通过类似 Service Locator模式来寻找依赖的位置是相反的（这也是 IoC 名字的由来）。
org.springframework.beans 和 org.springframework.context 包是 SpringFramework IoC 容器的基石。BeanFactory 接口提供了一种更先进的能够控制人已类型对象的配置机制。ApplicationContext 是 BeanFactory 的子接口。它增加了下面的特性：
与 Spring 的 AOP 特性更容易整合 消息资源处理（在国际化场景的使用） 事件发布 例如用于 Web 应用的 WebApplicationContext 应用层特定的上下文 总而言之，BeanFactory 提供了配置的框架和基本的功能。ApplicationContext 增加了更多的企业特定的功能。ApplicationContext 完全是 BeanFactory 的超集。在本章关于 Spring IoC 容器做专门描述时会用到。想要获取更多的关于使用 ApplicationContext 而非 BeanFactory 的信息，参见介绍 BeanFactory API 的部分。
在 Spring 中，作为你应用基石同时可以被 Spring IoC 容器所操控的对象就被称之为 bean。bean 就是被 Spring IoC 容器实例化、组装和设置的对象。否则，一个 bean 就是你应用程序中诸多对象中的一个。 Beans 以及他们依赖关系，反映在容器使用的配置元数据中。</description>
      <content:encoded><![CDATA[<h1 id="spring-ioc-和-bean-的简介">Spring IOC 和 bean 的简介</h1>
<p>本章涵盖了 SpringFramework 中的控制反转原则（Ioc）的实现。IoC 也被称为依赖注入（DI）。它是这样的一种过程，在此期间对象仅通过构造函数参数、工厂方法的参数或者当对象实例被构造后或者通过工厂方法返回时在它上面设置的属性定义自己的依赖（即对象必须合作的其他对象）。</p>
<p>当容器创建这些 bean 后，再注入这些依赖。</p>
<p>这个过程本质上与bean 通过使用直接的类构造函数进行直接实例化或者通过类似 Service Locator模式来寻找依赖的位置是相反的（这也是 IoC 名字的由来）。</p>
<p><code>org.springframework.beans</code> 和 <code>org.springframework.context</code> 包是 SpringFramework IoC 容器的基石。<code>BeanFactory</code> 接口提供了一种更先进的能够控制人已类型对象的配置机制。<code>ApplicationContext</code> 是 <code>BeanFactory</code> 的子接口。它增加了下面的特性：</p>
<ul>
<li>与 Spring 的 AOP 特性更容易整合</li>
<li>消息资源处理（在国际化场景的使用）</li>
<li>事件发布</li>
<li>例如用于 Web 应用的 <code>WebApplicationContext</code> 应用层特定的上下文</li>
</ul>
<p>总而言之，<code>BeanFactory</code> 提供了配置的框架和基本的功能。<code>ApplicationContext</code> 增加了更多的企业特定的功能。<code>ApplicationContext</code> 完全是 <code>BeanFactory</code> 的超集。在本章关于 Spring IoC 容器做专门描述时会用到。想要获取更多的关于使用 <code>ApplicationContext</code> 而非 <code>BeanFactory</code> 的信息，参见介绍 <a href="https://docs.spring.io/spring-framework/reference/core/beans/beanfactory.html">BeanFactory</a> API 的部分。</p>
<p>在 Spring 中，作为你应用基石同时可以被 Spring IoC 容器所操控的对象就被称之为 bean。bean 就是被 Spring IoC 容器实例化、组装和设置的对象。否则，一个 bean 就是你应用程序中诸多对象中的一个。 Beans 以及他们依赖关系，反映在容器使用的配置元数据中。</p>
<h1 id="容器概述">容器概述</h1>
<p><code>org.springframework.context.ApplicationContext</code> 接口代表了 Spring IoC 容器，它主要负责通过读取配置文件对 bean 进行实例化、配置和组装。
容器通过读取配置元数据来获知要实例化、配置和组装那些对象。配置的元数据一般为 XML、Java 注解和 Java 代码的形式，它让你能够表达组成你应用程序的对象以及对象之间的丰富的相互依赖关系。</p>
<p>Spring 提供了 <code>ApplicationContext</code> 接口的若干实现。在单体应用中，创建一个 <code>ClassPathXmlApplicationContext</code> 或者 <code>FileSystemXmlApplicationContext</code> 是很常见的。虽然 XML 是定义配置元数据的传统形式，但是你还可以通过在 XML 文件里面进行声明配置来告诉容器对于 Java 注解或者Java代码格式的支持。</p>
<p>在大多数的应用场景中，并不需要显式的代码来实例化 Spring IoC 容器。例如，在 Web 应用的场景中，在 <code>web.xml</code> 文件中仅用简单的 8 行代码左右的样板 Web XML 描述符即可满足需要（参考 <a href="https://docs.spring.io/spring-framework/reference/core/beans/context-introduction.html#context-create">Convenient ApplicationContext Instantiation for Web Applications</a>）。如果你使 Eclipse 中的 Spring 工具（在 Eclipse 开发环境中），你可以通过几下鼠标点击或者按键的敲击就能轻松创建这样一个样板配置文件。</p>
<p>下图展示了关于 Spring 工作机制的一个全局视角。在 <code>ApplicationContext</code> 被创建和初始化后，你的应用类和配置元数据已经捆绑在一起了，这样一来，你就有一个充分配置并且可执行的系统或者应用程序。</p>
<p></p>
<h1 id="配置元数据">配置元数据</h1>
<p>如上图所示，Spring Ioc 容器接收到一种格式的配置元数据。这个配置元数据代表了，作为一个应用开发者你告诉 Spring 容器在应用程序中，如何实例化、配置和组装对象。</p>
<p>传统的配置元数据是一种简单并且符合直觉的 XML 形式，在本章的大部分地方，也用此来表达关键的概念和 Spring IoC 容器的特性。</p>
<blockquote>
<p>基于 XML 的元数据不是配置元数据的唯一允许的形式。Spring IoC 容器自身与配置元数据实际上是什么格式完全解耦。目前许多开发者在应用程序中选择<a href="https://docs.spring.io/spring-framework/reference/core/beans/java.html">基于Java 的配置</a>。</p>
</blockquote>
<p>在 Spring 容器中使用其他格式的配置元数据，可参考：</p>
<ul>
<li><a href="https://docs.spring.io/spring-framework/reference/core/beans/annotation-config.html">基于注解的配置</a>：通过基于注解的配置元数据定义 beans</li>
<li><a href="https://docs.spring.io/spring-framework/reference/core/beans/java.html">基于Java的配置</a>：通过使用 Java 而不是 XML 文件来定义你应用类之外的 beans。使用这些特性可以参考 <a href="https://docs.spring.io/spring-framework/docs/6.0.11/javadoc-api/org/springframework/context/annotation/Configuration.html">@Configuration</a>, <a href="https://docs.spring.io/spring-framework/docs/6.0.11/javadoc-api/org/springframework/context/annotation/Bean.html">@Bean</a>, <a href="https://docs.spring.io/spring-framework/docs/6.0.11/javadoc-api/org/springframework/context/annotation/Import.html">@Import</a>, <a href="https://docs.spring.io/spring-framework/docs/6.0.11/javadoc-api/org/springframework/context/annotation/DependsOn.html">@DependsOn</a> 注解。</li>
</ul>
<p>TO BE CONTINUED &hellip;..</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>[译] SpringFramework 概述</title>
      <link>https://anriclee.github.io/posts/translation_docs/spring_framework_overview/</link>
      <pubDate>Sat, 02 Sep 2023 11:46:07 +0800</pubDate>
      
      <guid>https://anriclee.github.io/posts/translation_docs/spring_framework_overview/</guid>
      <description>概述 Spring 使得创建 Java 企业级应用更加容易。它提供了你在企业环境下拥抱 Java 语言所需要的一切，支持 JVM 平台上的 Groovy 和 Kotlin 作为备选语言，并且提供了根据应用程序的需求创建多种架构的灵活性。从 SpringFramework 6.0 开始，Spring 需要 Java 17 以上的版本。
Spring 支持广泛的应用场景。在一个大型企业里，应用程序经常会存在很长时间，并且必须运行在一个开发者不能控制升级周期的 JDK 和应用服务器上。 另外一些可能会作为一个内嵌服务器的单独 jar 包，运行在一个云环境里，还有一些可能是一个不需要服务器的独立应用程序（例如批处理或者集成处理工作）。
Spring 是开源的。它有一个庞大而活跃的社群，基于各种实际用例，提供持续反馈。这也帮助了 Spring 在相当长一段时间内成功发展。。
当我们在谈 Spring 时我们在谈什么 “Spring” 这个术语在不同的语境下有着不同的含义。它可以用来表示 SpringFramework 这个项目自身，一切都是从这里开始的（-译者按：梦开始的地方）。随着时间的推移，又构建了一些以 SpringFramework 为基础的 Spring 项目。大部分情况下，当人们谈论 Spring，他们的意思是 Spring 整个系列（-译者按：俗称全家桶）。本参考文档只针对这个基础进行介绍：SpringFramework 本身。
SpringFramework 被分成不同的模块。应用程序可以根据他们所需要的模块进行选择。这些模块中处于核心的是 core container，包括配置模型和依赖注入机制。除此之外，SpringFramework 还对于不同应用架构提供基础支持，包括消息传递、事务以及持久化和 web。它同时也包含了基于 Servlet 的 SpringMVC web 框架以及Spring WebFlux 响应式web框架。
关于这些模块需要注意的是：
Spring 的框架，允许部署到 JDK 9 的模块路径（&amp;ldquo;Jigsaw&amp;rdquo;）。对于在支持 “Jigsaw” 的应用程序中的使用，Spring Framework 5 的 jar 包里面，携带了 “Automatic-Module-Name” 的 manifest entries，它定义了稳定的语言级别模块名（例如：“spring.</description>
      <content:encoded><![CDATA[<h1 id="概述">概述</h1>
<p>Spring 使得创建 Java 企业级应用更加容易。它提供了你在企业环境下拥抱 Java 语言所需要的一切，支持 JVM 平台上的 Groovy 和 Kotlin 作为备选语言，并且提供了根据应用程序的需求创建多种架构的灵活性。从 SpringFramework 6.0 开始，Spring 需要 Java 17 以上的版本。</p>
<p>Spring 支持广泛的应用场景。在一个大型企业里，应用程序经常会存在很长时间，并且必须运行在一个开发者不能控制升级周期的 JDK 和应用服务器上。
另外一些可能会作为一个内嵌服务器的单独 jar 包，运行在一个云环境里，还有一些可能是一个不需要服务器的独立应用程序（例如批处理或者集成处理工作）。</p>
<p>Spring 是开源的。它有一个庞大而活跃的社群，基于各种实际用例，提供持续反馈。这也帮助了 Spring 在相当长一段时间内成功发展。。</p>
<h1 id="当我们在谈-spring-时我们在谈什么">当我们在谈 Spring 时我们在谈什么</h1>
<p>“Spring” 这个术语在不同的语境下有着不同的含义。它可以用来表示 SpringFramework 这个项目自身，一切都是从这里开始的（-译者按：梦开始的地方）。随着时间的推移，又构建了一些以 SpringFramework 为基础的 Spring 项目。大部分情况下，当人们谈论 Spring，他们的意思是 Spring 整个系列（-译者按：俗称全家桶）。本参考文档只针对这个基础进行介绍：SpringFramework 本身。</p>
<p>SpringFramework 被分成不同的模块。应用程序可以根据他们所需要的模块进行选择。这些模块中处于核心的是 core container，包括配置模型和依赖注入机制。除此之外，SpringFramework 还对于不同应用架构提供基础支持，包括消息传递、事务以及持久化和 web。它同时也包含了基于 Servlet 的 SpringMVC web 框架以及Spring WebFlux 响应式web框架。</p>
<p>关于这些模块需要注意的是：</p>
<p>Spring 的框架，允许部署到 JDK 9 的模块路径（&ldquo;Jigsaw&rdquo;）。对于在支持 “Jigsaw” 的应用程序中的使用，Spring Framework 5 的 jar 包里面，携带了 “Automatic-Module-Name” 的 manifest entries，它定义了稳定的语言级别模块名（例如：“spring.core”，“spring.context” 等等），它与 jar 的 artifact 名字独立（ 这些 jar 遵循同样的模式，例如 “spring-core” 和 “spring-context”。 “-” 代替 “.”</p>
<blockquote>
<p>译者按：本人对于 Jigsaw 不太熟悉，等后面熟悉了，再过来修正这一段的翻译。目前，是不知道这段说了什么的。</p>
</blockquote>
<p>当然，Spring 框架中的 jar 包，在 JDK 9 和 JDK 9+ 的 classpath 中，可以继续正常工作。</p>
<h1 id="spring-和-spring-framework-的历史">Spring 和 Spring Framework 的历史</h1>
<p>在 2003 年，为了应对 J2EE 早期规范的复杂性，Spring 应运而生。
虽然一些人认为 Java EE 和他的现代继承者 Jakarta EE 与 Spring 势不两立，但是他们实际上是互为补充的。
Spring 的编程模型不会拥抱 Jakarta EE 平台的规范，相反，它从传统的 EE 的笼罩下面，精心挑选了一些规范，并与之整合：</p>
<ul>
<li>
<p>Servlet API (JSR 340)</p>
</li>
<li>
<p>WebSocket API (JSR 356)</p>
</li>
<li>
<p>Concurrency Utilities (JSR 236)</p>
</li>
<li>
<p>JSON Binding API (JSR 367)</p>
</li>
<li>
<p>Bean Validation (JSR 303)</p>
</li>
<li>
<p>JPA (JSR 338)</p>
</li>
<li>
<p>JMS (JSR 914)</p>
</li>
<li>
<p>如果有必要的话，还有 JTA/JCA 用于事务协商的设置</p>
</li>
</ul>
<p>SpringFramework 还支持应用开发者使用依赖注入规范（JSR 330）和通用注解规范（JSR 250），代替 SpringFramework 提供的 Spring 规范机制。最初，他们都是基于 javax 包的。</p>
<blockquote>
<p>译者按：自由即长久。</p>
</blockquote>
<p>SpringFramework 6.0 里，Spring 已经升级到 Jakarta EE 9（例如：Servlet 5.0+，JPA 3.0+），基于 Jakarta 名称空间，而非传统的 javax 包。
从 EE 9 开始到现在已经支持的 EE 10，Spring 准备对 Jakarta EE 接口的进一步发展提供开箱即用的支持。</p>
<p>SpringFramework 6.0 已经完全兼容 Tomcat 10.1，Jetty 11 和 Undertow 2.3 作为 web 服务器，这其中也抱愧 Hibernate ORM 6.1.</p>
<p>随着时间的推移，Java/Jakarta EE 在应用开发中的角色在不断演进。在 J2EE 和 Spring 的早期，应用被创建后，部署到一个应用服务器上。</p>
<p>今天，在 Spring Boot 的帮助下，应用可以以一种 devops 和云友好的方式创建，内嵌 Servlet 容器，并且易于修改。从 SpringFramework 5 开始，WebFlux 应用甚至不直接使用 Servlet API 就可以在非 Servlet 的服务器上运行起来（例如 Netty）</p>
<p>Spring 持续创新和演进。除了 SpringFramework 之外，还有很多项目，例如 Spring Boot，Spring Security，Spring Data，Spring Cloud，Spring Batch。
值得记住的是：每一个项目都有它自己的源码仓库，问题追踪和发版节奏。可以在 <a href="https://spring.io/projects">spring.io/projects</a> 看到 Spring 项目的完整清单。</p>
<h1 id="设计哲学">设计哲学</h1>
<p>当你了解一个框架时，重要的不是知道它做了什么而是它遵循什么样的准则。SpringFramework 的指导准则如下：</p>
<ul>
<li>在每一个级别上提供选择。Spring 可以让你尽可能晚地推迟做出设计决策。比如，你可以在不更改代码的情况下，改变你的持久化方案。对于其他的基础设施问题，整合其他第三方的 API，这一点同样适用。</li>
<li>兼容并包。Spring 拥抱灵活性，并不介意事情是怎么被完成的。它提供了在不同观念下的诸多需要。</li>
<li>保持较强的向后兼容性。Spring 的演进经过精心管理，在版本之间，几乎没有特别大的变化。Spring 精心挑选 JDK 版本号范围以及第三方库，以方便维护依赖于 Spring 的应用以及库。</li>
<li>精心设计 API。Spring 团队投入了较多的时间和精力设计 API，目的是让 API 更加符合直觉，可以使用很多年，跨越多个版本。</li>
<li>对代码质量设置较高的标准。SpringFramework 重点强调有意义的、及时、精确的 javadoc。它是为数不多的声称拥有干净的代码架构且在不同的包之间没有循环引用的项目之一。</li>
</ul>
<h1 id="开始">开始</h1>
<p>如果你刚开始接触 Spring，你也许会从创建一个基于 SpringBoot 应用开始使用 SpringFramework。SpringBoot 提供了一个快速（固定）的方式来创建可部署生产环境的基于 Spring 的应用。它基于 SpringFramework，喜欢约定优于配置的风格，设计它就是为了让你能够尽可能快地启动和运行。</p>
<p>你可以使用<a href="https://start.spring.io/">start.spring.io</a>来生成一个基本的项目，或者遵循<a href="https://spring.io/guides">&ldquo;Getting Started&rdquo; 指南</a> 例如 <a href="https://spring.io/guides/gs/rest-service/">Getting Started Building a RESTful Web Service</a>。</p>
<p>这些指南都是任务导向且易于理解的，他们中的大部分是基于 SpringBoot。它同时也涵盖了 Spring 产品中的其他项目，这些你可能会在解决某个具体的问题时会使用到。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>[译]SpringFramework</title>
      <link>https://anriclee.github.io/posts/translation_docs/spring/</link>
      <pubDate>Sat, 02 Sep 2023 11:43:42 +0800</pubDate>
      
      <guid>https://anriclee.github.io/posts/translation_docs/spring/</guid>
      <description>以下为本系列的目录归档：
概述
核心技术
IOC 容器 </description>
      <content:encoded><![CDATA[<p>以下为本系列的目录归档：</p>
<p><a href="/posts/translation_docs/spring_framework_overview">概述</a></p>
<p><a href="">核心技术</a></p>
<ul>
<li><a href="">IOC 容器</a></li>
</ul>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
